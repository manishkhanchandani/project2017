<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Untitled Document</title>
<style type="text/css">
<!--
body {
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: 11px;
}
-->
</style>
</head>

<body>
<h1>Problems</h1>
<table width="100%" border="1" cellspacing="0" cellpadding="5">
    <tr><td valign="top"><a href="#1-two-sum-js">1 Two Sum.js</a></td>
    <td valign="top">&nbsp;</td>
    <tr>
        <td valign="top"><a href="#2-add-two-numbers-js">2 Add Two Numbers.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#3-longest-substring-without-repeating-characters-js">3 Longest Substring Without Repeating Characters.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr><td valign="top"><a href="#10-regular-expresion-matching-js">10 Regular Expresion Matching.js</a></td>
    <td valign="top">&nbsp;</td>
    <tr>
        <td valign="top"><a href="#11-container-with-most-water-js">11 Container With Most Water.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#12-integer-to-roman-js">12 Integer to Roman.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#13-roman-to-integer-js">13 Roman to Integer.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#14-longest-common-prefix-js">14 Longest Common Prefix.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#15-3sum-js">15 3Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#16-3sum-closest-js">16 3Sum Closest.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#17-letter-combinations-of-a-phone-number-js">17 Letter Combinations of a Phone Number.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#18-4sum-js">18. 4Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#19-remove-nth-node-from-end-of-list-js">19 Remove Nth Node From End of List.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#20-valid-parentheses-js">20 Valid Parentheses.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#21-merge-two-sorted-lists-js">21 Merge Two Sorted Lists.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#22-generate-parentheses-js">22 Generate Parentheses.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#23-merge-k-sorted-lists-js">23 Merge k Sorted Lists.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#24-swap-nodes-in-pairs-js">24 Swap nodes in Pairs.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#25-reverse-nodes-in-k-group-js">25 Reverse Nodes in k-Group.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#26-remove-duplicates-from-sorted-array-js">26 Remove Duplicates from Sorted Array.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#27-remove-element-js">27 Remove Element.js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><a href="#28-implement-strstr-js">28 Implement strStr().js</a></td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr><td valign="top"><a href="#100-same-tree-js">100 Same Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#101-symmetric-tree-js">101 Symmetric Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#102-binary-tree-level-order-traversal-js">102 Binary Tree Level Order Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#103-binary-tree-zigzag-level-order-traversal-js">103 Binary Tree Zigzag Level Order Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#104-maximum-depth-of-binary-tree-js">104 Maximum Depth of Binary Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal-js">105 Construct Binary Tree from Preorder and Inorder Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal-js">106 Construct Binary Tree from Inorder and Postorder Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#107-binary-tree-level-order-traversal-ii-js">107 Binary Tree Level Order Traversal II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#108-convert-sorted-array-to-binary-search-tree-js">108 Convert Sorted Array to Binary Search Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#110-balanced-binary-tree-js">110 Balanced Binary Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#111-minimum-depth-of-binary-tree-js">111 Minimum Depth of Binary Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#112-path-sum-js">112 Path Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#114-flatten-binary-tree-to-linked-list-js">114 Flatten Binary Tree to Linked List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#116-populating-next-right-pointers-in-each-node-js">116 Populating Next Right Pointers in Each Node.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#117-populating-next-right-pointer-js">117 Populating Next Right Pointer.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#117-populating-next-right-pointers-in-each-node-ii-js">117 Populating Next Right Pointers in Each Node II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#118-pascal-s-triangle-js">118 Pascal's Triangle.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#119-pascal-s-triangle-ii-js">119 Pascal's Triangle II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#120-triangle-js">120 Triangle.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#121-best-time-to-buy-and-sell-stock-js">121 Best Time to Buy and Sell Stock.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#122-best-time-to-buy-and-sell-stock-ii-js">122 Best Time to Buy and Sell Stock II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#123-best-time-to-buy-and-sell-stock-iii-js">123 Best Time to Buy and Sell Stock III.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#124-binary-tree-maximum-path-sum-js">124 Binary Tree Maximum Path Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#125-valid-palindrome-js">125 Valid Palindrome.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#126-word-ladder-ii-js">126 Word Ladder II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#127-word-ladder-js">127 Word Ladder.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#128-longest-consecutive-sequence-js">128 Longest Consecutive Sequence.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#129-sum-root-to-leaf-numbers-js">129 Sum Root to Leaf Numbers.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#131-palindrome-partitioning-js">131 Palindrome Partitioning.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#133-clone-graph-js">133 Clone Graph.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#136-single-number-js">136 Single Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#137-single-number-ii-js">137 Single Number II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#138-copy-list-with-random-pointer-js">138 Copy List With Random Pointer.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#139-word-break-js">139 Word Break.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#140-word-break-ii-js">140 Word Break II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#141-linked-list-cycle-js">141 Linked List Cycle.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#144-binary-tree-preorder-traversal-my-submissions-question-js">144 Binary Tree Preorder Traversal My Submissions Question.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#145-binary-tree-post-order-traversal-js">145 Binary Tree Post Order Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#146-lru-cache-js">146 LRU Cache.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#148-sort-list-js">148 Sort List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#149-max-points-on-a-line-js">149 Max Points on a Line.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#150-evaluate-reverse-polish-notation-js">150 Evaluate Reverse Polish Notation.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#151-reverse-words-in-a-string-js">151 Reverse Words in a String.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#152-maximum-product-subarray-js">152 Maximum Product Subarray.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#153-find-minimum-in-rotated-sorted-array-js">153 Find Minimum in Rotated Sorted Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#155-min-stack-js">155 Min Stack.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#156-binary-tree-upside-down-js">156 Binary Tree Upside Down.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#157-read-n-characters-given-read4-js">157 Read N Characters Given Read4.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#158-read-n-characters-give-read4-ii-call-multiple-times-js">158 Read N Characters Give Read4 II - Call Multiple Times.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#159-longest-substring-with-at-most-two-disctinct-characters-js">159 Longest Substring with At Most Two Disctinct Characters.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#160-intersection-of-two-linked-lists-js">160 Intersection Of Two Linked Lists.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#161-one-edit-distance-js">161 One Edit Distance.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#162-find-peak-element-js">162 Find Peak Element.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#165-compare-version-numbers-js">165 Compare Version Numbers.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#166-fraction-to-recurring-decimal-js">166 Fraction to Recurring Decimal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#168-excel-sheet-column-title-js">168 Excel Sheet Column Title.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#169-majority-element-js">169 Majority Element.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#170-two-sum-iii-data-structure-design-js">170 Two Sum III - Data structure design.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#171-excel-sheet-column-number-js">171 Excel Sheet Column Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#172-factorial-trailing-zeroes-js">172 Factorial Trailing Zeroes.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#173-binary-search-tree-iterator-js">173 Binary Search Tree Iterator.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#179-largest-number-js">179 Largest Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#186-reverse-words-in-a-string-ii-js">186 Reverse Words in a String II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#187-repeated-dna-sequences-js">187 Repeated DNA Sequences.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#188-best-time-to-buy-and-sell-stock-iv-js">188 Best Time to Buy and Sell Stock IV.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#189-rotate-array-js">189 Rotate Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#190-reverse-bits-js">190 Reverse Bits.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#191-number-of-1-bits-js">191 Number of 1 Bits.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#198-house-robber-js">198 House Robber.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#199-binary-tree-right-side-view-js">199 Binary Tree Right Side View.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#200-number-of-islands-js">200 Number of Islands.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#201-bitwise-and-of-numbers-range-js">201 Bitwise AND of Numbers Range.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#202-happy-number-js">202 Happy Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#203-remove-linked-list-elements-js">203 Remove Linked List Elements.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#204-count-primes-js">204 Count Primes.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#205-isomorphic-strings-js">205 Isomorphic Strings.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#206-reverse-linked-list-js">206 Reverse Linked List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#207-course-schedule-js">207 Course Schedule.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#208-implement-trie-prefix-tree-js">208 Implement Trie (Prefix Tree).js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#209-minimum-size-subarray-sum-js">209 Minimum Size Subarray Sum.js</a></td>
    <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#210-course-schedule-ii-js">210 Course Schedule II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#211-add-and-search-word-data-structure-design-js">211 Add and Search Word - Data structure design.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#212-word-search-ii-js">212 Word Search II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#213-house-robber-ii-js">213 House Robber II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#215-kth-largest-element-in-an-array-js">215 Kth Largest Element in an Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#215-kth-largest-element-in-an-array-py">215 Kth Largest Element in an Array.py</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#217-contain-duplicate-js">217 Contain Duplicate.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#219-contains-duplicate-ii-js">219 Contains Duplicate II.js</a></td>
    <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#220-contains-duplicate-iii-js">220 Contains Duplicate III.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#221-maximal-square-js">221 Maximal Square.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#222-count-complete-tree-nodes-js">222. Count Complete Tree Nodes.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#223-rectangle-area-js">223 Rectangle Area.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#224-basic-calculator-js">224 Basic Calculator.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#225-implement-stack-using-queues-js">225 Implement Stack Using Queues.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#226-invert-binary-tree-js">226 Invert Binary Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#228-summary-ranges-js">228 Summary Ranges.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#229-majority-element-ii-js">229 Majority Element II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#231-power-of-two-js">231 Power of Two.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#232-implement-queue-using-stacks-js">232 Implement Queue using Stacks.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#233-number-of-digit-one-js">233 Number of Digit One.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#234-palindrome-linked-list-js">234 Palindrome Linked List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#235-lowest-common-ancestor-of-a-binary-search-tree-js">235 Lowest Common Ancestor Of a Binary Search Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#236-lowest-common-ancestor-of-a-binary-tree-js">236 Lowest Common Ancestor of a Binary Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#237-delete-node-in-a-linked-list-js">237 Delete Node in a Linked List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#238-product-of-array-except-self-js">238 Product of Array Except Self.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#239-sliding-window-maximum-js">239 Sliding Window Maximum.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#240-search-a-2d-matrix-ii-js">240 Search a 2D Matrix II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#241-different-ways-to-add-parentheses-js">241 Different Ways to Add Parentheses.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#242-valid-anagram-js">242 Valid Anagram.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#243-shortest-word-distance-js">243 Shortest Word Distance.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#244-shortest-word-distance-ii-js">244 Shortest Word Distance II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#245-shortest-word-distance-iii-js">245 Shortest Word Distance III.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#249-group-shifted-strings-js">249 Group Shifted Strings.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#252-meeting-rooms-js">252 Meeting Rooms.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#253-meeting-rooms-ii-js">253 Meeting Rooms II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#254-factor-combinations-js">254 Factor Combinations.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#256-paint-house-js">256 Paint House.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#257-binary-tree-paths-js">257 Binary Tree Paths.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#260-single-number-iii-js">260. Single Number III.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#261-graph-valid-tree-js">261 Graph Valid Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#263-ugly-number-js">263 Ugly Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#264-ugly-number-ii-js">264 Ugly Number II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#265-paint-house-ii-js">265 Paint House II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#266-palindrome-permutation-js">266 Palindrome Permutation.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#268-missing-number-js">268 Missing Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#269-alien-dictionary-js">269 Alien Dictionary.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#277-find-the-celebrity-js">277 Find the Celebrity.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#278-first-bad-version-js">278 First Bad Version.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#279-perfect-squares-js">279. Perfect Squares.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#282-expression-add-operators-js">282 Expression Add Operators.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#283-move-zeroes-js">283 Move Zeroes.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#285-inorder-successor-in-bst-js">285 Inorder Successor in BST.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#286-walls-and-gates-js">286 Walls and Gates.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#289-game-of-life-js">289. Game of Life.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#293-flip-game-js">293 Flip Game.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#294-flip-game-ii-js">294 Flip Game II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#295-find-median-from-data-stream-js">295 Find Median From Data Stream.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#296-best-meeting-point-js">296 Best Meeting Point.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#297-serialize-and-deserialize-binary-tree-my-submissions-question-js">297 Serialize and Deserialize Binary Tree My Submissions Question.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#300-longest-increasing-subsequence-js">300 Longest Increasing Subsequence.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#301-remove-invalid-parentheses-js">301 Remove Invalid Parentheses.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#307-range-sum-query-mutable-js">307 Range Sum Query - Mutable.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#31-next-permutation-js">31 Next Permutation.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#311-sparse-matrix-multiplication-js">311 Sparse Matrix Multiplication.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#314-binary-tree-vertical-order-traversal-js">314 Binary Tree Vertical Order Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#317-shortest-distance-from-all-buildings-js">317 Shortest Distance From All Buildings.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#318-maximum-product-of-word-lengths-my-submissions-question-js">318 Maximum Product of Word Lengths My Submissions Question.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#320-generalized-abbreviation-js">320 Generalized Abbreviation.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#322-coin-change-js">322 Coin Change.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#325-maximum-size-subarray-sum-equals-k-js">325 Maximum Size Subarray Sum Equals k.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#33-search-in-rotated-sorted-array-js">33 Search in Rotated Sorted Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#334-increasing-triplet-subsequence-js">334 Increasing Triplet Subsequence.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#335-self-crossing-js">335 Self Crossing.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#337-house-robber-iii-js">337 House Robber III.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#338-count-bits-js">338 Count Bits.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#339-nested-list-weight-sum-js">339 Nested List Weight Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#34-search-for-a-range-js">34 Search for a Range.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#340-longest-substring-with-at-most-k-distinct-characters-js">340 Longest Substring With At Most K Distinct Characters.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#341-flatten-nested-list-iterator-js">341 Flatten Nested List Iterator.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#348-design-tic-tac-toe-java">348. Design Tic-Tac-Toe.java</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#349-intersection-of-two-arrays-js">349 Intersection of Two Arrays.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#35-search-insert-position-js">35 Search Insert Position.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#350-intersection-of-two-arrays-ii-js">350 Intersection of Two Arrays II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#353-design-snake-game-js">353 Design Snake Game.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#36-valid-sudoku-js">36 Valid Sudoku.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#364-nested-list-weight-sum-ii-js">364 Nested List Weight Sum II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#366-find-leaves-of-binary-tree-js">366 Find Leaves of Binary Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#367-valid-perfect-square-js">367 Valid Perfect Square.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#37-sudoku-solver-js">37 Sudoku Solver.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#371-sum-of-two-integers-js">371 Sum of Two Integers.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#38-count-and-say-js">38 Count and Say.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#39-combination-sum-js">39 Combination Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#4-median-of-two-sorted-arrays-js">4. Median of Two Sorted Arrays.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#40-combination-sum-ii-js">40 combination Sum II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#42-trapping-rain-water-js">42 Trapping Rain Water.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#43-multiply-strings-js">43 Multiply Strings.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#44-wildcard-matching-js">44 Wildcard Matching.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#45-jump-game-ii-js">45 Jump Game II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#46-permutations-js">46 Permutations.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#47-permutations-ii-js">47 Permutations II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#48-rotate-image-js">48 Rotate Image.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#49-anagrams-js">49 Anagrams.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#49-group-anagrams-js">49 Group Anagrams.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#5-longest-palindromic-substring-js">5 Longest Palindromic Substring.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#50-pow-x-n-js">50 Pow(x, n).js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#51-n-queens-js">51 N-Queens.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#53-maximum-subarray-js">53 Maximum Subarray.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#532-k-diff-pairs-in-an-array-js">532. K-diff Pairs in an Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#54-spiral-matrix-js">54 Spiral Matrix.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#55-jump-game-js">55 Jump Game.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#56-merge-intervals-js">56. Merge Intervals.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#57-insert-interval-js">57. Insert Interval.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#58-length-of-last-word-js">58 Length of Last Word.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#59-spiral-matrix-ii-js">59 Spiral Matrix II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#61-rotate-list-js">61 Rotate List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#62-unique-paths-js">62 Unique Paths.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#63-unique-paths-ii-js">63 Unique Paths II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#64-minimum-path-sum-js">64 Minimum Path Sum.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#65-valid-number-js">65 Valid Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#66-plus-one-js">66 Plus One.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#67-add-binary-js">67 Add Binary.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#68-text-justification-js">68 Text Justification.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#69-sqrt-x-js">69 Sqrt(x).js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#70-climbing-stairs-js">70 Climbing Stairs.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#71-simplify-path-js">71 Simplify Path.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#72-edit-distance-js">72 Edit Distance.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#74-search-a-2d-matrix-js">74 Search a 2D Matrix.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#75-sort-colors-js">75 Sort Colors.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#76-minimum-window-substring-js">76 Minimum Window Substring.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#77-combinations-js">77 Combinations.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#78-subsets-js">78 Subsets.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#79-word-search-js">79 Word Search.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#8-string-to-integer-atoi-js">8 String to Integer (atoi).js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#80-remove-duplicates-from-sorted-array-ii-js">80 Remove Duplicates from Sorted Array II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#81-search-in-rotated-sorted-array-ii-js">81 Search in Rotated Sorted Array II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#82-remove-duplicates-from-sorted-list-ii-js">82 Remove Duplicates from Sorted List II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#83-remove-duplicates-from-sorted-list-js">83 Remove Duplicates from Sorted List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#84-largest-rectangle-in-histogram-js">84 Largest Rectangle in Histogram.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#85-maximal-rectangle-js">85 Maximal Rectangle.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#86-partition-list-js">86 Partition List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#88-merge-sorted-array-js">88 Merge Sorted Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#89-gray-code-js">89 Gray Code.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#9-palindrome-number-js">9 Palindrome Number.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#90-subsets-ii-js">90 Subsets II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#91-decode-ways-js">91 Decode Ways.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#92-reverse-linked-list-ii-js">92 Reverse Linked List II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#93-restore-ip-addresses-js">93 Restore IP Addresses.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#94-binary-tree-inorder-traversal-js">94 Binary Tree Inorder Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#95-unique-binary-search-trees-ii-js">95 Unique Binary Search Trees II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#96-unique-binary-search-trees-js">96 Unique Binary Search Trees.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#98-validate-binary-search-tree-js">98 Validate Binary Search Tree.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#basic-calculator-ii-js">Basic Calculator II.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#basic-calculator-iii-js">Basic Calculator III.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#bean-probability-js">Bean Probability.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#can-win-js">Can Win.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#conjuct-names-with-limit-js">Conjuct Names With Limit.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#convert-binary-search-tree-to-doubly-linked-list-js">Convert Binary Search Tree To Doubly Linked List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#convert-infix-to-reverse-polish-notation-js">Convert Infix to Reverse Polish Notation.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#custom-tree-problem-js">Custom Tree Problem.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#data-structure-max-heap-js">Data Structure Max Heap.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#data-structure-min-heap-js">Data Structure Min Heap.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#disambiguos-actors-js">Disambiguos Actors.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#find-duplicate-files-js">Find Duplicate Files.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#find-median-in-k-sorted-arrays-js">Find Median in  K Sorted Arrays.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#javascript-closure-questions-js">Javascript Closure Questions.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#job-sequencing-problem-js">Job Sequencing Problem.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#log-hits-js">Log Hits.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#longest-common-subsequence-js">Longest Common Subsequence.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#matrix-diagonal-traversal-js">Matrix Diagonal Traversal.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#maximum-sum-rectangular-submatrix-in-matrix-dynamic-programming-2d-js">Maximum Sum Rectangular Submatrix in Matrix Dynamic Programming_2D.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#merge-two-lists-into-sorted-list-js">Merge Two Lists Into Sorted List.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#min-cpu-count-js">Min CPU Count.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#parse-html-js">Parse HTML.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#parse-log-top-k-longest-running-job-js">Parse Log Top k Longest Running Job.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#parse-string-into-array-js">Parse String Into Array.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#readme-md">README.md</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#ransom-note-from-magazine-js">Ransom Note From Magazine.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#rate-limiter-js">Rate Limiter.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#reverse-integer-js">Reverse Integer.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#snake-and-ladder-js">Snake And Ladder.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#string-encoding-and-decoding-js">String Encoding and Decoding.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#top-k-longest-running-job-js">Top k Longest Running Job.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#url-shortening-js">URL shortening.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#weighted-job-scheduling-js">Weighted Job Scheduling.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#zigzag-conversion-js">ZigZag Conversion.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#find-kth-element-in-two-arrays-js">find kth element in two arrays.js</a></td>
        <td valign="top">&nbsp;</td>
    <tr><td valign="top"><a href="#flatten-nested-array-js">flatten nested array.js</a></td>
        <td valign="top">&nbsp;</td>
    </table>
<div>
<h3>1 Two Sum.js</h3>
<a name="1-two-sum-js"></a>
<pre>
// Given an array of integers, return indices of the two numbers such that they add up to a specific target.

// You may assume that each input would have exactly one solution.

// Example:
// Given nums = [2, 7, 11, 15], target = 9,

// Because nums[0] + nums[1] = 2 + 7 = 9,
// return [0, 1].
// UPDATE (2016/2/13):
// The return format had been changed to zero-based indices. Please read the above updated description carefully.

// Hide Company Tags LinkedIn Uber Airbnb Facebook Amazon Microsoft Apple Yahoo Dropbox Bloomberg Yelp Adobe
// Hide Tags Array Hash Table
// Hide Similar Problems (M) 3Sum (M) 4Sum (M) Two Sum II - Input array is sorted (E) Two Sum III - Data structure design



/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    var hash = {};
    
    for(var i = 0; i < nums.length; i++) {
        var num = nums[i];
        if(hash[num] !== undefined) {
            return [hash[num], i]
        } else {
            hash[target - num] = i;
        }
    }
    
    return [];
};
</pre>
<hr />
</div>

<div>
<h3>10 Regular Expresion Matching.js</h3>
<a name="10-regular-expresion-matching-js"></a>
<pre>
// https://www.youtube.com/watch?v=l3hda49XcDE#t=211.113333

// Implement regular expression matching with support for '.' and '*'.

// '.' Matches any single character.
// '*' Matches zero or more of the preceding element.

// The matching should cover the entire input string (not partial).

// The function prototype should be:
// bool isMatch(const char *s, const char *p)

// Some examples:
// isMatch("aa","a") ? false
// isMatch("aa","aa") ? true
// isMatch("aaa","aa") ? false
// isMatch("aa", "a*") ? true
// isMatch("aa", ".*") ? true
// isMatch("ab", ".*") ? true
// isMatch("aab", "c*a*b") ? true

/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
        var sLen = s.length;
    var pLen = p.length;
    var dp = [];
    
    for(var i = 0; i <= sLen; i++) {
        var tmp = [];
        
        for(var j = 0; j <= pLen; j++) {
            tmp.push(false);
        }
        
        dp.push(tmp);
    }
    
    dp[0][0] = true;
    
    for(i = 0; i <= sLen; i++) {
        for(j = 0; j <= pLen; j++) {
            if(p[j - 1] !== '.' && p[j - 1] !== '*') {
                if(i > 0 && p[j - 1] === s[i - 1] && dp[i - 1][j - 1]) {
                    dp[i][j] = true;
                }
            } else if(p[j - 1] === '.') {
                if(i > 0 && dp[i - 1][j - 1]) {
                    dp[i][j] = true;
                }
            } else if(j > 1) { // '*' cannot be the first element
                if(dp[i][j - 2]) { // 0 occurance
                    dp[i][j] = true;
                } else if(i > 0 && (p[j - 2] === s[i - 1] || p[j - 2] === '.') && dp[i - 1][j]) {
                    
                  // example
                  // xa and xa* 
                  // s[i-1] === a
                  // p[j-2] === a
                  // a === a
                  // so we can now compare x, xa*
                  // and x here is dp[i-1][j]
                    dp[i][j] = true;
                }
            }
        }
    }
    
    return dp[sLen][pLen];
};
</pre>
<hr />
</div>

<div>
<h3>100 Same Tree.js</h3>
<a name="100-same-tree-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    var queue1 = [];
    var queue2 = [];
    
    queue1.push(p);
    queue2.push(q);
    
    while(queue1.length && queue2.length){
        var node1 = queue1.shift();
        var node2 = queue2.shift();
        var val1;
        var val2;
        
        
        if(node1 === null){

            val1 = null;
        } else {
            val1 = node1.val;
            queue1.push(node1.left);
            queue1.push(node1.right);
        }
        
        if(node2 === null){
            val2 = null;
        } else {
            val2 = node2.val;
            queue2.push(node2.left);
            queue2.push(node2.right);
        }
        
        if(val1 !== val2){
            return false;
        }
    }
    
    return queue1.length === queue2.length;
};

</pre>
<hr />
</div>

<div>
<h3>101 Symmetric Tree.js</h3>
<a name="101-symmetric-tree-js"></a>
<pre>
// Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

// For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

//     1
//    / \
//   2   2
//  / \ / \
// 3  4 4  3
// But the following [1,2,2,null,3,null,3] is not:
//     1
//    / \
//   2   2
//    \   \
//    3    3
// Note:
// Bonus points if you could solve it both recursively and iteratively.

// Hide Company Tags LinkedIn Bloomberg Microsoft
// Hide Tags Tree Depth-first Search Breadth-first Search



/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    var queue = [];
    queue.push(root);
    
    while(queue.length !== 0) {
        var len = queue.length;
        
        if(!isLevelSymmetric(queue)) {
            return false;
        }
        
        for(var i = 0; i < len; i++) {
            var node = queue.shift();
            
            if(node !== null) {
                queue.push(node.left);
                queue.push(node.right);
            }
        }
    }
    
    return true;
};

function isLevelSymmetric(nodes) {
    var len = nodes.length;
    var beg = 0;
    var end = len - 1;
    
    while(beg < end) {
        if(nodes[beg] === null && nodes[end] === null || (nodes[beg] && nodes[end] && nodes[beg].val === nodes[end].val)) {
            beg++;
            end--;
        } else {
            return false;
        }
    }
    
    return true;
}

</pre>
<hr />
</div>

<div>
<h3>102 Binary Tree Level Order Traversal.js</h3>
<a name="102-binary-tree-level-order-traversal-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    var result = [];
    
    if(root === null){
        return result;
    }
    
    var queue = [];
    var temp = [];
    var curLvlCnt = 1;
    var nextLvlCnt = 0;
    
    queue.push(root);
    
    while(queue.length !== 0){
        var p = queue.shift();
        temp.push(p.val);
        curLvlCnt--;
        
        if(p.left){
            queue.push(p.left);
            nextLvlCnt++;
        }
        if(p.right){
            queue.push(p.right);
            nextLvlCnt++;
        }
        
        if(curLvlCnt === 0){
            result.push(temp);
            curLvlCnt = nextLvlCnt;
            nextLvlCnt = 0;
            temp = [];
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>103 Binary Tree Zigzag Level Order Traversal.js</h3>
<a name="103-binary-tree-zigzag-level-order-traversal-js"></a>
<pre>
// Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

// For example:
// Given binary tree [3,9,20,null,null,15,7],
//     3
//    / \
//   9  20
//     /  \
//    15   7
// return its zigzag level order traversal as:
// [
//   [3],
//   [20,9],
//   [15,7]
// ]
// Hide Company Tags LinkedIn Bloomberg Microsoft
// Hide Tags Tree Breadth-first Search Stack
// Hide Similar Problems (E) Binary Tree Level Order Traversal

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var zigzagLevelOrder = function(root) {
    // bfs
    
    if(!root) {
        return [];
    }
    
    var curLevel = [];
    curLevel.push(root);
    
    var fromLeft = true;
    var result = [];
    var tmpResult = [];
    var nextLevel = [];
    
    while(curLevel.length > 0) {
        var len = curLevel.length;
        
        for(var i = 0; i < len; i++) {
            var node = curLevel.pop();
            tmpResult.push(node.val);
            
            if(fromLeft) {
                if(node.left) {
                    nextLevel.push(node.left);
                }
                if(node.right) {
                    nextLevel.push(node.right);
                }
            } else {
                if(node.right) {
                    nextLevel.push(node.right);
                }
                if(node.left) {
                    nextLevel.push(node.left);
                }
            }
        }
        
        fromLeft = !fromLeft;
        curLevel = nextLevel;
        nextLevel = [];
        result.push(tmpResult);
        tmpResult = [];
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>104 Maximum Depth of Binary Tree.js</h3>
<a name="104-maximum-depth-of-binary-tree-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if(root === null){
      return 0;
  }  
  
  return 1+ Math.max(maxDepth(root.left), maxDepth(root.right));
};
</pre>
<hr />
</div>

<div>
<h3>105 Construct Binary Tree from Preorder and Inorder Traversal.js</h3>
<a name="105-construct-binary-tree-from-preorder-and-inorder-traversal-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder || !inorder) {
        return null;
    }
    
    if(preorder.length !== inorder.length) {
        return null;
    }
    
    return generate(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
};


var generate = function(preorder, pl, pr, inorder, il, ir) {
    if(pl > pr || il > ir) {
        return null
    }
    
    
    var root = new TreeNode(preorder[pl]);
    var midIndex = -1;
    
    for(var i = 0; i < inorder.length; i++) {
        if(inorder[i] === preorder[pl]) {
            midIndex = i;
            break;
        }
    }
    
    if(midIndex === -1) {
        return null;
    }
    
    var left = generate(preorder, pl + 1, pl + (midIndex - il), inorder, il, midIndex - 1);
    var right = generate(preorder, pl + (midIndex - il) + 1, pr, inorder, midIndex + 1, ir);
    
    root.left = left;
    root.right = right;
    
    return root;
}
</pre>
<hr />
</div>

<div>
<h3>106 Construct Binary Tree from Inorder and Postorder Traversal.js</h3>
<a name="106-construct-binary-tree-from-inorder-and-postorder-traversal-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    if(inorder === null || postorder === null){
        return null;
    }
    
    if(inorder.length !== postorder.length){
        return null;
    }
    
    return generate(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
};

var generate = function(inorder, il, ir, postorder, pl, pr){
    if(il > ir || pl > pr){
        return null;
    }
    
    var rootVal = postorder[pr];
    var root = new TreeNode(rootVal);
    var rootIndex = -1;
    
    for(var i = il; i <= ir; i++){
        var nodeVal = inorder[i];
        if(nodeVal === rootVal){
            rootIndex = i;
            break;
        }
    }
    
    if(rootIndex === -1){
        return null;
    }
    
    var leftTreeSize = rootIndex - il;
    var rightTreeSize = ir - rootIndex;
    
    root.left = generate(inorder, il, rootIndex - 1, postorder, pl, pl + leftTreeSize - 1);
    root.right = generate(inorder, rootIndex + 1, ir, postorder, pr - rightTreeSize, pr - 1);
    
    return root;
}
</pre>
<hr />
</div>

<div>
<h3>107 Binary Tree Level Order Traversal II.js</h3>
<a name="107-binary-tree-level-order-traversal-ii-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function(root) {
    var q = [];
    var result = [];
    var temp = [];
    
    if(root === null){
        return q;
    }
    
    q.push(root);
    
    var curLvlCnt = 1;
    var nextLvlCnt = 0;
    
    while(q.length !== 0){
        var p = q.shift();
        curLvlCnt--;
        temp.push(p.val);
        
        if(p.left !== null){
            q.push(p.left);
            nextLvlCnt++;
        }
        
        if(p.right !== null){
            q.push(p.right);
            nextLvlCnt++;
        }
        
        if(curLvlCnt === 0){
            curLvlCnt = nextLvlCnt;

            nextLvlCnt = 0;
            result.unshift(temp.slice());
            temp = [];
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>108 Convert Sorted Array to Binary Search Tree.js</h3>
<a name="108-convert-sorted-array-to-binary-search-tree-js"></a>
<pre>
// Leetcode 108 
// Language: Javascript
// Problem: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var sortedArrayToBST = function(nums) {
    return generate(nums,0,nums.length-1);
};

var generate = function(nums, start, end){
    
    if(start > end){
        return null;
    }
    var midIndex = start + parseInt((end - start)/2);
    var midVal = nums[midIndex];
    
    var node = new TreeNode(midVal);
    node.left = generate(nums, start, midIndex-1);
    node.right = generate(nums, midIndex+1, end);
    
    return node;
}
</pre>
<hr />
</div>

<div>
<h3>11 Container With Most Water.js</h3>
<a name="11-container-with-most-water-js"></a>
<pre>
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    var left = 0;
    var right = height.length - 1;
    var maxVal = 0;
    
    while(left<right){
        var contain = (right-left)*Math.min(height[left],height[right]);
        maxVal = Math.max(contain, maxVal);
        
        if(height[left] >= height[right]){
            right--;
        } else {
            left++;
        }
    }
    
    return maxVal;
};
</pre>
<hr />
</div>

<div>
<h3>110 Balanced Binary Tree.js</h3>
<a name="110-balanced-binary-tree-js"></a>
<pre>
// Leetcode 110
// Language: Javascript
// Problem: https://leetcode.com/problems/balanced-binary-tree/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
 
var maxHeight = function(node){
    if(node === null){
        return 0;
    }
    
    return 1 + Math.max(maxHeight(node.left), maxHeight(node.right));
}

var minHeight = function(node){
    if(node === null){
        return 0;
    }
    
    return 1 + Math.min(minHeight(node.left), minHeight(node.right));
}


var height = function(node){
    if(node === null){
        return 0;
    }
    
    return 1 + Math.max(height(node.left), height(node.right));
}
 
var isBalanced = function(root) {
    if(root === null){
        return true;
    }
    
    // var maxh = maxHeight(root);
    // var minh = minHeight(root);
    
    // return Math.abs(maxh - minh) <= 1;
    
    var lh = height(root.left);
    var rh = height(root.right);
    
    var diff = Math.abs(lh - rh);
    
    if(diff <= 1){
        return isBalanced(root.left) && isBalanced(root.right);
    } else {
        return false;
    }
};
</pre>
<hr />
</div>

<div>
<h3>111 Minimum Depth of Binary Tree.js</h3>
<a name="111-minimum-depth-of-binary-tree-js"></a>
<pre>
// Leetcode 111
// Language: Javascript
// Problem: https://leetcode.com/problems/minimum-depth-of-binary-tree/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(root === null){
        return 0;
    }
    
    var queue = [];
    
    queue.push(root);
    
    var height = 1;
    
    var curLvlCnt = 1;
    var nextLvlCnt = 0;
    
    while(queue.length !== 0){
        var node = queue.shift();
        
        curLvlCnt--;
        
        if(node.left){
            queue.push(node.left);
            nextLvlCnt++;
        }
        if(node.right){
            queue.push(node.right);
            nextLvlCnt++;
        }
        
        if(node.left === null && node.right === null){
            return height;
        }
        
        if(curLvlCnt === 0){
            height++;
            curLvlCnt = nextLvlCnt;
            nextLvlCnt = 0;
        }
    }
    
    return height;
};
</pre>
<hr />
</div>

<div>
<h3>112 Path Sum.js</h3>
<a name="112-path-sum-js"></a>
<pre>
// Leetcode #112 
// Language: Javascript
// Problem: https://leetcode.com/problems/path-sum/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(root === null){
        return false;
    }
    
    if(root.val === sum && root.left === null && root.right === null){
        return true;
    }
    
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
};
</pre>
<hr />
</div>

<div>
<h3>114 Flatten Binary Tree to Linked List.js</h3>
<a name="114-flatten-binary-tree-to-linked-list-js"></a>
<pre>
// Leetcode 114
// Language: Javascript
// Problem: https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    var stack = [];
    var p = root;

    while(p !== null || stack.length !== 0){
        if(p.right  !== null){
            stack.push(p.right);
        }

        if(p.left !== null){ // [!!!]point of confusing, if null then pop stack
            p.right = p.left;
            p.left = null;
        } else if(stack.length !== 0){
            var node = stack.pop();
            p.right = node;
        }

        p = p.right;
    }
};

// Recursive solution

var flatten = function(root) {
    if(root === null || (root.left === null && root.right === null)) {
        return;
    }

    var rootLeft = root.left;
    var rootRight = root.right;
    root.left = null;
    root.right = null;

    flatten(rootLeft);
    flatten(rootRight);

    root.right = rootLeft;

    var aux = root;
    while(aux !== null && aux.right !== null) {
        aux = aux.right;
    }
    aux.right = rootRight;
};

</pre>
<hr />
</div>

<div>
<h3>116 Populating Next Right Pointers in Each Node.js</h3>
<a name="116-populating-next-right-pointers-in-each-node-js"></a>
<pre>
// Leetcode 116
// Language: Javascript
// Problem: https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
// Author: Chihung Yu
/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
    if(root === null){
        return;
    }
    
    if(root.left){
        root.left.next = root.right;
    }
    
    if(root.right){
        root.right.next = (root.next === null) ? null : root.next.left
    }
    
    connect(root.left);
    connect(root.right);
};
</pre>
<hr />
</div>

<div>
<h3>117 Populating Next Right Pointer.js</h3>
<a name="117-populating-next-right-pointer-js"></a>
<pre>
// Follow up for problem "Populating Next Right Pointers in Each Node".

// What if the given tree could be any binary tree? Would your previous solution still work?

// Note:

// You may only use constant extra space.
// For example,
// Given the following binary tree,
//          1
//        /  \
//       2    3
//      / \    \
//     4   5    7
// After calling your function, the tree should look like:
//          1 -> NULL
//        /  \
//       2 -> 3 -> NULL
//      / \    \
//     4-> 5 -> 7 -> NULL
// Hide Company Tags Microsoft Bloomberg Facebook
// Hide Tags Tree Depth-first Search
// Hide Similar Problems (M) Populating Next Right Pointers in Each Node



/**
 * Definition for binary tree with next pointer.
 * function TreeLinkNode(val) {
 *     this.val = val;
 *     this.left = this.right = this.next = null;
 * }
 */

/**
 * @param {TreeLinkNode} root
 * @return {void} Do not return anything, modify tree in-place instead.
 */
var connect = function(root) {
    if(!root) {
        return;
    }
    
    // leftEnd is used to track the current left most node
    var leftEnd = root;
    
    while(leftEnd !== null) {
        var cur = leftEnd;
        // dummy is used to point to the next level's leftEnd
        var dummy = new TreeLinkNode(0);
        var pre = dummy;
        // for each level we use leftEnd and leftEnd next to achieve level traversal
        while(cur !== null) {
            if(cur.left !== null) {
                pre.next = cur.left;
                pre = cur.left;
            }
            
            if(cur.right !== null) {
                pre.next = cur.right;
                pre = cur.right;
            }
            
            cur = cur.next;
        }
        
        leftEnd = dummy.next;
    }
};
</pre>
<hr />
</div>

<div>
<h3>117 Populating Next Right Pointers in Each Node II.js</h3>
<a name="117-populating-next-right-pointers-in-each-node-ii-js"></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>118 Pascal's Triangle.js</h3>
<a name="118-pascal-s-triangle-js"></a>
<pre>
// Leetcode 118
// Language: Javascript
// Problem: https://leetcode.com/problems/pascals-triangle/
// Author: Chihung Yu
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    var result = [];
    
    if(numRows <= 0){
        return result;
    }
    
    for(var i = 0; i < numRows; i++){
        var cur = [];
        var pre = i > 0 ? result[i - 1] : [];
        
        for(var j = 0; j <= i; j++){
            if(j === 0){
                cur.push(1);    
            } else if(j === i){
                cur.push(1);
            } else {

                cur.push(pre[j] + pre[j-1]);
            }
        }
        
        result.push(cur);
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>119 Pascal's Triangle II.js</h3>
<a name="119-pascal-s-triangle-ii-js"></a>
<pre>
// Leetcode 119
// Language: Javascript
// Problem: https://leetcode.com/problems/pascals-triangle-ii/
// Author: Chihung Yu
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
var getRow = function(rowIndex) {
    if(rowIndex === null || rowIndex < 0){
        return [];
    }
    
    var result = [1];
    
    for(var i = 1; i <= rowIndex; i++){
        var cur = [];
        
        for(var j = 0; j <= i; j++){
            cur[j] = (result[j - 1] || 0) + (result[j] || 0);
        }

        result = cur;
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>12 Integer to Roman.js</h3>
<a name="12-integer-to-roman-js"></a>
<pre>
// Leetcode 12
// Language: Javascript
// Problem: https://leetcode.com/problems/integer-to-roman/
// Author: Chihung Yu
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
    var dict = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"];
    var val = [1000,900,500,400,100,90,50,40,10,9,5,4,1];
    var result = "";
    
    for(var i = 0; i < val.length; i++) {
        var v = val[i];
        
        if(num >= v) {
            var count = parseInt(num/v);
            num %= v;
            
            for(var j = 0; j < count; j++) {
                result = result + dict[i];
            }
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>120 Triangle.js</h3>
<a name="120-triangle-js"></a>
<pre>
// Leetcode 120
// Language: Javascript
// Problem: https://leetcode.com/problems/triangle/
// Author: Chihung Yu
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function(triangle) {
    var curLvlIndex = 0;
    var cur = triangle[curLvlIndex];
    var next;
    
    while(curLvlIndex < (triangle.length-1)){
        next = triangle[curLvlIndex + 1];
        
        for(var i = 0; i < next.length; i++){
            var a,b;
            if(i === 0){
                b = Infinity;
            } else {
                b = cur[i-1];
            }
            
            if(i < cur.length){
                a = cur[i];
            } else {
                a = Infinity;
            }
            
            next[i] += Math.min(a,b);
        }
        cur = next;
        curLvlIndex++;
    }
    
    return Math.min.apply(null, cur);
};
</pre>
<hr />
</div>

<div>
<h3>121 Best Time to Buy and Sell Stock.js</h3>
<a name="121-best-time-to-buy-and-sell-stock-js"></a>
<pre>
// Say you have an array for which the ith element is the price of a given stock on day i.

// If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

// Example 1:
// Input: [7, 1, 5, 3, 6, 4]
// Output: 5

// max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
// Example 2:
// Input: [7, 6, 4, 3, 1]
// Output: 0

// In this case, no transaction is done, i.e. max profit = 0.
// Hide Company Tags Amazon Microsoft Bloomberg Uber Facebook
// Hide Tags Array Dynamic Programming
// Hide Similar Problems (M) Maximum Subarray (M) Best Time to Buy and Sell Stock II (H) Best Time to Buy and Sell Stock III (H) Best Time to Buy and Sell Stock IV (M) Best Time to Buy and Sell Stock with Cooldown

/**
 * @param {number[]} prices
 * @return {number}
 */
//  http://fisherlei.blogspot.com/2013/01/leetcode-best-time-to-buy-and-sell.html
var maxProfit = function(prices) {
    if(prices === null || prices.length === 0){
        return 0;
    }
    
    var max = 0;
    var diff = 0;
    var min = Infinity;
    
    for(var i = 0; i < prices.length; i++){
        var price = prices[i];
        if(min > price){
            min = price;
        }
        
        diff = price - min;
        
        if(max < diff){
            max = diff;
        }
    }
    
    return max;
};
</pre>
<hr />
</div>

<div>
<h3>122 Best Time to Buy and Sell Stock II.js</h3>
<a name="122-best-time-to-buy-and-sell-stock-ii-js"></a>
<pre>
// Leetcode 122
// Language: Javascript
// Problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
// Author: Chihung Yu
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    if(prices === null || prices.length === 0){
        return 0;
    }
    
    var profit = 0;

    for(var i = 1; i < prices.length; i++){
        var diff = prices[i] - prices[i-1];
        if(diff > 0){
            profit += diff;
        }
    }
    
    return profit;
};
</pre>
<hr />
</div>

<div>
<h3>123 Best Time to Buy and Sell Stock III.js</h3>
<a name="123-best-time-to-buy-and-sell-stock-iii-js"></a>
<pre>
// Say you have an array for which the ith element is the price of a given stock on day i.

// Design an algorithm to find the maximum profit. You may complete at most two transactions.

// Note:
// You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

// http://www.cnblogs.com/springfor/p/3877068.html

/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    // Calculate MaxProfit from 0 to x and MaxProfit from x + 1 to len - 1;
    var profitFromZeroToX = [];
    var profitFromXToEnd = [];
    var min = prices[0];

    // get max profit from 0 to x
    for(var x = 1; x < prices.length; x++) {
        var price = prices[x];
        min = Math.min(price, min);
        profitFromZeroToX[x] = Math.max(profitFromZeroToX[x - 1] || 0, price - min);
    }
    // get max profit from i + 1 to end
    var max = prices[prices.length - 1];
    for(x = prices.length - 2; x >= 0; x--) {
        price = prices[x];
        max = Math.max(price, max);
        profitFromXToEnd[x] = Math.max(profitFromXToEnd[x + 1] || 0, max - price);
    }
    
    var maxProfit = 0;
    for(x = 0; x < prices.length; x++) {
        var maxProfitSeperateAtX = (profitFromZeroToX[x] || 0) + (profitFromXToEnd[x] || 0);
        maxProfit = Math.max(maxProfitSeperateAtX, maxProfit);
    }
    
    return maxProfit;
};

</pre>
<hr />
</div>

<div>
<h3>124 Binary Tree Maximum Path Sum.js</h3>
<a name="124-binary-tree-maximum-path-sum-js"></a>
<pre>
// Given a binary tree, find the maximum path sum.

// For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.

// For example:
// Given the below binary tree,

//        1
//       / \
//      2   3
// Return 6.


// http://bangbingsyb.blogspot.com/2014/11/leetcode-binary-tree-maximum-path-sum.html
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
    var maxVal = -Infinity;
    findMaxPath(root);
    return maxVal;
    
    function findMaxPath(node) {
        if(!node) {
            return 0;
        }
        
        var leftVal = Math.max(findMaxPath(node.left), 0);
        var rightVal = Math.max(findMaxPath(node.right), 0);
        
        var ps1 = node.val + Math.max(leftVal, rightVal);
        // ps2 means taking this current node as parent node and stop there
        var ps2 = node.val + leftVal + rightVal;
        
        // maxVal as if we end counting value here, what will be the maximum val
        // leftVal and rightVal can be negative values
        maxVal = Math.max.apply(null, [maxVal, ps1, ps2]);

        // return ps1 only since, ps2 cannot be combined with the parent node
        // leftVal and rightVal can be negative values, however, we can to see if combining with values down below can give higher number
        return ps1;
    }
};

</pre>
<hr />
</div>

<div>
<h3>125 Valid Palindrome.js</h3>
<a name="125-valid-palindrome-js"></a>
<pre>
// Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

// For example,
// "A man, a plan, a canal: Panama" is a palindrome.
// "race a car" is not a palindrome.

// Note:
// Have you consider that the string might be empty? This is a good question to ask during an interview.

// For the purpose of this problem, we define empty string as valid palindrome.

// Hide Company Tags Microsoft Uber Facebook Zenefits
// Hide Tags Two Pointers String
// Hide Similar Problems (E) Palindrome Linked List


/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s = s.toLowerCase();
    var beg = 0;
    var end = s.length - 1;
    
    while(beg < end) {
        if(!s[beg].match(/[a-z0-9]/)) {
            beg++;
        } else if(!s[end].match(/[a-z0-9]/)) {
            end--;
        } else if(s[beg] !== s[end]) {
            return false;
        } else {
            end--;
            beg++;
        }
    }
    
    return true;
};


/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    var head = 0;
    var tail = s.length - 1;
    
    s = s.toLowerCase();
    
    while(head < tail) {
        while(s[head] && !s[head].match(/[a-z0-9]/)) {
            head++;
        }
        while(s[tail] && !s[tail].match(/[a-z0-9]/)) {
            tail--;
        }
        if(head < tail && s[head] !== s[tail]) {
            return false;
        }
        head++;
        tail--;
    }
    
    return true;
};
</pre>
<hr />
</div>

<div>
<h3>126 Word Ladder II.js</h3>
<a name="126-word-ladder-ii-js"></a>
<pre>
// Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

// Only one letter can be changed at a time
// Each intermediate word must exist in the word list
// For example,

// Given:
// beginWord = "hit"
// endWord = "cog"
// wordList = ["hot","dot","dog","lot","log"]
// Return
//   [
//     ["hit","hot","dot","dog","cog"],
//     ["hit","hot","lot","log","cog"]
//   ]
// Note:
// All words have the same length.
// All words contain only lowercase alphabetic characters.

/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {Set} wordList
 *   Note: wordList is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
    
};
</pre>
<hr />
</div>

<div>
<h3>127 Word Ladder.js</h3>
<a name="127-word-ladder-js"></a>
<pre>
// Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

// Only one letter can be changed at a time
// Each intermediate word must exist in the word list
// For example,

// Given:
// beginWord = "hit"
// endWord = "cog"
// wordList = ["hot","dot","dog","lot","log"]
// As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
// return its length 5.

// Note:
// Return 0 if there is no such transformation sequence.
// All words have the same length.
// All words contain only lowercase alphabetic characters.
// Amazon LinkedIn Snapchat Facebook Yelp


// Leetcode 127
// Language: Javascript
// Problem: https://leetcode.com/problems/word-ladder/
// Author: Chihung Yu

/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {Set} wordList
 *   Note: wordList is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
    var visited = new Set();
    var queue = [];
    var level = 1;
    var letters = 'abcdefghijklmnopqrstuvwxyz';
    queue.push(beginWord);
    visited.add(beginWord);    
    
    while(queue.length > 0) {
        
        var len = queue.length;
        
        for(var i = 0; i < len; i++) {
            var word = queue.shift();
            
            for(var j = 0; j < word.length; j++) {
                for(var k = 0; k < letters.length; k++) {
                    var newWord = word.substring(0, j) + letters[k] + word.substring(j + 1);
                    
                    if(newWord === endWord) {
                        return level + 1;
                    }
                    if(wordList.has(newWord) && !visited.has(newWord)) {
                        queue.push(newWord);
                        visited.add(newWord);
                    }
                }
            }
        }
        
        level++;
    }
    
    return 0;
};

// will time exceeded. javascript hash is slower than set
var ladderLength = function(beginWord, endWord, wordList) {
    if(beginWord === endWord) {
        return 0;
    }
    
    var queue = [];
    var visited = {};
    var count = 1;
    var baseCharCode = 'a'.charCodeAt(0);
    
    queue.push(beginWord);
    
    while(queue.length) {
        var len = queue.length;
        
        for(var i = 0; i < len; i++) {
            var word = queue.shift();
            
            for(var j = 0; j < word.length; j++) {
                for(var k = 0; k < 26; k++) {
                    var newChar = String.fromCharCode(baseCharCode + k);
                    var newWord = word.substring(0, j) + newChar + word.substring(j + 1);
                    
                    if(newWord === endWord) {
                        return count + 1;
                    }
                    
                    if(!visited[newWord] && wordList.has(newWord)) {
                        visited[newWord] = true;
                        queue.push(newWord);
                    }
                }
            }    
        }
        
        count++;
    }
    
    return 0;
};




Hi Thiago

I very much appreciate that you took the time writing this warm welcoming letter and provided me the opportunity to come onsite visiting the team at Periscope.
After much thought, I've decided to accept offer at another company. It was really a tough call for me since I really like the product, role and people I met during my visit. 
Again, I cannot thank you enough for your time, and support. It's been a great pleasure to know you and the team. I hope that we cross paths in the near future.

Wish you, teams, and Periscope all the success.

Regards,
Jerry




Hi Cynthia

Thank your for patience and support along the way.
I very much appreciate that you took the time answering many of my questions about the Periscope, and role.

After much thought, I've decided to accept offer at another company. It was really a tough call for me since I really like the product and people I met during my visit.
 
Again, I cannot thank you enough for your time, and support. It's been a great pleasure to know you and the team. I hope that we cross paths in the near future.

Wish you, teams, and Periscope all the success.

Regards,
Jerry
</pre>
<hr />
</div>

<div>
<h3>128 Longest Consecutive Sequence.js</h3>
<a name="128-longest-consecutive-sequence-js"></a>
<pre>
// Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

// For example,
// Given [100, 4, 200, 1, 3, 2],
// The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

// Your algorithm should run in O(n) complexity.

// Hide Company Tags Google Facebook
// Hide Tags Array Union Find
// Hide Similar Problems (M) Binary Tree Longest Consecutive Sequence


/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    var maxLen = -Infinity;
    var hash = {};
    
    for(var i = 0; i < nums.length; i++) {
        hash[nums[i]] = 1;
    }
    
    var visited = {};
    
    for(i = 0; i < nums.length; i++) {
        var val = nums[i];
        if(visited[val]) {
            continue;
        }
        visited[val] = true;
        var len = 1;
        var preVal = val - 1;
        while(hash[preVal]) {
            len++
            visited[preVal--] = true;
        }
        var nxtVal = val + 1;
        while(hash[nxtVal]) {
            len++
            visited[nxtVal++] = true;
        }
        
        if(len > maxLen) {
            maxLen = len;
        }
    }
    
    return maxLen;
};
</pre>
<hr />
</div>

<div>
<h3>129 Sum Root to Leaf Numbers.js</h3>
<a name="129-sum-root-to-leaf-numbers-js"></a>
<pre>
// Leetcode 129
// Language: Javascript
// Problem: https://leetcode.com/problems/sum-root-to-leaf-numbers/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    var total = 0;

    if(root === null){
        return total;
    }
    
    var queue = [];
    queue.push(root);
    
    while(queue.length !== 0){
        var node = queue.shift();
        
        if(node.left === null && node.right === null){
            total += parseInt(node.val);
        }
        
        if(node.left){
            node.left.val = '' + node.val + node.left.val;
            queue.push(node.left);
        }
        if(node.right){
            node.right.val = '' + node.val + node.right.val;
            queue.push(node.right);
        }
    }
    
    return total;
};
</pre>
<hr />
</div>

<div>
<h3>13 Roman to Integer.js</h3>
<a name="13-roman-to-integer-js"></a>
<pre>
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    var result = 0;
    
    for(var i = 0; i < s.length; i++){
        if(i > 0 && (c2n(s[i]) > c2n(s[i-1]))){
            result -= 2*c2n(s[i-1]); // because previously added [!!!]
        }
        
        result += c2n(s[i]);
    }
    
    return result;
};

var c2n = function(c){
    switch(c){
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}


</pre>
<hr />
</div>

<div>
<h3>131 Palindrome Partitioning.js</h3>
<a name="131-palindrome-partitioning-js"></a>
<pre>
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    var result = [];
    
    generate(s, 0, [], result);
    
    return result;
};

var generate = function(s, index, output, result) {
    if(index === s.length){
        result.push(output.slice());
        return;
    }
    
    
    for(var i = index; i < s.length; i++) {
        var str = s.substring(index, i);
        
        if(isPalindrome(s, index, i)){
            output.push(s.substring(index, i + 1));
            generate(s, i + 1, output, result);
            output.pop();
        }
    }
}

var isPalindrome = function(s, head, tail) {
    while(head < tail) {
        if(s[head] !== s[tail]) {
            return false;
        }
        
        head++;
        tail--;
    }
    
    return true;
}
</pre>
<hr />
</div>

<div>
<h3>133 Clone Graph.js</h3>
<a name="133-clone-graph-js"></a>
<pre>
// Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


// OJ's undirected graph serialization:
// Nodes are labeled uniquely.

// We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
// As an example, consider the serialized graph {0,1,2#1,2#2,2}.

// The graph has a total of three nodes, and therefore contains three parts as separated by #.

// First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
// Second node is labeled as 1. Connect node 1 to node 2.
// Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
// Visually, the graph looks like the following:

//        1
//       / \
//      /   \
//     0 --- 2
//          / \
//          \_/

// Pocket Gems Google Uber Facebook
// Hide Tags Depth-first Search Breadth-first Search Graph
// Hide Similar Problems (H) Copy List with Random Pointer



/**
 * Definition for undirected graph.
 * function UndirectedGraphNode(label) {
 *     this.label = label;
 *     this.neighbors = [];   // Array of UndirectedGraphNode
 * }
 */
/**
 * @param {UndirectedGraphNode} graph
 * @return {UndirectedGraphNode}
 */
var cloneGraph = function(graph) {
    var visited = {};
    
    if(graph === null){
        return graph;
    }else{
        return dfs(graph);
    }

    function dfs(node){
        var newNode = visited[node.label] ? visited[node.label] : new UndirectedGraphNode(node.label);
        visited[node.label] = newNode;
        
        for(var i = 0; i < node.neighbors.length; i++){
            var newNeighbor = visited[node.neighbors[i].label] ? visited[node.neighbors[i].label] : dfs(node.neighbors[i]);
            newNode.neighbors.push(newNeighbor);
        }
        return newNode; 
    }   
};


var cloneGraph = function(graph) {
    if(!graph) {
        return graph;
    } else {
        return dfs(graph, {});
    }
    
    function dfs(node, visited) {
        var newNode = visited[node.label] = visited[node.label] || new UndirectedGraphNode(node.label);
        
        for(var i = 0; i < node.neighbors.length; i++) {
            var neighbor = node.neighbors[i];
            newNode.neighbors[i] = visited[neighbor.label] = visited[neighbor.label] || dfs(neighbor, visited);
        }
        
        return newNode;
    }
    
};
</pre>
<hr />
</div>

<div>
<h3>136 Single Number.js</h3>
<a name="136-single-number-js"></a>
<pre>
// Leetcode 136
// Language: Javascript
// Problem: https://leetcode.com/problems/single-number/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    var total = 0;
    
    for(var i = 0; i < nums.length; i++){
        var num = nums[i];
        total ^= num;
    }
    
    return total;
};
</pre>
<hr />
</div>

<div>
<h3>137 Single Number II.js</h3>
<a name="137-single-number-ii-js"></a>
<pre>
// Leetcode 137
// Language: Javascript
// Problem: https://leetcode.com/problems/single-number-ii/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    
    var singleNum = 0;
    
    for(var i = 0; i < 32; i++){
        var bit = 0;
        for(var j = 0; j < nums.length; j++){
            var num = nums[j];
            
            bit = (bit + ((num >> i) & 1)) % 3;
        }
        
        singleNum += bit << i;
    }
    
    return singleNum;
};
</pre>
<hr />
</div>

<div>
<h3>138 Copy List With Random Pointer.js</h3>
<a name="138-copy-list-with-random-pointer-js"></a>
<pre>
// A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

// Return a deep copy of the list.

// Hide Company Tags Amazon Microsoft Bloomberg Uber
// Show Tags
// Show Similar Problems


/**
 * Definition for singly-linked list with a random pointer.
 * function RandomListNode(label) {
 *     this.label = label;
 *     this.next = this.random = null;
 * }
 */

/**
 * @param {RandomListNode} head
 * @return {RandomListNode}
 */
var copyRandomList = function(head) {
  var hashMap = {};
  var newHead = new RandomListNode(0);
  newHead.next = copyList(head);
  
  function copyList(node)   {
    if(node === null) {
        return node;
    }
      
    if(hashMap[node.label]) {
        return hashMap[node.label];
    }
    
    var newNode = new RandomListNode(node.label);
    hashMap[node.label] = newNode;
    
    newNode.next = copyList(node.next);
    newNode.random = copyList(node.random);
    
    return newNode;
  }
  
  return newHead.next;
};
</pre>
<hr />
</div>

<div>
<h3>139 Word Break.js</h3>
<a name="139-word-break-js"></a>
<pre>
/**
 * @param {string} s
 * @param {set<string>} wordDict
 *   Note: wordDict is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {boolean}
 */
var wordBreak = function(s, wordDict) {
    if(wordDict === null || wordDict.size === 0) {
        return false;
    }
  
    var possible = [];
    possible[0] = true;
    
    for(var i = 0; i < s.length; i++) {
        if(possible[i]) {
            for(var j = i + 1; j <= s.length; j++) {
                var str = s.substring(i, j);
                if(wordDict.has(str)) {
                    possible[j] = true;
                }
            }
        }
    }
    
    return possible[s.length] === true;
};
</pre>
<hr />
</div>

<div>
<h3>14 Longest Common Prefix.js</h3>
<a name="14-longest-common-prefix-js"></a>
<pre>
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    var len = strs.length;
    var result = '';
    
    if(len === 0) {
        return result;
    }
    
    for(var i = 0; i < strs[0].length; i++) {
        var curChar = strs[0][i];
        
        for(var j = 1; j < len; j++) {
            if(curChar !== strs[j][i]) {
                return result;
            }
            
            if(strs[j].length === i) {
                return result;
            }
        }
        
        result += curChar;
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>140 Word Break II.js</h3>
<a name="140-word-break-ii-js"></a>
<pre>
// http://fisherlei.blogspot.com/2013/11/leetcode-wordbreak-ii-solution.html
/**
 * @param {string} s
 * @param {set<string>} wordDict
 *   Note: wordDict is a Set object, see:
 *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
 * @return {string[]}
 */
var wordBreak = function(s, wordDict) {
    var result = [];
    var solutions = [];
    var len = s.length;
    var possible = [];
    
    for(var i = 0; i <= s.length; i++) {
        possible.push(true);
    }
    
    getAllSolutions(0, s, wordDict, result, solutions, possible);
    return solutions;
};

function getAllSolutions(start, s, wordDict, result, solutions, possible) {
    if(start === s.length) {
        solutions.push(result.join(' ')) // remove the last space
        return;
    }
    
    // loop through string from i to s.length
    for(var i = start; i < s.length; i++) {
        var piece = s.substring(start, i+1);
        
        // possible is to mark step whether i+1 to s.length have any possible words
        if(wordDict.has(piece) && possible[i+1]) {// eliminate unnecessary search
            result.push(piece);
            var beforeChange = solutions.length;
            getAllSolutions(i + 1, s, wordDict, result, solutions, possible);
            if(solutions.length === beforeChange) {
                possible[i+1] = false;
            }
            result.pop();
        }
    }
}


var dict = new Set();
dict.add('leet');
dict.add('code');
dict.add('cod');
dict.add('de');

wordBreak('leetcode', dict)
</pre>
<hr />
</div>

<div>
<h3>141 Linked List Cycle.js</h3>
<a name="141-linked-list-cycle-js"></a>
<pre>
// Leetcode #141
// Language: Javascript
// Problem: https://leetcode.com/problems/linked-list-cycle/
// Author: Chihung Yu
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if(head === null || head.next === null){
        return false;
    }
    
    var faster = head.next;
    var slower = head;
    
    while(faster && slower){
        if(faster.val === slower.val){
            return true;
        }
        faster = faster.next;
        
        if(faster === null){
            return false;
        } else {
            faster = faster.next;
        }
        
        slower = slower.next;
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>144 Binary Tree Preorder Traversal My Submissions Question.js</h3>
<a name="144-binary-tree-preorder-traversal-my-submissions-question-js"></a>
<pre>
// Leetcode #144
// Language: Javascript
// Problem: https://leetcode.com/problems/binary-tree-preorder-traversal/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */

// var preorderTraversal = function(root) {
//     var result = [];
    
//     traverse(root, result);
    
//     return result;
// };

// function traverse(node, result) {
//     if(!node) {
//         return;
//     }
    
//     result.push(node.val);
    
//     traverse(node.left, result);
//     traverse(node.right, result);
// }



/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    var result = [];

    if(root === null) {
        return result;
    }
    
    var stack = [];
    stack.push(root);
    
    while(stack.length) {
        var node = stack.pop();
        result.push(node.val);
        
        if(node.right !== null) {
            stack.push(node.right);
        }
        if(node.left !== null) {
            stack.push(node.left);
        }
    }
    
    return result;
};


</pre>
<hr />
</div>

<div>
<h3>145 Binary Tree Post Order Traversal.js</h3>
<a name="145-binary-tree-post-order-traversal-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    var result = [];
    var stack = [];
    var prev = null;
    var curr = null;
    
    if(root === null) {
        return result;
    }
    
    stack.push(root);
    
    // use prev and curr to figure out the direction of tree traversal
    while(stack.length !== 0) {
        curr = stack[stack.length - 1];
        
        if(prev === null || prev.left === curr || prev.right === curr) { // traverse down the tree
            if(curr.left !== null) {
                stack.push(curr.left);
            } else if(curr.right !== null) {
                stack.push(curr.right);
            }
        } else if(curr.left === prev) { //traverse up the tree from the left
            if(curr.right !== null) {
                stack.push(curr.right);
            }
        } else {
            // it means that curr === prev 
            result.push(curr.val);
            stack.pop();
        }
        
        prev = curr;
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>146 LRU Cache.js</h3>
<a name="146-lru-cache-js"></a>
<pre>
class Node {
    constructor(key, val) {
        this.key = key;
        this.val = val;
        this.next = null;
        this.prev = null;
    }
}
/**
 * @constructor
 */
var LRUCache = function(capacity) {
    this.list = null;
    this.map = new Map();
    this.head = null;
    this.tail = null;
    this.capacity = capacity;
    this.curSize = 0;
};

/**
 * @param {number} key
 * @returns {number}
 */
LRUCache.prototype.get = function(key) {
    let node = this.map.get(key);
    if (!node) {
        return -1;
    }
    
    if (node === this.head) {
        return node.val;
    }
    
    // remove node from list
    if (node === this.tail) {
        this.tail.prev.next = null;
        this.tail = this.tail.prev;
    } else {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    // insert node to head
    node.next = this.head;
    this.head.prev = node;
    this.head = node;
    
    return node.val;
};

/**
 * @param {number} key
 * @param {number} value
 * @returns {void}
 */
LRUCache.prototype.set = function(key, value) {
    let newNode = new Node(key, value);
    
    if (this.curSize === 0) {
        this.tail = newNode;
    } else {
        newNode.next = this.head;
        this.head.prev = newNode;
    }
    
    this.head = newNode;
    // this.curSize++;
    
    // update
    if (this.map.get(key)) {
        let oldNode = this.map.get(key);
        
        // remove node
        if (oldNode === this.tail) {
            this.tail = this.tail.prev;
            this.tail.next = null;
        } else {
            oldNode.prev.next = oldNode.next;
            oldNode.next.prev = oldNode.prev;
        }
    } else {
        this.curSize++
        if (this.curSize > this.capacity) {
            //delete tail
            this.map.delete(this.tail.key);
            this.tail = this.tail.prev;
            this.tail.next = null;
            this.curSize--;
        }
    }
    
    this.map.set(key, newNode);
};










// Second Implementation


function DoublyLinkListNode(key, value) {
    this.key = key;
    this.value = value;
    this.prev = this.next = null;
}

/**
 * @constructor
 */
var LRUCache = function(capacity) {
    this.head = this.tail = null;
    this.maxCapacity = capacity;
    this.currSize = 0;
    this.hash = {};
};

/**
 * @param {number} key
 * @returns {number}
 */
LRUCache.prototype.get = function(key) {
    if(!this.hash[key]) {
        return -1;
    }
    
    this.moveToHead(key);
    return this.hash[key].value;
};

/**
 * @param {number} key
 * @param {number} value
 * @returns {void}
 */
LRUCache.prototype.set = function(key, value) {
    if(this.maxCapacity <= 0) {
        return;
    }

    if(!this.hash[key]) {

        if(this.currSize === this.maxCapacity) {
            this.removeLast();
            this.currSize--;
        }
        
        this.hash[key] = new DoublyLinkListNode(key, value);
        this.currSize++;
    }
    
    this.hash[key].value = value;
    this.moveToHead(key);
};

LRUCache.prototype.removeLast = function() { 
    if(this.tail === null) {
        return;
    }

    delete this.hash[this.tail.key];
    var newTail = this.tail.prev;

    if(newTail === null) {
        this.head = this.tail = null;
        return;
    }

    this.tail.prev = null;
    newTail.next = null;
    this.tail = newTail;
}

LRUCache.prototype.moveToHead = function(key) {
    var newHead = this.hash[key];
    
    if(this.head === null && this.tail === null) {
        this.head = this.tail = newHead;
    }

    if(newHead === this.head) {
        return;
    }
    
    if(newHead === this.tail) {
        this.tail = newHead.prev;
    }
    
    if(newHead.prev) {
        newHead.prev.next = newHead.next;    
    }
    if(newHead.next) {
        newHead.next.prev = newHead.prev;    
    }
    
    newHead.prev = null;
    newHead.next = this.head;
    this.head.prev = newHead;
    this.head = newHead;
}
</pre>
<hr />
</div>

<div>
<h3>148 Sort List.js</h3>
<a name="148-sort-list-js"></a>
<pre>
// Sort a linked list in O(n log n) time using constant space complexity.

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
 
var sortList = function(head) {
    if(head === null) {
        return null;
    }
    
    var len = 0;
    var p = head;
    
    while(p) {
        len++;
        p = p.next;
    }
    
    var newHead = sort(len);
    
    return newHead;
    
    function sort(len) {
        // there will be no case of len = 0 which is caused by 1/2
        if(len === 1) {
            var temp = head;
            // !!! important: moving pointer to the next
            // e.g. 1->2->3->4
            // head-> 1
            // now head will be point to 2
            head = head.next; 
            temp.next = null;
            return temp;
        }
        // there will be no case of len = 0 which is caused by 1/2
        var leftHead = sort(parseInt(len/2));
        var rightHead = sort(len - parseInt(len/2));
        var newHead = merge(leftHead, rightHead);
        
        return newHead;
    }
    
    function merge(first, second) {
        var h = new ListNode(-1);
        var cur = h;
    
        while(first && second) {
            
            
            if(first.val <= second.val) {
                cur.next = first;
                first = first.next;
            } else {
                cur.next = second;
                second = second.next;
            }
            
            cur = cur.next;
        }
        
        if(first) {
            cur.next = first;
        }
        
        if(second) {
            cur.next = second;
        }
        
        cur = h.next;
        h.next = null;
        return cur;
    }
};
</pre>
<hr />
</div>

<div>
<h3>149 Max Points on a Line.js</h3>
<a name="149-max-points-on-a-line-js"></a>
<pre>
?????????3???:

1. ???????
??????,?????????????????p1(x1, y1),p2(x2, y2),p3(x3, y3)??,??????p1-p2??????p1-p3???????,?
(y2-y1)/(x2-x1) = (y3-y1)/(x3-x1)
??????n?,??????????????

2. ???????????
?????p??,??????????qi???,???????????????????????1(?????)?????????

3. ????
?x1 = x2,y1!=y2?,??????????????0????
?x1 = x2,y1 = y2?,??????(x2, y2)???(x1, y1)??????


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
class Solution {
public:
    int maxPoints(vector<Point> &points) {
        int maxPts = 0;
        for(int i=0; i<points.size(); i++) {
            int nMax = 0, nSame = 0, nInf = 0;
            unordered_map<float,int> comSlopes;
            
            for(int j=i+1; j<points.size(); j++) {
                if(points[j].x==points[i].x) {
                    if(points[j].y==points[i].y)
                        nSame++;
                    else
                        nInf++;
                    continue;
                }
                float slope = (float)(points[j].y-points[i].y)/(float)(points[j].x-points[i].x);
                comSlopes[slope]++;
                nMax = max(nMax, comSlopes[slope]);
            }
            
            nMax = max(nMax, nInf)+nSame+1;
            maxPts = max(maxPts,nMax);
        }
        return maxPts;
    }
};

</pre>
<hr />
</div>

<div>
<h3>15 3Sum.js</h3>
<a name="15-3sum-js"></a>
<pre>
// Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

// Note: The solution set must not contain duplicate triplets.

// For example, given array S = [-1, 0, 1, 2, -1, -4],

// A solution set is:
// [
//   [-1, 0, 1],
//   [-1, -1, 2]
// ]
// Hide Company Tags Amazon Microsoft Bloomberg Facebook Adobe
// Hide Tags Array Two Pointers
// Hide Similar Problems (E) Two Sum (M) 3Sum Closest (M) 4Sum (M) 3Sum Smaller



/**
 * @param {number[]} nums
 * @return {number[][]}
 */

var threeSum = function(nums) {
    var result = [];
    
    if(nums.length < 3){
        return result;
    }
    
    nums.sort(function(a,b){return a>b ? 1 : -1;});
    
    var len = nums.length;
    
    for(var i = 0; i < len-2; i++){
        
        if(i === 0 || nums[i] > nums[i-1]){ // very important, same as line 40, remove duplicate as 111 will only run once 1-> rather tan 1 1 1
            target = 0 - nums[i];
            
            j = i + 1;
            k = len - 1;
            
            while(j < k){
                if(nums[j] + nums[k] === target){
                    result.push([nums[i],nums[j],nums[k]]);
                    j++;
                    k--;
                    while(j < k && nums[j] === nums[j-1]){j++;}
                    while(j < k && nums[k] === nums[k+1]){k--;}
                } else if(nums[j] + nums[k] < target){
                    j++;
                } else {
                    k--;
                }
            }
        }
        // very important, same as line 19
        // if(i < len - 1){ 
        //     while(nums[i] === nums[i+1]){i++;}
        // }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>150 Evaluate Reverse Polish Notation.js</h3>
<a name="150-evaluate-reverse-polish-notation-js"></a>
<pre>
// Evaluate the value of an arithmetic expression in Reverse Polish Notation.

// Valid operators are +, -, *, /. Each operand may be an integer or another expression.

// Some examples:
//   ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
//   ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
// Hide Company Tags LinkedIn
// Hide Tags Stack
// Hide Similar Problems (H) Basic Calculator (H) Expression Add Operators

/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
    var stack = [];
    
    for(var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var val1,val2;
        var val = parseInt(token);
        if(!isNaN(val)) {
            stack.push(val);
        } else {
            val2 = stack.pop();
            val1 = stack.pop();
            
            if(token === '*') {
                stack.push(parseInt(val1 * val2));
            } else if(token === '/') {
                stack.push(parseInt(val1 / val2));
            } else if(token === '-') {
                stack.push(val1 - val2);
            } else if(token === '+') {
                stack.push(val1 + val2);
            }
        }
    }
    
    return stack.pop();
};


console.log(evalRPN([ 12, 12, 12, '*', '+', 3, 4, '-', '+' ] ));

</pre>
<hr />
</div>

<div>
<h3>151 Reverse Words in a String.js</h3>
<a name="151-reverse-words-in-a-string-js"></a>
<pre>
// Leetcode #151
// Language: Javascript
// Problem: https://leetcode.com/problems/reverse-words-in-a-string/
// Author: Chihung Yu
/**
 * @param {string} str
 * @returns {string}
 */
var reverseWords = function(str) {
    return str.split(' ').reverse().join(' ').replace(/^\s+|\s+$/g,'').replace(/\s+/g, ' ');
};
</pre>
<hr />
</div>

<div>
<h3>152 Maximum Product Subarray.js</h3>
<a name="152-maximum-product-subarray-js"></a>
<pre>
// Find the contiguous subarray within an array (containing at least one number) which has the largest product.

// For example, given the array [2,3,-2,4],
// the contiguous subarray [2,3] has the largest product = 6.

// Hide Company Tags LinkedIn
// Hide Tags Array Dynamic Programming
// Show Similar Problems



// Leetcode #152
// Language: Javascript
// Problem: https://leetcode.com/problems/maximum-product-subarray/
/**
 * @param {number[]} nums
 * @return {number}
 */
// reference: http://www.programcreek.com/2014/03/leetcode-maximum-product-subarray-java/
var maxProduct = function(nums) {
  if(nums === null || nums.length === 0){
      return 0;
  }
   
  var max = nums[0];
  var min = max;
  var ans = max;
   
  for(var i = 1; i < nums.length; i++){
      var tmax = nums[i]*max;
      var tmin = nums[i]*min;
      
      max = Math.max(Math.max(tmax, nums[i]), tmin);
      min = Math.min(Math.min(tmax, nums[i]), tmin);
      ans = Math.max(ans,max);
  }
   
  return ans
};
</pre>
<hr />
</div>

<div>
<h3>153 Find Minimum in Rotated Sorted Array.js</h3>
<a name="153-find-minimum-in-rotated-sorted-array-js"></a>
<pre>
// Leetcode #153
// Language: Javascript
// Problem: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function(nums) {
    var s = 0;
    var e = nums.length - 1;
    var min;

    while(s<e-1){
        var mid = s + parseInt((e-s)/2);

        if(nums[mid] < nums[s]){
            e = mid;
        } else if(nums[mid] > nums[e]) {
            s = mid;
        } else {
            return nums[s];
        }

    }

    return Math.min(nums[e], nums[s]);
};

// Another shorter solution;
var findMin = function(nums) {
    var i = 0;
    while(i < nums.length - 1 && nums[i] < nums[i + 1]) {
        i++;
    }
    return (i === nums.length - 1)? nums[0] : nums[i + 1]
};

</pre>
<hr />
</div>

<div>
<h3>155 Min Stack.js</h3>
<a name="155-min-stack-js"></a>
<pre>
// Leetcode #155
// Language: Javascript
// Problem: https://leetcode.com/problems/min-stack/
// Author: Chihung Yu
/**
 * @constructor
 */
var MinStack = function() {
    this.min = [];
    this.stack = [];
}




/**
 * @param {number} x
 * @returns {void}
 */
MinStack.prototype.push = function(x) {
    var min = this.getMin();
    
    this.stack.push(x);
    
    if(min === undefined || min >= x){
        this.min.push(x);
    }
};

/**
 * @returns {void}
 */
MinStack.prototype.pop = function() {
    var val = this.stack.pop();
    var min = this.getMin();
    
    if(val === min){
        this.min.pop();
    }
};

/**
 * @returns {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length-1];
};

/**
 * @returns {number}
 */
MinStack.prototype.getMin = function() {
    return this.min[this.min.length - 1];
};
</pre>
<hr />
</div>

<div>
<h3>156 Binary Tree Upside Down.js</h3>
<a name="156-binary-tree-upside-down-js"></a>
<pre>
// Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

// For example:
// Given a binary tree {1,2,3,4,5},
//     1
//    / \
//   2   3
//  / \
// 4   5
// return the root of the binary tree [4,5,2,#,#,3,1].
//    4
//   / \
//  5   2
//     / \
//    3   1  
// confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.

// Hide Company Tags LinkedIn
// Hide Tags Tree
// Show Similar Problems



/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var upsideDownBinaryTree = function(root) {
    var newRoot = root;
    
    generateUpsideDownHelper(root);
    
    function generateUpsideDownHelper(root) {
        if(!root) {
            return root;
        }
        
        if(!root.left && !root.right) {
            newRoot = root;
            return root;
        }
    
        if(root.left) {
            var ret = generateUpsideDownHelper(root.left);
            ret.left = root.right;
            ret.right = root;
            root.left = null;
            root.right = null;
        }
        
        return root;
    }
    return newRoot;
};


// simpler solution
var upsideDownBinaryTree = function(root) {
    // second condition ensure the left most child will be the new root
    if (!root || (!root.left && !root.right)) {
        return root;
    }
    
    let newRoot = upsideDownBinaryTree(root.left);
    console.log(newRoot.val, root.left)
    
    root.left.left = root.right;
    root.left.right = root;

    // cannot work if we sub root.left with newRoot
    // since new root is always the left most child
    // [doesn't work] newRoot.left = root.right;
    // [doesn't work] newRoot.right = root;
    
    root.left = null;
    root.right = null;
    
    return newRoot;
};

</pre>
<hr />
</div>

<div>
<h3>157 Read N Characters Given Read4.js</h3>
<a name="157-read-n-characters-given-read4-js"></a>
<pre>
// The API: int read4(char *buf) reads 4 characters at a time from a file.

// The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

// By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

// Note:
// The read function will only be called once for each test case.

// Hide Company Tags Facebook
// Hide Tags String
// Hide Similar Problems (H) Read N Characters Given Read4 II - Call multiple times


/**
 * Definition for read4()
 * 
 * @param {character[]} buf Destination buffer
 * @return {number} The number of characters read
 * read4 = function(buf) {
 *     ...
 * };
 */

/**
 * @param {function} read4()
 * @return {function}
 */
var solution = function(read4) {
    /**
     * @param {character[]} buf Destination buffer
     * @param {number} n Maximum number of characters to read
     * @return {number} The number of characters read
     */
    return function(buf, n) {
        var eof = false;
        var total = 0;
        var temp = Array(4);
        
        while(!eof && total < n) {
            // read4 will populate temp with read characters, and return count ...
            var count = read4(temp);
        
            if(count < 4) {
                eof = true;
            }
            
            count = Math.min(count, n - total);
            
            for(var i = 0; i < count; i++) {
                buf[total++] = temp[i];
            }
        }
        
        return total;
    };
};


// [tricky] [important]
</pre>
<hr />
</div>

<div>
<h3>158 Read N Characters Give Read4 II - Call Multiple Times.js</h3>
<a name="158-read-n-characters-give-read4-ii-call-multiple-times-js"></a>
<pre>
// The API: int read4(char *buf) reads 4 characters at a time from a file.

// The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

// By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

// Note:
// The read function may be called multiple times.

// Hide Company Tags Bloomberg Google Facebook
// Hide Tags String
// Hide Similar Problems (E) Read N Characters Given Read4



/**
 * Definition for read4()
 * 
 * @param {character[]} buf Destination buffer
 * @return {number} The number of characters read
 * read4 = function(buf) {
 *     ...
 * };
 */

/**
 * @param {function} read4()
 * @return {function}
 */
var solution = function(read4) {
    let bufRead = [];
    let count = 0; // how many characters read with read4
    let i = 0;
        
    /**
     * @param {character[]} buf Destination buffer
     * @param {number} n Maximum number of characters to read
     * @return {number} The number of characters read
     */
    return function(buf, n) {
        let numChrRead = 0;
        
        while (numChrRead < n) {
            if (i === 0) {
                count = read4(bufRead);
            }
            
            while (i < count && numChrRead < n) {
                buf[numChrRead++] = bufRead[i++];
            }
            
            // read4 buffer used up, start over
            if (i === count) {
                i = 0;
            }
            
            // end of file
            if (count < 4) {
                break;
            }
        }
        
        return numChrRead;
    };
};

</pre>
<hr />
</div>

<div>
<h3>159 Longest Substring with At Most Two Disctinct Characters.js</h3>
<a name="159-longest-substring-with-at-most-two-disctinct-characters-js"></a>
<pre>
// https://segmentfault.com/a/1190000003790746

/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstringTwoDistinct = function(s) {
    var longestSubstr = "";
    var maxLength = 0;
    var start = 0;
    var map = new Map();
    
    for(var i = 0; i < s.length; i++) {
        var c = s.charAt(i);
        
        // if map already contains two distrinct chars and the char is new to the map
        if(map.size > 1 && map.get(c) === undefined) {
            var leftMost = s.length;
              
            // Calc substring len before the new char
            if(i - start > maxLength) {
                // Should not include i, since i is the new distinct char's index
                longestSubstr = s.substring(start, i);
                maxLength = longestSubstr.length;
            }
            
            map.forEach((charIdx, key)=> {
                if(charIdx < leftMost) {
                    leftMost = charIdx;
                }
            });
                      
            start = leftMost + 1;
            map.delete(s[leftMost]);
        }
        
        map.set(c, i);
    }
    
    if(s.length - start > maxLength) {
        longestSubstr = s.substring(start, s.length);
        maxLength = longestSubstr.length;
    }
    
    return maxLength;
};

</pre>
<hr />
</div>

<div>
<h3>16 3Sum Closest.js</h3>
<a name="16-3sum-closest-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
    if(nums === null || nums.length < 2){
        return null;
    }

    if(nums.length === 3){
        return nums.reduce(function(prev,cur){return prev + cur;});
    }

    var result = 0;
    var closest = Infinity;

    nums.sort(function(a,b){return a > b ? 1 : -1;});

    for(var i = 0; i < nums.length; i++){
        var j = i + 1;
        var k = nums.length - 1;
        while(j < k){
            var sum = nums[j] + nums[k] + nums[i];
            var diff = sum - target;

            if(diff === 0){
                return sum;
            }

            if(sum < target){
                diff = target - sum;
                j++;
            } else {
                diff = sum - target;
                k--
            }

            if(diff < closest){
                closest = diff;
                result = sum;
            }
        }

        while(i < (nums.length-1) && nums[i] === nums[i+1]) i++;
    }

    return result;
};

//Shorter solution
var threeSumClosest = function(nums, target) {
    var closest = Number.Infinity;
    var gap = -1;

    nums.sort(function(a, b) { return a - b });
    for(var i = 0; i < nums.length - 2; i++) {
        var low = i + 1;
        var high = nums.length - 1;

        while(low < high) {
            var sum = nums[i] + nums[low] + nums[high];
            partialGap = Math.abs(target - sum);
            if(partialGap < gap || gap === -1) {
                gap = partialGap;
                closest = sum;
            }

            if(sum === target) {
                return target;
            } else if (sum < target) {
                low++;
            } else {
                high--;
            }
        }
    }
    return closest;
};

</pre>
<hr />
</div>

<div>
<h3>160 Intersection Of Two Linked Lists.js</h3>
<a name="160-intersection-of-two-linked-lists-js"></a>
<pre>
// Leetcode #160 
// Language: Javascript
// Problem: https://leetcode.com/problems/intersection-of-two-linked-lists/
// Author: Chihung Yu
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    var lenA = getLen(headA);
    var lenB = getLen(headB);
    
    if(lenA === 0 || lenB === 0){
        return null;
    }
    
    while(lenA > lenB){
        headA = headA.next;
        lenA--;
    }
    
    while(lenB > lenA){
        headB = headB.next;
        lenB--;
    }

    while(lenA && lenB){
        if(headB === headA){
            return headA;
        }
        
        headA = headA.next;
        headB = headB.next;
    }

    return null;
};   

var getLen = function(head){
    var len = 0;
    
    while(head){
        head = head.next;
        len++;
    }
    
    return len;
}
</pre>
<hr />
</div>

<div>
<h3>161 One Edit Distance.js</h3>
<a name="161-one-edit-distance-js"></a>
<pre>
// Given two strings S and T, determine if they are both one edit distance apart.

// Hide Company Tags Snapchat Uber Facebook Twitter
// Hide Tags String
// Hide Similar Problems (H) Edit Distance


/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */

// tricky question!

var isOneEditDistance = function(s, t) {
  if(s.length > t.length) {
    var tmp = s;
    s = t;
    t = tmp;
  }

  if((t.length - s.length) > 1) {
    return false;
  }

  var found = false;
  
  for(var i = 0, j = 0; i < s.length; i++, j++) {
    if(s[i] !== t[j]) {

      if(found) {
        return false;
      }

      found = true;

      if(s.length < t.length) {
        i--;
      }
    }
  }

  return found || s.length < t.length;
};


var isOneEditDistance = function(s, t) {
    if(s.length > t.length) {
        var tmp = s;
        s = t;
        t = tmp;
    }
    
    if(t.length - s.length > 1) {
        return false;
    }
    
    
    var i = 0;
    var j = 0;
    var diff = 0;
    
    while(i < s.length && j < t.length) {
        if(s[i] !== t[j]) {
            if(diff !== 0) {
                return false;
            }
            diff++;
            
            if(t.length !== s.length) {
                i--;
            }
        }
        
        i++;
        j++;
    }
    
    return diff === 1 || (t.length !== s.length && (t.length - j) === 1);
};
</pre>
<hr />
</div>

<div>
<h3>162 Find Peak Element.js</h3>
<a name="162-find-peak-element-js"></a>
<pre>
// Leetcode #162
// Language: Javascript
// Problem: https://leetcode.com/problems/find-peak-element/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
    if(nums === null || nums.length === 0){
        return 0;
    }
    
    var n = nums.length;
    var start = 0;
    var end = n - 1;
    var mid = 0;
    
    while(start <= end){
        mid = start + parseInt((end - start)/2);
        if((mid === 0 || nums[mid] > nums[mid-1]) && (mid === n - 1 || nums[mid] >= nums[mid+1])){
            return mid;
        } else if(mid > 0 && nums[mid-1] > nums[mid]){
            end = mid-1;
        } else{
            start = mid+1;
        }
    }
    
    return mid;
};
</pre>
<hr />
</div>

<div>
<h3>165 Compare Version Numbers.js</h3>
<a name="165-compare-version-numbers-js"></a>
<pre>
// Leetcode #165
// Language: Javascript
// Problem: https://leetcode.com/problems/compare-version-numbers/
// Author: Chihung Yu
/**
 * @param {string} version1
 * @param {string} version2
 * @return {number}
 */
 
var comparator = function(v1,v2){
    
}
 
var compareVersion = function(version1, version2) {
    var arr1 = version1.split('.');
    var arr2 = version2.split('.');
    
    var index = 0;
    var len = Math.max(arr1.length, arr2.length);
    
    while(index < len){
        var v1 = parseInt(arr1[index]);
        var v2 = parseInt(arr2[index]);
        
        if(isNaN(v1) && v2 !== 0){
            return -1;
        }
        
        if(isNaN(v2) && v1 !== 0){
            return 1;
        }
        
        if(v1 > v2){
            return 1;
        } else if(v1 < v2){
            return -1;
        }
        
        index++;
    }
    
    return 0;
};
</pre>
<hr />
</div>

<div>
<h3>166 Fraction to Recurring Decimal.js</h3>
<a name="166-fraction-to-recurring-decimal-js"></a>
<pre>
// Leetcode #166
// Language: Javascript
// Problem: https://leetcode.com/problems/fraction-to-recurring-decimal/
// Author: Chihung Yu
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
//  http://blog.csdn.net/ljiabin/article/details/42025037
var fractionToDecimal = function(numerator, denominator) {
    if(numerator === null || denominator === null){
        return "";
    }
    
    if(numerator === 0){
        return "0";
    }
    
    if(denominator === 0){
        return "";
    }
    
    var answer = "";
    var isNegative = false;
    if((numerator < 0) ^ (denominator < 0)){
        isNegative = true;
    }
    
    var num = Math.abs(numerator);
    var den = Math.abs(denominator);
    
    var res = ~~(num / den);
    
    answer += res;
    
    var rem = (num % den) * 10;
    
    if(rem === 0){
        return fixAnswer(isNegative,answer);
    }
    
    var map = {}
    answer += ".";
    
    while(rem !== 0){
        if(map[rem]){
            var beg = answer.substring(0,map[rem]);
            var end = answer.substring(map[rem]);
            
            answer = beg + '(' + end +')';
            
            return fixAnswer(isNegative,answer);
        }
        
        map[rem] = answer.length;
        res = ~~(rem / den);
        
        answer += res;
        rem = rem%den*10;
    }
    
    return fixAnswer(isNegative,answer);
};

var fixAnswer = function(isNegative, answer){
    answer = answer.replace(/-/g,'');
    if(isNegative){
        answer = '-' + answer;
    }
    
    return answer;
}
</pre>
<hr />
</div>

<div>
<h3>168 Excel Sheet Column Title.js</h3>
<a name="168-excel-sheet-column-title-js"></a>
<pre>
// Leetcode #168
// Language: Javascript
// Problem: https://leetcode.com/problems/excel-sheet-column-title/
// Author: Chihung Yu
/**
 * @param {number} n
 * @return {string}
 */
 
var getLetter = function(num){
    return String.fromCharCode(num + 'A'.charCodeAt(0));
} 

var convertToTitle = function(n) {
    var result = "";
    var base = 1;
    
    while(n > 0){
        n--; // [!!!] key
        rem = n%26;
        result = getLetter(rem) + result;
        n = parseInt(n/26);
    }
  
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>169 Majority Element.js</h3>
<a name="169-majority-element-js"></a>
<pre>
// Leetcode #169
// Language: Javascript
// Problem: https://leetcode.com/problems/majority-element/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    var mj = 0;
    var cnt = 1;
    
    for(var i = 1; i < nums.length; i++){
        if(nums[i] === nums[mj]){
            cnt++;
        } else {
            cnt--;
        }
        
        if(cnt === 0){
            mj = i;
            cnt = 1;
        }
    }
    
    return nums[mj];
};
</pre>
<hr />
</div>

<div>
<h3>17 Letter Combinations of a Phone Number.js</h3>
<a name="17-letter-combinations-of-a-phone-number-js"></a>
<pre>
// Given a digit string, return all possible letter combinations that the number could represent.

// A mapping of digit to letters (just like on the telephone buttons) is given below.



// Input:Digit string "23"
// Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
// Note:
// Although the above answer is in lexicographical order, your answer could be in any order you want.

// Hide Company Tags Amazon Dropbox Google Uber Facebook
// Hide Tags Backtracking String
// Hide Similar Problems (M) Generate Parentheses (M) Combination Sum


/**
 * @param {string} digits
 * @return {string[]}
 */
 
var numToLetters = {
    '0': ' ',
    '1': '',
    '2': 'abc',
    '3': 'def',
    '4': 'ghi',
    '5': 'jkl',
    '6': 'mno',
    '7': 'pqrs',
    '8': 'tuv',
    '9': 'wxyz'
};
 
var letterCombinations = function(digits) {
    var res = [];
    
    if(digits.length === 0) {
        return res;
    }
    
    function dfs(digits, idx, curr) {
        if(idx === digits.length) {
            res.push(curr);
            return;
        }
        
        var letters = numToLetters[digits[idx]];
        
        for(var i = 0; i < letters.length; i++) {
            dfs(digits, idx + 1, curr + letters[i]);
        }
    }
    
    dfs(digits, 0, '');
    return res;
};
</pre>
<hr />
</div>

<div>
<h3>170 Two Sum III - Data structure design.js</h3>
<a name="170-two-sum-iii-data-structure-design-js"></a>
<pre>
/**
 * initialize your data structure here
 * @constructor
 */
var TwoSum = function() {
    this.hashmap = new Map();
};

/**
 * Add the number to an internal data structure.
 * @param {number} input
 * @returns {void}
 */
TwoSum.prototype.add = function(input) {
    this.hashmap[input] = this.hashmap[input] || 0;
    this.hashmap[input]++;
};

/**
 * Find if there exists any pair of numbers which sum is equal to the value.
 * @param {number} val
 * @returns {boolean}
 */
TwoSum.prototype.find = function(val) {  
    for(var key in this.hashmap) {
        var diff = val - parseInt(key);

        if(diff === parseInt(key)){
          if(this.hashmap[diff] >= 2) {
            return true;
          }
        } else if(this.hashmap[diff] >= 1) {
            return true;
        }
    }
    
    return false;
};

/**
 * Your TwoSum object will be instantiated and called as such:
 * var twoSum = new TwoSum();
 * twoSum.add(number);
 * twoSum.find(value);
 */
</pre>
<hr />
</div>

<div>
<h3>171 Excel Sheet Column Number.js</h3>
<a name="171-excel-sheet-column-number-js"></a>
<pre>
// Leetcode #171
// Language: Javascript
// Problem: https://leetcode.com/problems/excel-sheet-column-number/
// Author: Chihung Yu
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    var total = 0;
    var len = s.length;
    var base = 26;
    
    for(var i = 0; i < len; i++){
        var pow = len - i - 1;
        var num = getNumber(s[i]);
        
        total += Math.pow(base,pow)*num;
    }
    
    return total;
};

var getNumber = function(c){
    var charCodeOfA = 'A'.charCodeAt(0);
    var charCodeOfTarget = c.charCodeAt(0);
    
    return charCodeOfTarget - charCodeOfA + 1;
};

</pre>
<hr />
</div>

<div>
<h3>172 Factorial Trailing Zeroes.js</h3>
<a name="172-factorial-trailing-zeroes-js"></a>
<pre>
// Leetcode #172
// Language: Javascript
// Problem: https://leetcode.com/problems/factorial-trailing-zeroes/
// Author: Chihung Yu
/**
 * @param {number} n
 * @return {number}
 */
var trailingZeroes = function(n) {
    if(n < 0){
        return -1;
    }
    
    var count = 0;
    
    while(n>=5){
        var rem = parseInt(n/5);
        count += rem;
        n = rem;
    }
    
    return count;
};
</pre>
<hr />
</div>

<div>
<h3>173 Binary Search Tree Iterator.js</h3>
<a name="173-binary-search-tree-iterator-js"></a>
<pre>
// Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

// Calling next() will return the next smallest number in the BST.

// Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

// Credits:
// Special thanks to @ts for adding this problem and creating all test cases.

// Hide Company Tags LinkedIn Google Facebook Microsoft
// Hide Tags Tree Stack Design
// Hide Similar Problems (M) Binary Tree Inorder Traversal (M) Flatten 2D Vector (M) Zigzag Iterator (M) Peeking Iterator (M) Inorder Successor in BST



/**
 * Definition for binary tree
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * @constructor
 * @param {TreeNode} root - root of the binary search tree
 */
var BSTIterator = function(root) {
    this.stack = [];
    this.pushLeft(root);
};


/**
 * @this BSTIterator
 * @returns {boolean} - whether we have a next smallest number

 */
BSTIterator.prototype.hasNext = function() {
    return this.stack.length !== 0;
};

/**
 * @this BSTIterator
 * @returns {number} - the next smallest number
 */
BSTIterator.prototype.next = function() {
    if(this.hasNext()) {
        var node = this.stack.pop();
        
        if(node.right) {
            this.pushLeft(node.right);
        }
        
        return node.val;
    }
};

BSTIterator.prototype.pushLeft = function(node) {
    while(node) {
        this.stack.push(node);
        node = node.left;
    }
}

/**
 * Your BSTIterator will be called like this:
 * var i = new BSTIterator(root), a = [];
 * while (i.hasNext()) a.push(i.next());
*/
</pre>
<hr />
</div>

<div>
<h3>179 Largest Number.js</h3>
<a name="179-largest-number-js"></a>
<pre>
// Leetcode #179
// Language: Javascript
// Problem: https://leetcode.com/problems/largest-number/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {string}
 */
var largestNumber = function(nums) {
    nums.sort(cmp);
    var result = nums.join('');
    
    return parseInt(result) === 0 ? '0' : result;
};

var cmp = function(a,b){
    return ('' + a + b) > ('' + b + a) ? -1 : 1;
}
</pre>
<hr />
</div>

<div>
<h3>18. 4Sum.js</h3>
<a name="18-4sum-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    var results = [];
    nums.sort(function(a,b) { return a - b });
    for(var i = 0; i < nums.length - 3; i++) {
        while(i > 0 && i < nums.length - 3 && nums[i] === nums[i - 1]) {
            i++;
        }
        for(var j = i + 1; j < nums.length - 2; j++) {
            while(j > i + 1 && j < nums.length - 2 && nums[j] === nums[j - 1]) {
                j++;
            }
            var low = j + 1;
            var high = nums.length - 1;
            var newTarget = target - (nums[i] + nums[j]);
            while(low < high) {
                partialSum = nums[low] + nums[high];
                if(partialSum === newTarget) {
                    results.push([nums[i], nums[j], nums[low], nums[high]]);
                    high--;
                    low++;
                    while(low < high && nums[low] === nums[low - 1]) {
                        low++;
                    }
                    while(low < high && nums[high] === nums[high + 1]) {
                        high--;
                    }
                } else if (partialSum > newTarget) {
                    high--;
                } else {
                    low++;
                }
            }
        }
    }
    return results;
};

</pre>
<hr />
</div>

<div>
<h3>186 Reverse Words in a String II.js</h3>
<a name="186-reverse-words-in-a-string-ii-js"></a>
<pre>
// Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.

// The input string does not contain leading or trailing spaces and the words are always separated by a single space.

// For example,
// Given s = "the sky is blue",
// return "blue is sky the".

// Could you do it in-place without allocating extra space?

/**
 * @param {character[]} str
 * @return {void} Do not return anything, modify the string in-place instead.
 */
var reverseWords = function(str) {
    var arr = str;
    
    reverse(arr, 0, arr.length - 1);
    var last = 0;
  
    for(var i = 0; i <= arr.length; i++) {
        if(arr[i] === ' ' || i === arr.length) {
            reverse(arr, last, i - 1);
            last = i + 1;
        }
    }
    
    function reverse(arr, beg, end) {
        while(beg < end) {
            var tmp = str[beg];
            str[beg] = str[end];
            str[end] = tmp;
            beg++;
            end--;
        }    
    }  
};
</pre>
<hr />
</div>

<div>
<h3>187 Repeated DNA Sequences.js</h3>
<a name="187-repeated-dna-sequences-js"></a>
<pre>
// All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

// Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

// For example,

// Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

// Return:
// ["AAAAACCCCC", "CCCCCAAAAA"].
// Hide Company Tags LinkedIn
// Hide Tags Hash Table Bit Manipulation


/**
 * @param {string} s
 * @return {string[]}
 */
var findRepeatedDnaSequences = function(s) {
    var hash = {};
    var result = [];
    
    for(var i = 10; i <= s.length; i++) {
        var substr = s.substring(i - 10, i);
        if(hash[substr] === undefined) {
            hash[substr] = 1;
        } else if(hash[substr] === 1) {
            hash[substr]++;
            result.push(substr);
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>188 Best Time to Buy and Sell Stock IV.js</h3>
<a name="188-best-time-to-buy-and-sell-stock-iv-js"></a>
<pre>
// memory limit exceeded
// Time O(n*k)
// Space (n*k)
// ref: http://blog.csdn.net/fightforyourdream/article/details/14503469

/**
 * @param {number} k
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(k, prices) {
    var len = prices.length;
    
    if(len === 0) {
        return 0;
    }
    var globalBest = initMatrix(len, k + 1);
    var localBest = initMatrix(len, k + 1);
    
    // matrix[row][col]
    // row is ith day
    // col is jth transaction
    // localBest[i][j] is the max profit across i day, with j transaction where there is transaction happening on i day
    // globalBest[i][j] is the max profit across i day, with j transaction
    
    for(var i = 1; i < len; i++) {
        var diff = prices[i] - prices[i - 1];
        
        for(var j = 1; j <= k; j++) {
            
            // globalBest[i - 1][j - 1] + Math.max(diff, 0)
            // -> current global best before ith day and jth transaction, Math.max(diff, 0) means we can take this transaction into account or discard it.
            // localBest[i - 1][j] + diff 
            // -> since localBest[i][j] means the last transaction has to happen on this day, regardless transaction lost money or not, we need to add it.
            // In addition, localBest[i - 1][j] + diff -> does not add transaction count e.g.
            // [buy, sell and buy, sell] is the same as [buy, nothing, sell] since it's all continuous actions
            localBest[i][j] = Math.max(globalBest[i - 1][j - 1] + Math.max(diff, 0), localBest[i - 1][j] + diff);
            globalBest[i][j] = Math.max(globalBest[i - 1][j], localBest[i][j]);
        }
    }
    
    return globalBest[len - 1][k];
};


function initMatrix(days, transactions) {
    var matrix = [];
    
    for(var i = 0; i < days; i++) {
        matrix.push([]);
        for(var j = 0; j < transactions; j++) {
            matrix[i][j] = 0;
        }
    }
    
    return matrix;
}
</pre>
<hr />
</div>

<div>
<h3>189 Rotate Array.js</h3>
<a name="189-rotate-array-js"></a>
<pre>
// Leetcode #189
// Language: Javascript
// Problem: https://leetcode.com/problems/rotate-array/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {void} Do not return anything, modify nums in-place instead.
 */
 
Array.prototype.reverseFromLToR = function(left,right){
    if(right >= this.length){
        return;
    }

    while(left < right){
        var temp = this[left];
        this[left] = this[right];
        this[right] = temp;
        left++;
        right--;
    }
}
var rotate = function(nums, k) {
    k = k%nums.length;
    
    nums.reverse();
    nums.reverseFromLToR(0,k-1);
    nums.reverseFromLToR(k,nums.length-1);
};
</pre>
<hr />
</div>

<div>
<h3>19 Remove Nth Node From End of List.js</h3>
<a name="19-remove-nth-node-from-end-of-list-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    var n1 = new ListNode();
    var n2 = new ListNode();
    var dummy = n2;
    
    n1.next = head;
    n2.next = head;
    
    while(n > 0 && n1){
        n1 = n1.next;
        n--;
    }
    
    if(n > 0){
        return head;
    }
    
    while(n1 && n1.next){
        n1 = n1.next;
        n2 = n2.next;
    }
    
    n2.next = n2.next.next;
    
    return dummy.next;
};
</pre>
<hr />
</div>

<div>
<h3>190 Reverse Bits.js</h3>
<a name="190-reverse-bits-js"></a>
<pre>
// Leetcode #190
// Language: Javascript
// Problem: https://leetcode.com/problems/reverse-bits/
// Author: Chihung Yu
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    var result =  0;
    
    for(var i = 0; i < 32; i++){
        result <<= 1;
        result |= n & 1;
        n >>= 1;
    }
    
    return Math.abs(result);
};
</pre>
<hr />
</div>

<div>
<h3>191 Number of 1 Bits.js</h3>
<a name="191-number-of-1-bits-js"></a>
<pre>
// Leetcode #191
// Language: Javascript
// Problem: https://leetcode.com/problems/number-of-1-bits/
// Author: Chihung Yu

// Write a function that takes an unsigned integer and returns the number of 1' bits it has (also known as the Hamming weight).

// For example, the 32-bit integer 11' has binary representation 00000000000000000000000000001011, so the function should return 3.

// Credits:
// Special thanks to @ts for adding this problem and creating all test cases.

// Hide Company Tags Microsoft Apple
// Hide Tags Bit Manipulation
// Hide Similar Problems (E) Reverse Bits (E) Power of Two (M) Counting Bits



/**
 * @param {number} n - a positive integer
 * @return {number}
 */

var hammingWeight = function(n) {
    if(n === null){
        return n;
    }
    count = 0;
    
    while(n !== 0){
        n = n & (n-1);
        // use x & (x-1) to determine if an integer is a power of two
        // every time you perform the operation x & (x-1), a single 1 bit is erased
        count++;
    }
    
    return count;
};
</pre>
<hr />
</div>

<div>
<h3>198 House Robber.js</h3>
<a name="198-house-robber-js"></a>
<pre>
// You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

// Credits:
// Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases.

// Hide Company Tags LinkedIn Airbnb
// Show Tags
// Show Similar Problems



// Leetcode #198
// Language: Javascript
// Problem: https://leetcode.com/problems/house-robber/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    if(nums === null){
        return nums;
    }
    
    var even = 0;
    var odd = 0;
    
    for(var i = 0; i < nums.length; i++){
        if(i%2 === 0){
            even = Math.max(even + nums[i], odd);
        } else {
            odd = Math.max(odd + nums[i], even);
        }
    }
    
    return Math.max(even,odd);
};


// var rob = function(nums) {
//     var dp = [];
    
//     if(!nums || nums.length === 0) {
//         return 0;
//     }
//     // dp[i] is the max amount can rob on ith house
    
//     for(var i = 0; i < nums.length; i++){
//         var num = nums[i];
//         dp[i] = Math.max((dp[i-2] || 0) + num, (dp[i-1] || 0));
//     }
    
//     return dp[nums.length - 1];
// };


</pre>
<hr />
</div>

<div>
<h3>199 Binary Tree Right Side View.js</h3>
<a name="199-binary-tree-right-side-view-js"></a>
<pre>
// For example:
// Given the following binary tree,
//    1            <---
//  /   \
// 2     3         <---
//  \     \
//   5     4       <---
// You should return [1, 3, 4].


/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    var result = [];
    
    if(root === null) {
        return result;
    }
    
    queue = [];
    queue.push(root);
    
    while(queue.length > 0) {
        var len = queue.length;
        
        for(var i = 0; i < len; i++) {
            var node = queue.shift();
            
            if(node.left) {
                queue.push(node.left);
            }
            
            if(node.right) {
                queue.push(node.right);
            }
            
            if(i === len - 1) {
                result.push(node.val);
            }
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>2 Add Two Numbers.js</h3>
<a name="2-add-two-numbers-js"></a>
<pre>
// You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

// Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
// Output: 7 -> 0 -> 8

//  Amazon Microsoft Bloomberg Airbnb Adobe

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */



// value reverse helps to asslign the first digit or both linklist

var addTwoNumbers = function(l1, l2) {
    if(l1 === null || l2 === null){
        return l1 || l2;
    }
    
    var result = new ListNode(0);
    var cur = result;
    var p = l1;
    var q = l2;
    var carry = 0;
    
    while(p || q){
        var qval;
        var pval;
        
        if(q){
            qval = q.val;
            q = q.next;
        } else {
            qval = 0;
        }
        
        if(p){
            pval = p.val;
            p = p.next;
        } else {
            pval = 0;
        }
        
        var val = qval + pval + carry;
        
        if(val > 9){
            carry = 1;
            val %= 10;
        } else {
            carry = 0;
        }
        
        cur.next = new ListNode(val);
        cur = cur.next;
    }
    
    if(carry !== 0){
        cur.next = new ListNode(1);
    }
    
    return result.next;
    
};
</pre>
<hr />
</div>

<div>
<h3>20 Valid Parentheses.js</h3>
<a name="20-valid-parentheses-js"></a>
<pre>
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    var stack = [];
    var index = 0;
    while(index < s.length){
        var c = s[index];
        
        if(c === "(" || c === "[" || c === "{"){
            stack.push(c);
        } else {
            var oldC = stack.pop();
            
            if(oldC === '(' && c !== ')'){
                return false;
            } else if(oldC === '[' && c !== ']'){
                return false;
            } else if(oldC === '{' && c !== '}'){
                return false;
            } else if(oldC === undefined) {
                return false;
            }
        }
        
        index++;
    }
    
    return stack.length === 0;
};

// second attempt

var isValid = function(s) {
    var stack = [];
    
    for(var i = 0; i < s.length; i++) {
        var chr = s[i];
        
        if(chr === '(' || chr === '{' || chr === '[') {
            stack.push(chr);
        } else if(chr === ')' || chr === '}' || chr === ']') {
            var top = stack.pop();
            if(!top || (top === '(' && chr !== ')') || (top === '{' && chr !== '}') || (top === '[' && chr !== ']')) {
                return false;
            }
        }
    }
    
    return stack.length === 0;
};
</pre>
<hr />
</div>

<div>
<h3>200 Number of Islands.js</h3>
<a name="200-number-of-islands-js"></a>
<pre>
// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

// Example 1:

// 11110
// 11010
// 11000
// 00000
// Answer: 1

// Example 2:

// 11000
// 11000
// 00100
// 00011
// Answer: 3
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    var visited = [];
    var row = grid.length;
    
    if(!grid || row === 0) {
        return 0;
    }
    
    var col = grid[0].length;
    var count = 0;
    for(var i = 0; i < row; i++) {
        for(var j = 0; j < col; j++) {
            if(grid[i][j] === '1') {
                count++;
                traverse(i, j, grid, row, col);    
            }
        }
    }
    
    return count;
};

var traverse = function(i, j, grid, row, col) {
    if((0 <= i &&  i < row) && (0 <= j && j < col) && grid[i][j] === '1') {
        grid[i][j] = '2';
    
        
        traverse(i + 1, j, grid, row, col);
        traverse(i, j + 1, grid, row, col);
        traverse(i - 1, j, grid, row, col);
        traverse(i, j - 1, grid, row, col);
    }
}

// non recusion
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    var count = 0;
    
    function traverseIsland(i, j, grid) {
        var stack = [];
        
        stack.push([i, j]);
        
        while(stack.length) {
            var pair = stack.pop();
            i = pair[0];
            j = pair[1];
            
            if(i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] === '1') {
                grid[i][j] = '2';
                stack.push([i + 1, j]);
                stack.push([i - 1, j]);
                stack.push([i, j + 1]);
                stack.push([i, j - 1]);
            }
        }
    }
    
    for(var i = 0; i < grid.length; i++) {
        for(var j = 0; j < grid[0].length; j++) {
            if(grid[i][j] === '1') {
                traverseIsland(i, j, grid);
                count++;
            }
        }
    }
    
    return count;
};
</pre>
<hr />
</div>

<div>
<h3>201 Bitwise AND of Numbers Range.js</h3>
<a name="201-bitwise-and-of-numbers-range-js"></a>
<pre>
// Leetcode #201
// Language: Javascript
// Problem: https://leetcode.com/problems/bitwise-and-of-numbers-range/
// Author: Chihung Yu
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
 
var rangeBitwiseAnd = function(m, n) {
    while(n > m){
        n = n & (n-1);
    }
    
    return m & n;
};
</pre>
<hr />
</div>

<div>
<h3>202 Happy Number.js</h3>
<a name="202-happy-number-js"></a>
<pre>
// Leetcode #202
// Language: Javascript
// Problem: https://leetcode.com/problems/happy-number/
// Author: Chihung Yu
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    if(n === null){
        return false;
    }
    
    var val = n;
    var hash = {};
    
    while(!hash[val]){
        if(val === 1){
            return true;
        }
        
        hash[val] = true;
        
        var sn = val + '';
        var sarr = sn.split('');    
        var total = 0;
        
        for(var i = 0; i < sarr.length; i++){
            si = parseInt(sarr[i]);
            total += Math.pow(si,2);
        }
        
        
        val = total;
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>203 Remove Linked List Elements.js</h3>
<a name="203-remove-linked-list-elements-js"></a>
<pre>
// Leetcode #203
// Language: Javascript
// Problem: https://leetcode.com/problems/remove-linked-list-elements/
// Author: Chihung Yu
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
    if(head === null){
        return head;
    }
    
    var dummy = new ListNode(-1);
    dummy.next = head;
    prev = dummy;
    cur = head;
    
    while(prev !== null && prev.next !== null){
        if(cur.val === val) {
            prev.next = cur.next;
            cur = prev.next;
        } else {
            prev = cur;
            cur = cur.next;
        }
    }
    
    return dummy.next;
};
</pre>
<hr />
</div>

<div>
<h3>204 Count Primes.js</h3>
<a name="204-count-primes-js"></a>
<pre>
// Description:

// Count the number of prime numbers less than a non-negative number, n.

// Leetcode #204
// Language: Javascript
// Problem: https://leetcode.com/problems/count-primes/
// Author: Chihung Yu
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
    if(n <= 2){
        return 0;
    }

    var mem = [];
    
    for(var i = 2; i < n; i++){
        mem[i] = true;
    }
    
    sq = parseInt(Math.sqrt(n - 1));

    for(i = 2; i <= sq; i++){
        if(mem[i]){
            for(var j = i + i; j < mem.length; j += i){
                mem[j] = false;
            }
        }
    }

    var count = 0;
    for(i = 2; i < mem.length; i++){
        if(mem[i]){
            count++;    

        }
    }
    
    return count;
}
</pre>
<hr />
</div>

<div>
<h3>205 Isomorphic Strings.js</h3>
<a name="205-isomorphic-strings-js"></a>
<pre>
// Given two strings s and t, determine if they are isomorphic.

// Two strings are isomorphic if the characters in s can be replaced to get t.

// All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

// For example,
// Given "egg", "add", return true.

// Given "foo", "bar", return false.

// Given "paper", "title", return true.

// Note:
// You may assume both s and t have the same length.

// Hide Company Tags LinkedIn
// Hide Tags Hash Table
// Hide Similar Problems (E) Word Pattern



/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
    if(s.length !== t.length) {
        return false;
    }
    
    var hash1 = {};
    var hash2 = {};
    
    for(var i = 0; i < s.length; i++) {
        hash1[s[i]] = t[i];
        hash2[t[i]] = s[i];
    }
    
    var result1 = '';
    var result2 = '';
    
    for(i = 0; i < s.length; i++) {
        result1 += hash1[s[i]];
        result2 += hash2[t[i]];
    }
    
    return result1 === t && result2 === s;
};
</pre>
<hr />
</div>

<div>
<h3>206 Reverse Linked List.js</h3>
<a name="206-reverse-linked-list-js"></a>
<pre>
// Leetcode #206
// Language: Javascript
// Problem: https://leetcode.com/problems/reverse-linked-list/
// Author: Chihung Yu


// Reverse a singly linked list.

// Uber Facebook Twitter Zenefits Amazon Microsoft Snapchat Apple Yahoo Bloomberg Yelp Adobe
// Show Tags
// Show Similar Problems

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    var curr = head;
    var prev = null;
    
    while(curr) {
        var next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next; 
    }
    
    return prev;
};
</pre>
<hr />
</div>

<div>
<h3>207 Course Schedule.js</h3>
<a name="207-course-schedule-js"></a>
<pre>
// Leetcode #225
// Language: Javascript
// Problem: https://leetcode.com/problems/course-schedule/
// Author: Chihung Yu

// Non-recursion version 144ms
// more generic solution to problem that doesn't need information of numCourses and can deal with duplicated prerequisites

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
    var courseWithOtherCoursesDependOn = {};
    var courseDependsOnOtherCourses = {};
    
    prerequisites.forEach((prerequisite)=> {
        var prereqCourse = prerequisite[1];
        var courseToTake = prerequisite[0]
        
        
        courseWithOtherCoursesDependOn[prereqCourse] = courseWithOtherCoursesDependOn[prereqCourse] || new Set();
        courseWithOtherCoursesDependOn[prereqCourse].add(courseToTake);
        
        courseDependsOnOtherCourses[prereqCourse] = courseDependsOnOtherCourses[prereqCourse] || new Set();
        courseDependsOnOtherCourses[courseToTake] = courseDependsOnOtherCourses[courseToTake] || new Set();
        courseDependsOnOtherCourses[courseToTake].add(prereqCourse);
    });
    
    var courseWithNoDependencies = [];
    
    for(var i in courseDependsOnOtherCourses) {
        if(courseDependsOnOtherCourses[i].size === 0) {
            courseWithNoDependencies.push(i);
        }
    }
    
    while(courseWithNoDependencies.length > 0) {
        var rootCourse = courseWithNoDependencies.shift();
        
        if(courseWithOtherCoursesDependOn[rootCourse]) {
            courseWithOtherCoursesDependOn[rootCourse].forEach((childCourse)=> {
                courseDependsOnOtherCourses[childCourse].delete(parseInt(rootCourse));
                
                if(courseDependsOnOtherCourses[childCourse].size === 0) {
                    courseWithNoDependencies.push(childCourse + '');
                }
            });
        }
    }
    
    for(i in courseDependsOnOtherCourses) {
        if(courseDependsOnOtherCourses[i].size !== 0) {
            return false;
        }
    }
    
    return true;
};



// recursion 132ms

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */

 // http://www.cnblogs.com/Liok3187/p/4752700.html

var constructGraph = function(numNodes, pre) {
    var nodes = [];
    for (var i = 0; i < numNodes; i++) {
        var node = {};
        node.neighbors = [];
        nodes.push(node);
    }
    for (var j = 0; j < pre.length; j++) {
        var requiredCourse = pre[j][1];
        var course = pre[j][0];
        // pushing course that require required-course to it's neighbor
        // when we go to the required-course, and traverse it's neighbors, we want to make sure that those neighbor doesn't have others that nodes
        // that required those neighbor plus those neighbor's required-course
        // example [1,0], [0,2], [2,1]
        // 1 required 0, 0 required 2, and 2 required 1
        // it creates loop
        nodes[requiredCourse].neighbors.push(nodes[course]);
    }
    return nodes;
}

// Return true if there is a cycle detected.
var dfs = function(startNode, parents) {
    if (parents.indexOf(startNode) >= 0) return true;
    if (startNode.visited) return false;
    
    startNode.visited = true;
    var neighbors = startNode.neighbors;
    parents.push(startNode);
    for (var i = 0; i < neighbors.length; i++) {
        var hasCycle = dfs(neighbors[i], parents);
        if (hasCycle) return true;
    }
    parents.pop();
}

var canFinish = function(numCourses, prerequisites) {
    var nodes = constructGraph(numCourses, prerequisites);
    
    for (var i = 0; i < nodes.length; i++) {
        var parent = [];
        var hasCycle = dfs(nodes[i], parent);

        if (hasCycle) return false;
    }
    return true;
};



</pre>
<hr />
</div>

<div>
<h3>208 Implement Trie (Prefix Tree).js</h3>
<a name="208-implement-trie-prefix-tree-js"></a>
<pre>
/**
 * @constructor
 * Initialize your data structure here.
 */
//  http://www.cnblogs.com/Liok3187/p/4626730.html
var TrieNode = function(key) {
    return {
        key: key,
        isWord: false,
        children: {}
    }
};

var Trie = function() {
    this.root = TrieNode();
};

/**
 * @param {string} word
 * @return {void}
 * Inserts a word into the trie.
 */
Trie.prototype.insert = function(word) {
    var tree = this.root;
    var i, curr;
    
    for(i = 0; i < word.length; i++) {
        curr = word[i];
        if(!tree.children[curr]) {
            tree.children[curr] = TrieNode(curr);
        }
        tree = tree.children[curr];
    }
    
    tree.isWord = true;
};

/**
 * @param {string} word
 * @return {boolean}
 * Returns if the word is in the trie.
 */
Trie.prototype.search = function(word) {
    var tree = this.root;
    
    for(var i = 0; i < word.length; i++) {
        var curr = word[i];
        
        if(!tree.children[curr]) {
            return false;
        }
        
        tree = tree.children[curr];
    }
    
    return tree.isWord;
};

/**
 * @param {string} prefix
 * @return {boolean}
 * Returns if there is any word in the trie
 * that starts with the given prefix.
 */
Trie.prototype.startsWith = function(prefix) {
    var tree = this.root;
    
    for(var i = 0; i < prefix.length; i++) {
        var curr = prefix[i];
        
        if(!tree.children[curr]) {
            return false;
        }
        
        tree = tree.children[curr];
    }
    
    return true;    
};

/**
 * Your Trie object will be instantiated and called as such:
 * var trie = new Trie();
 * trie.insert("somestring");
 * trie.search("key");
 */
</pre>
<hr />
</div>

<div>
<h3>209 Minimum Size Subarray Sum.js</h3>
<a name="209-minimum-size-subarray-sum-js"></a>
<pre>
// http://blog.csdn.net/lisonglisonglisong/article/details/45666975
// http://www.cnblogs.com/grandyang/p/4501934.html

// Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum = s. If there isn't one, return 0 instead.

// For example, given the array [2,3,1,2,4,3] and s = 7,
// the subarray [4,3] has the minimal length under the problem constraint.

// click to show more practice.

// Credits:
// Special thanks to @Freezen for adding this problem and creating all test cases.

// Hide Company Tags Facebook
// Hide Tags Array Two Pointers Binary Search
// Hide Similar Problems (H) Minimum Window Substring (M) Maximum Size Subarray Sum Equals k


/**
 * @param {number} s
 * @param {number[]} nums
 * @return {number}
 */

// O(n) solution
var minSubArrayLen = function(s, nums) {
    var sum = 0;
    var left = 0;
    var right = 0;
    var minLen = Infinity;
    
    while(right < nums.length) {
        while(right < nums.length && sum < s) {
            sum += nums[right++];
        }
        
        while(sum >= s) {
            minLen = Math.min(minLen, right - left);
            sum -= nums[left++];
        }
    }
    
    return minLen > nums.length ? 0 : minLen;
};

// The O(NlogN) solution is to sum up the array
// [1,2,3,4,5] becomes [1,3,6,10,15]
// then iterate through array from index 0 to nums.length - 1
// for each value in the summed array
// binary search values after that index so the difference becomes greater than s
// example
// s = 8
// at index 0 with value 1 look between [3,6,10,15] using binary search.
// we can find that at value 10 the difference is 10 - 1 = 9 the minLen is index 3 - 1 + 1 = 3
// then we check index 1 with value 3 and binary search [6,10,15] we can find that at value 15 we have difference 15 - 3 = 12
// the distance is index 4 - 1 + 1 = 4

// console.log(minSubArrayLen(11, [1,2,3,4,5]));
</pre>
<hr />
</div>

<div>
<h3>21 Merge Two Sorted Lists.js</h3>
<a name="21-merge-two-sorted-lists-js"></a>
<pre>
// Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

// Hide Company Tags Amazon LinkedIn Apple Microsoft
// Hide Tags Linked List
// Hide Similar Problems (H) Merge k Sorted Lists (E) Merge Sorted Array (M) Sort List (M) Shortest Word Distance II

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    var p1 = l1;
    var p2 = l2;
    var fn = new ListNode(-1);
    var p = fn;
    
    
    while(p1 && p2){
        if(p1.val >= p2.val){
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        p = p.next;
    }
    
    if(p1){
        p.next = p1;
    } else {
        p.next = p2;
    }
    
    return fn.next;
};
</pre>
<hr />
</div>

<div>
<h3>210 Course Schedule II.js</h3>
<a name="210-course-schedule-ii-js"></a>
<pre>
// There are a total of n courses you have to take, labeled from 0 to n - 1.

// Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

// Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

// There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

// For example:

// 2, [[1,0]]
// There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]

// 4, [[1,0],[2,0],[3,1],[3,2]]
// There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

// Note:
// The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

// click to show more hints.

// Hide Company Tags Facebook Zenefits
// Hide Tags Depth-first Search Breadth-first Search Graph Topological Sort
// Hide Similar Problems (M) Course Schedule (H) Alien Dictionary (M) Minimum Height Trees


// 160ms

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
var findOrder = function(numCourses, prerequisites) {
    var courseWithOtherCoursesDependOn = {};
    var courseDependsOnOtherCourses = {};
    
    prerequisites.forEach((prerequisite)=> {
        var prereqCourse = prerequisite[1];
        var courseToTake = prerequisite[0]
        
        
        courseWithOtherCoursesDependOn[prereqCourse] = courseWithOtherCoursesDependOn[prereqCourse] || new Set();
        courseWithOtherCoursesDependOn[prereqCourse].add(courseToTake);
        
        courseDependsOnOtherCourses[prereqCourse] = courseDependsOnOtherCourses[prereqCourse] || new Set();
        courseDependsOnOtherCourses[courseToTake] = courseDependsOnOtherCourses[courseToTake] || new Set();
        courseDependsOnOtherCourses[courseToTake].add(prereqCourse);
    });
    
    var courseWithNoDependencies = [];
    
    for(var i in courseDependsOnOtherCourses) {
        if(courseDependsOnOtherCourses[i].size === 0) {
            courseWithNoDependencies.push(i);
        }
    }
    

    // pretty much the same as Course Schedule I. Just need to add those non root
    var courseOrders = [];
    var hasCourseOrders = {};
    
    while(courseWithNoDependencies.length > 0) {
        var rootCourse = courseWithNoDependencies.shift();
        
        courseOrders.push(parseInt(rootCourse));
        hasCourseOrders[parseInt(rootCourse)] = true;
        
        if(courseWithOtherCoursesDependOn[rootCourse]) {
            courseWithOtherCoursesDependOn[rootCourse].forEach((childCourse)=> {
                courseDependsOnOtherCourses[childCourse].delete(parseInt(rootCourse));
                
                if(courseDependsOnOtherCourses[childCourse].size === 0) {
                    courseWithNoDependencies.push(childCourse + '');
                }
            });
        }
    }
    
    for(i in courseDependsOnOtherCourses) {
        if(courseDependsOnOtherCourses[i].size !== 0) {
            return [];
        }
    }
    
    if(courseOrders.length < numCourses) {
        for(i = 0; i < numCourses; i++) {
            if(!hasCourseOrders[i]) {
                courseOrders.push(i);
            }
        }
    }
    
    return courseOrders;
};

console.log(findOrder(3, [[1,0]]));
</pre>
<hr />
</div>

<div>
<h3>211 Add and Search Word - Data structure design.js</h3>
<a name="211-add-and-search-word-data-structure-design-js"></a>
<pre>
// Design a data structure that supports the following two operations:

// void addWord(word)
// bool search(word)
// search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

// For example:

// addWord("bad")
// addWord("dad")
// addWord("mad")
// search("pad") -> false
// search("bad") -> true
// search(".ad") -> true
// search("b..") -> true
// Note:
// You may assume that all words are consist of lowercase letters a-z.

// click to show hint.

// Hide Company Tags Facebook
// Hide Tags Backtracking Trie Design
// Hide Similar Problems (M) Implement Trie (Prefix Tree)

function TrieNode(chr) {
    this.val = chr;
    this.isWord = false;
    this.children = [];
}

/**
 * @constructor
 */
var WordDictionary = function() {
   this.root = new TrieNode(null, false);
};

/**
 * @param {string} word
 * @return {void}
 * Adds a word into the data structure.
 */
WordDictionary.prototype.addWord = function(word) {
    var node = this.root;
    for(var i = 0; i < word.length; i++) {
        var chr = word[i];
        node.children[chr] = node.children[chr] || new TrieNode(chr);
        node = node.children[chr];
    }
    
    node.isWord = true;
};

/**
 * @param {string} word
 * @return {boolean}
 * Returns if the word is in the data structure. A word could
 * contain the dot character '.' to represent any one letter.
 */
WordDictionary.prototype.search = function(word) {
    var node = this.root;
    
    function dfs(node, word, i) {
        if(i === word.length) {
            return node.isWord;
        }
        
        var chr = word[i];
        
        if(chr === '.') {
            for(var key in node.children) {
                if(dfs(node.children[key], word, i + 1)) {
                    return true;
                }
            }
        } else if(node.children[chr]) {
            return dfs(node.children[chr], word, i + 1);
        }
        
        return false;
    }
    
    return dfs(node, word, 0);
};

/**
 * Your WordDictionary object will be instantiated and called as such:
 * var wordDictionary = new WordDictionary();
 * wordDictionary.addWord("word");
 * wordDictionary.search("pattern");
 */
</pre>
<hr />
</div>

<div>
<h3>212 Word Search II.js</h3>
<a name="212-word-search-ii-js"></a>
<pre>
// Given a 2D board and a list of words from the dictionary, find all words in the board.

// Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

// For example,
// Given words = ["oath","pea","eat","rain"] and board =

// [
//   ['o','a','a','n'],
//   ['e','t','a','e'],
//   ['i','h','k','r'],
//   ['i','f','l','v']
// ]
// Return ["eat","oath"].
// Note:
// You may assume that all inputs are consist of lowercase letters a-z.

// click to show hint.

// Hide Company Tags Microsoft Google Airbnb
// Hide Tags Backtracking Trie
// Hide Similar Problems (M) Word Search



/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    var root = buildTrie(words);
    var result = [];
    
    for(var i = 0; i < board.length; i++) {
        for(var j = 0; j < board[0].length; j++) {
            searchWord(result, root, board, i, j);
        }
    }
    
    return result;
};

function searchWord(result, root, board, i, j) {
    if(root.word) {
        result.push(root.word);
        root.word = null;
    }
    
    if(i < 0 || i >= board.length || j < 0 || j >= board[0].length) {
        return;
    }
    
    if(board[i][j] === '#' || !root.children[board[i][j]]) {
        return;
    }
    
    var ch = board[i][j];
    board[i][j] = '#';
    
    searchWord(result, root.children[ch], board, i+1, j);
    searchWord(result, root.children[ch], board, i-1, j);
    searchWord(result, root.children[ch], board, i, j+1);
    searchWord(result, root.children[ch], board, i, j-1)
    
    board[i][j] = ch;
}


function buildTrie(words) {
    var root = new TrieNode();
    
    for(var i = 0; i < words.length; i++) {
        var word = words[i];
        var node = root;
        
        for(var j = 0; j < word.length; j++) {
            var ch = word[j];
            
            node.children[ch] = node.children[ch] || new TrieNode();
            node = node.children[ch];
        }
        
        node.word = word;
    }
    
    return root;
}

class TrieNode {
    constructor() {
        this.word = null;
        this.children = {};
    }
}
</pre>
<hr />
</div>

<div>
<h3>213 House Robber II.js</h3>
<a name="213-house-robber-ii-js"></a>
<pre>
// Note: This is an extension of House Robber.

// After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.

// Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
// Microsoft


/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    // same as house robber I, but we cannot rob first and last house at the same time.
    
    function robHouses(nums) {
        var odd = 0;
        var even = 0;
        
        for(var i = 0; i < nums.length; i++) {
            var num = nums[i];
            if(i % 2 === 0) {
                even = Math.max(even + num, odd);
            } else {
                odd = Math.max(odd + num, even);
            }
        }
        
        return Math.max(even, odd);
    }
    
    if(nums.length <= 1) {
        return robHouses(nums);
    }
    
    var robHousesExceptLast = robHouses(nums.slice(0, -1));
    var robHousesExceptFirst = robHouses(nums.slice(1));
    return Math.max(robHousesExceptLast, robHousesExceptFirst);
};
</pre>
<hr />
</div>

<div>
<h3>215 Kth Largest Element in an Array.js</h3>
<a name="215-kth-largest-element-in-an-array-js"></a>
<pre>
// Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

// For example,
// Given [3,2,1,5,6,4] and k = 2, return 5.

// Note: 
// You may assume k is always valid, 1 = k = array's length.

// Credits:
// Special thanks to @mithmatt for adding this problem and creating all test cases.

// Hide Company Tags Facebook Amazon Microsoft Apple Bloomberg Pocket Gems
// Hide Tags Heap Divide and Conquer
// Hide Similar Problems (M) Wiggle Sort II (M) Top K Frequent Elements



/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
 
//  use quick select
var findKthLargest = function(nums, k) {
    var smaller = [];
    var larger = [];
    var pivot = nums[parseInt(nums.length/2)];
    var pivotCnt = 0;
    
    for(var i = 0; i < nums.length; i++) {
        var num = nums[i];      
      
        if(num > pivot) {
            larger.push(num);
        } else if(num < pivot) {
            smaller.push(num);
        } else {
            pivotCnt++;
        }
    }
      
    if(k <= larger.length) { // if larger includes k
        return findKthLargest(larger, k);
    } else if(k - larger.length - pivotCnt <= 0) { // k is part of pivot
        return pivot;
    } else { // if smaller inclues k
        return findKthLargest(smaller, k - larger.length - pivotCnt);
    }
};
</pre>
<hr />
</div>

<div>
<h3>215 Kth Largest Element in an Array.py</h3>
<a name="215-kth-largest-element-in-an-array-py"></a>
<pre>
class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """

        pivot = random.choice(nums);
        nums1, nums2 = [], []
        for num in nums:
          if num > pivot:
            nums1.append(num)
          elif num < pivot:
            nums2.append(num)

        if k <= len(nums1):
          return self.findKthLargest(nums1, k)
        if k > len(nums) - len(nums2): # draw a graph to visualize it! It's not in the top k assortment, but in the small section
          return self.findKthLargest(nums2, k - (len(nums) - len(nums2)))

        return pivot
</pre>
<hr />
</div>

<div>
<h3>217 Contain Duplicate.js</h3>
<a name="217-contain-duplicate-js"></a>
<pre>
// Leetcode #217
// Language: Javascript
// Problem: https://leetcode.com/problems/contains-duplicate/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var containsDuplicate = function(nums) {
    if(nums === null){
        return false;
    }
    
    var map = {};
    
    for(var i = 0; i < nums.length; i++){
        var val = nums[i];
        if(map[val]){
            return true;
        } else {
            map[val] = true;
        }
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>219 Contains Duplicate II.js</h3>
<a name="219-contains-duplicate-ii-js"></a>
<pre>
// Leetcode #219
// Language: Javascript
// Problem: https://leetcode.com/problems/contains-duplicate-ii/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    if(k <= 0){
        return false;
    }
    
    if(nums === null || nums.length === 0){
        return false;
    }
    
    var hash = {};
    
    for(var i = 0; i < nums.length; i++){
        var val = nums[i];
        if(hash[val] !== undefined){
            if((i - hash[val]) <= k){
                return true;
            } else {
                hash[val] = i;
            }
        } else {
            hash[val] = i;
        }
        
        
    }

    return false;
};



</pre>
<hr />
</div>

<div>
<h3>22 Generate Parentheses.js</h3>
<a name="22-generate-parentheses-js"></a>
<pre>
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    var result = [];
    var output = '';
    
    generate(result, output, 0, n, 0, 0);
    return result;  
};

var generate = function(result, output, depth, n, left, right){
   if(depth === 2*n){
       result.push(output);
       return;
   }
   
   if(left < n){
       generate(result,output + '(',depth + 1, n, left + 1, right);
   }
   if(left > right){
       generate(result,output + ')',depth + 1, n, left, right+1);
   }
}
</pre>
<hr />
</div>

<div>
<h3>220 Contains Duplicate III.js</h3>
<a name="220-contains-duplicate-iii-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} t
 * @return {boolean}
 */

var search = function(pairs, t, k) {
    var p1 = 0;
    
    while(p1 < pairs.length) {
        var p2 = p1 + 1;
        
        while(p2 < pairs.length) {
            if(Math.abs(pairs[p1][0] - pairs[p2][0]) <= t && Math.abs(pairs[p1][1] - pairs[p2][1]) <= k) {
                return true;
            } else {
                if(Math.abs(pairs[p1][0] - pairs[p2][0]) > t) {
                    break;
                } else {
                    p2++;   
                }
            }
        }
        
        p1++;
    }
    
    return false;
}

var containsNearbyAlmostDuplicate = function(nums, k, t) {
    if(k <= 0) {
        return false;
    }
    
    if(nums === null || nums.length === 0) {
        return false;
    }
    
    var pairs = [];
    
    for(var i = 0; i < nums.length; i++){
        pairs.push([nums[i], i]);
    }

    pairs.sort(function(a,b){return a[0] > b[0] ? 1 : -1;});

    return search(pairs, t, k);
};
</pre>
<hr />
</div>

<div>
<h3>221 Maximal Square.js</h3>
<a name="221-maximal-square-js"></a>
<pre>
// Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

// For example, given the following matrix:

// 1 0 1 0 0
// 1 0 1 1 1
// 1 1 1 1 1
// 1 0 0 1 0
// Return 4.
// Credits:
// Special thanks to @Freezen for adding this problem and creating all test cases.

// Hide Company Tags Apple Airbnb Facebook
// Hide Tags Dynamic Programming
// Hide Similar Problems (H) Maximal Rectangle


/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
    var dp = [];
    var ans = 0;
    
    for(var i = 0; i < matrix.length; i++) {
        var arr = Array(matrix[i].length).fill(0);
        dp.push(arr);
    }
    
    for(var x = 0; x < matrix.length; x++) {
        for(var y = 0; y < matrix[x].length; y++) {
            dp[x][y] = parseInt(matrix[x][y]);
            
            // conditions to make sure that x !== 0 && y !== 0 && dp[x][y] !== 0
            // dp[x][y] is the current position
            // if the current position is not 1 then it cannot form square from previous values
            // and if matrix[x][y] is 0, then it will next dp[x+1][y+1] becomes zero plus one, since x+1 and y+1 will become the new start of the square.
            if(x && y && dp[x][y]) {
                dp[x][y] = Math.min(dp[x - 1][y - 1], dp[x - 1][y], dp[x][y - 1]) + 1;
            }
            
            ans = Math.max(ans, dp[x][y]);
        }
    }
    
    return Math.pow(ans, 2);
};

var matrix = ["1111","1111","1111"];
// dp becomes
// 1111
// 1222
// 1233

console.log(maximalSquare(matrix));
</pre>
<hr />
</div>

<div>
<h3>222. Count Complete Tree Nodes.js</h3>
<a name="222-count-complete-tree-nodes-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    return treeNodes(root);

    function treeNodes(node){
        if(!node){
            return 0;
        }else{
            var leftDepth = 0;
            var rightDepth = 0;
            var leftChild = node.left;
            while(leftChild){
                leftDepth++;
                leftChild = leftChild.left;
            }
            var rightChild = node.right;
            while(rightChild){
                rightDepth++;
                rightChild = rightChild.right;
            }
            if(leftDepth === rightDepth){
                return Math.pow(2, leftDepth + 1) - 1;
            }else{
                return treeNodes(node.left) + treeNodes(node.right) + 1;
            }
        }
    }
};
</pre>
<hr />
</div>

<div>
<h3>223 Rectangle Area.js</h3>
<a name="223-rectangle-area-js"></a>
<pre>
// Leetcode #223
// Language: Javascript
// Problem: https://leetcode.com/problems/rectangle-area/
// Author: Chihung Yu
/**
 * @param {number} A
 * @param {number} B
 * @param {number} C
 * @param {number} D
 * @param {number} E
 * @param {number} F
 * @param {number} G
 * @param {number} H
 * @return {number}
 */
var computeArea = function(A, B, C, D, E, F, G, H) {
    var area = (C-A)*(D-B) + (G-E)*(H-F);
    
    if((A > G || C < E) || (D < F || B > H)) {
        return area;
    }
    
    var left = Math.max(A,E);
    var top = Math.min(D,H);
    var right = Math.min(C,G);
    var bottom = Math.max(B,F);
    
    return area - (right - left)*(top - bottom);
};
</pre>
<hr />
</div>

<div>
<h3>224 Basic Calculator.js</h3>
<a name="224-basic-calculator-js"></a>
<pre>
// http://yucoding.blogspot.com/2015/10/leetcode-question-basic-calculator.html
// http://blog.welkinlan.com/2015/09/06/basic-calculator-i-ii-leetcode-java/

/**
Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .

You may assume that the given expression is always valid.

Some examples:
"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23
Note: Do not use the eval built-in library function.
*/
/**
 * @param {string} s
 * @return {number}
 */
// var calculate = function(s) {
//     var stack = [],
//         len = s.length,
//         sum = 0,
//         num,
//         ch,
//         j,
//         i;
    
//     stack.push(1);
//     stack.push(1);
    
//     for (i = 0; i < len; i++) {
//         ch = s.charAt(i);
        
//         if (!isNaN(parseInt(ch))) {
//             num = parseInt(ch);
            
//             for (j = i + 1; j < len && !isNaN(parseInt(s.charAt(j))); j++) {
//                 num = num * 10 + parseInt(s.charAt(j));
//             }
            
//             sum += stack.pop() * num;
            
//             i = j - 1;
//         } else if (ch === '+' || ch === '(') {
//             stack.push(stack[stack.length - 1]);
//         } else if (ch === '-') {
//             stack.push(stack[stack.length - 1] * (-1));
//         } else if (ch === ')') {
//             stack.pop();
//         }
//     }
    
//     return sum;
// };



/**
Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .

You may assume that the given expression is always valid.

Some examples:
"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23
Note: Do not use the eval built-in library function.
*/
/**
 * @param {string} s
 * @return {number}
 */



console.log(calculate("10+20-((2-4)*6-5)*6"));
var calculate = function(s) {





}

function helper(s, i, sign, finalSum, currentSum) {
    while(i < s.length) {
        if(s[i].match(/[0-9]/)) {
            var num = 0;

            while(i < s.length) {
                if(s[i].match(/[0-9]/)) {
                    num *= 10;
                    num += parseInt(s[i]);
                    i++                    
                } else {
                    break;
                }
            }
        } else if(s[i] === '-') {

        } else if(s[i] === '+') {
            return num + helper(s, i, sign, finalSum, currentSum);
        } else if(s[i] === '*') {

        } else if(s[i] === '/') {

        } else if(s[i] === '(') {

        } else if(s[i] === ')') {

        }

        i++;
    }
}
</pre>
<hr />
</div>

<div>
<h3>225 Implement Stack Using Queues.js</h3>
<a name="225-implement-stack-using-queues-js"></a>
<pre>
// Leetcode #225
// Language: Javascript
// Problem: https://leetcode.com/problems/implement-stack-using-queues/
// Author: Chihung Yu
/**
 * @constructor
 */
var Stack = function() {
    this.stack = [];  
};

/**
 * @param {number} x
 * @returns {void}
 */
Stack.prototype.push = function(x) {
    this.stack.push(x);
};

/**
 * @returns {void}
 */
Stack.prototype.pop = function() {
    this.stack.pop();  
};

/**
 * @returns {number}
 */
Stack.prototype.top = function() {
    return this.stack[this.stack.length - 1];
};

/**
 * @returns {boolean}
 */
Stack.prototype.empty = function() {
    return this.stack.length === 0;
};
</pre>
<hr />
</div>

<div>
<h3>226 Invert Binary Tree.js</h3>
<a name="226-invert-binary-tree-js"></a>
<pre>
// Invert a binary tree.

//      4
//    /   \
//   2     7
//  / \   / \
// 1   3 6   9
// to
//      4
//    /   \
//   7     2
//  / \   / \
// 9   6 3   1
// Trivia:
// This problem was inspired by this original tweet by Max Howell:
// Google: 90% of our engineers use the software you wrote (Homebrew), but you cant invert a binary tree on a whiteboard so fuck off.
// Hide Tags Tree



// Leetcode #226 
// Language: Javascript
// Problem: https://leetcode.com/problems/invert-binary-tree/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(root === null) {
        return root;
    }
    
    var tmp = root.left;
    root.left = root.right;
    root.right = tmp;
    
    invertTree(root.left);
    invertTree(root.right);
    
    return root;
};
</pre>
<hr />
</div>

<div>
<h3>228 Summary Ranges.js</h3>
<a name="228-summary-ranges-js"></a>
<pre>
// Leetcode #228 
// Language: Javascript
// Problem: https://leetcode.com/problems/summary-ranges/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var summaryRanges = function(nums) {

    var index = 0;
    var result = [];

    while(index < nums.length){
        var r = nums[index];
        var c = index;
        
        while(index + 1 < nums.length && nums[index + 1] - nums[index] == 1){
            index++;
        }
        
        if(index > c){
            r = nums[c] + '->' + nums[index];
        }
        
        result.push(r + "");
        index++;
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>229 Majority Element II.js</h3>
<a name="229-majority-element-ii-js"></a>
<pre>
// Leetcode #229
// Language: Javascript
// Problem: https://leetcode.com/problems/majority-element-ii/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var majorityElement = function(nums) {
    var n1 = null;
    var n2 = null;
    
    var c1 = 0;
    var c2 = 0;
    
    for(var i = 0; i < nums.length; i++){
        var n = nums[i];
        
        if(n === n1){
            c1++;
        } else if(n === n2){
            c2++;
        } else if(c1 === 0){
            c1 = 1;
            n1 = n;
        } else if(c2 === 0){
            c2 = 1;
            n2 = n;
        } else {
            c1--;
            c2--;
        }
    }
    
    c1 = 0;
    c2 = 0;
    
    for(i = 0; i < nums.length; i++){
        n = nums[i];
        
        if(n1 === n){
            c1++;
        }
        if(n2 === n){
            c2++;
        }
    }
    
    var results = [];
    var c3 = Math.floor(nums.length/3);
    
    if(c1 > c3){
        results.push(n1);
    }
    if(c2 > c3){
        results.push(n2);
    }
    
    return results;
};
</pre>
<hr />
</div>

<div>
<h3>23 Merge k Sorted Lists.js</h3>
<a name="23-merge-k-sorted-lists-js"></a>
<pre>
// Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
// http://www.cnblogs.com/springfor/p/3869217.html

// Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

// Hide Company Tags LinkedIn Google Uber Airbnb Facebook Twitter Amazon Microsoft
// Hide Tags Divide and Conquer Linked List Heap
// Hide Similar Problems (E) Merge Two Sorted Lists (M) Ugly Number II

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    
    function merge(beg, end, lists) {
        if(beg > end) {
            return [];
        }
        
        if(beg === end) {
            return lists[beg];
        }
        
        var mid = beg + Math.floor((end - beg)/2);
        var left = merge(beg, mid, lists);
        var right = merge(mid + 1, end, lists);
        
        return mergeTwoLists(left, right);
    }
    
    function mergeTwoLists(list1, list2) {
        var head = new ListNode(0);
        var tmp = head;
        
        while(list1 && list2) {
            if(list1.val < list2.val) {
                tmp.next = list1;
                list1 = list1.next;
            } else {
                tmp.next = list2;
                list2 = list2.next;
            }
            
            tmp = tmp.next;
        }
        
        if(list1) {
            tmp.next = list1;
        } else if(list2) {
            tmp.next = list2;
        }
        
        tmp = head.next;
        head.next = null;
        
        return tmp;
    }
    
    return merge(0, lists.length - 1, lists);
};
</pre>
<hr />
</div>

<div>
<h3>231 Power of Two.js</h3>
<a name="231-power-of-two-js"></a>
<pre>
// Leetcode #231 
// Language: Javascript
// Problem: https://leetcode.com/problems/power-of-two/
// Author: Chihung Yu
// Given an integer, write a function to determine if it is a power of two.

// Credits:
// Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

// Hide Company Tags Google
// Hide Tags Math Bit Manipulation
// Hide Similar Problems (E) Number of 1 Bits (E) Power of Three (E) Power of Four


/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    return n <= 0 ? false : (n & (n-1)) === 0;
};
</pre>
<hr />
</div>

<div>
<h3>232 Implement Queue using Stacks.js</h3>
<a name="232-implement-queue-using-stacks-js"></a>
<pre>
// Leetcode #232
// Language: Javascript
// Problem: https://leetcode.com/problems/implement-queue-using-stacks/
// Author: Chihung Yu
/**
 * @constructor
 */
var Queue = function() {
    this.stack = [];
};

/**
 * @param {number} x
 * @returns {void}
 */
Queue.prototype.push = function(x) {
    this.stack.push(x);
};

/**
 * @returns {void}
 */
Queue.prototype.pop = function() {
     this.stack.shift();
};

/**
 * @returns {number}
 */
Queue.prototype.peek = function() {
    return this.stack[0];
};

/**
 * @returns {boolean}
 */
Queue.prototype.empty = function() {
    return this.stack.length === 0;
};
</pre>
<hr />
</div>

<div>
<h3>233 Number of Digit One.js</h3>
<a name="233-number-of-digit-one-js"></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>234 Palindrome Linked List.js</h3>
<a name="234-palindrome-linked-list-js"></a>
<pre>
// Leetcode #234
// Language: Javascript
// Problem: https://leetcode.com/problems/palindrome-linked-list/
// Author: Chihung Yu
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function(head) {
    if(head === null || head.next === null){
        return true;
    }
    
    var slow = head;
    var fast = head;
    
    while(fast.next && fast.next.next){
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // if fast.next === null it's odd
    // else fast.next !== null it's even
    // but wether it's odd or even, we want to reverse slow's next
    // 1 2 3 3 2 1 
    // slow is pointing at 3 (index 2) and we want to reverse 3 2 1
    // to 1 2 3 1 2 3
    // 
    // 1 2 3 4 3 2 1
    // slow is pointing at 4 (index 3) and we want to reverse 3 2 1
    // to 1 2 3 4 1 2 3

    var secondHead = slow.next;
    slow.next = null;
    
    var p1 = secondHead;
    var p2 = secondHead.next;
    
    while(p1 && p2){
        var temp = p2.next;
        p2.next = p1;
        p1 = p2;
        p2 = temp;
    }
    
    secondHead.next = null; // !important
    
    p = p1;
    q = head;
    
    while(p && q){
        if(p.val !== q.val){
            return false;
        }
        
        p = p.next;
        q = q.next;
    }
    
    return true;
}
</pre>
<hr />
</div>

<div>
<h3>235 Lowest Common Ancestor Of a Binary Search Tree.js</h3>
<a name="235-lowest-common-ancestor-of-a-binary-search-tree-js"></a>
<pre>
// Leetcode #235
// Language: Javascript
// Problem: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
// Author: Chihung Yu
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(root === null) {
        return root;
    }
    
    if(root === p || root === q) {
        return root;
    }
    
    if((root.val >= p.val && root.val <= q.val) || (root.val <= p.val && root.val >= q.val)){
        return root;
    }
    
    if(root.val > p.val && root.val > q.val){
        return lowestCommonAncestor(root.left, p, q);
    } else {
        return lowestCommonAncestor(root.right, p, q);
    }
};
</pre>
<hr />
</div>

<div>
<h3>236 Lowest Common Ancestor of a Binary Tree.js</h3>
<a name="236-lowest-common-ancestor-of-a-binary-tree-js"></a>
<pre>
// Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

// According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).

//         _______3______
//        /              \
//     ___5__          ___1__
//    /      \        /      \
//    6      _2       0       8
//          /  \
//          7   4
// For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

// Hide Company Tags Amazon LinkedIn Apple Facebook Microsoft
// Show Tags
// Show Similar Problems



/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}

 */

// Amazon LinkedIn Apple Facebook Microsoft
// Hide Tags Tree
// Hide Similar Problems
 
// reference: http://www.cnblogs.com/anne-vista/p/4815076.html
var lowestCommonAncestor = function(root, p, q) {
    if(root === null || root === p || root === q) {
        return root;
    }
    
    var l = lowestCommonAncestor(root.left, p, q);
    var r = lowestCommonAncestor(root.right, p, q);
    
    if(l !== null && r !== null) {
        // p and q are on two different side of root node.
        return root;
    }
    
    return (l !== null) ? l : r; // either one of p, q is on one side OR p, q is not in l&r subtrees
};


// second attempt

var lowestCommonAncestor = function(root, p, q) {
    if(root === null || root === p || root === q) {
        return root;
    }
    
    var left = lowestCommonAncestor(root.left, p, q);
    var right = lowestCommonAncestor(root.right, p, q);
    
    if(left !== null && right !== null) {
        return root;
    }
    
    return left || right;
};
</pre>
<hr />
</div>

<div>
<h3>237 Delete Node in a Linked List.js</h3>
<a name="237-delete-node-in-a-linked-list-js"></a>
<pre>
// Leetcode #237 
// Language: Javascript
// Problem: https://leetcode.com/problems/delete-node-in-a-linked-list/
// Author: Chihung Yu
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    if(node.next === null){
        return;
    }
    
    node.val = node.next.val;
    node.next = node.next.next;
};
</pre>
<hr />
</div>

<div>
<h3>238 Product of Array Except Self.js</h3>
<a name="238-product-of-array-except-self-js"></a>
<pre>
// Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

// Solve it without division and in O(n).

// For example, given [1,2,3,4], return [24,12,8,6].

// Follow up:
// Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)

/**
 * @param {number[]} nums
 * @return {number[]}
 */
 
// http://fisherlei.blogspot.com/2015/10/leetcode-product-of-array-except-self.html
var productExceptSelf = function(nums) {
    var len = nums.length;
    var output = Array(len).fill(1);
    var left = 1;
    var right = 1;
    
    for(var i = 0; i < len - 1; i++) {
        left *= nums[i];
        right *= nums[len - i - 1];
        output[i + 1] *= left;
        output[len - i - 2] *= right;
    }
    
    return output;
};
</pre>
<hr />
</div>

<div>
<h3>239 Sliding Window Maximum.js</h3>
<a name="239-sliding-window-maximum-js"></a>
<pre>
// Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

// For example,
// Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

// Window position                Max
// ---------------               -----
// [1  3  -1] -3  5  3  6  7       3
//  1 [3  -1  -3] 5  3  6  7       3
//  1  3 [-1  -3  5] 3  6  7       5
//  1  3  -1 [-3  5  3] 6  7       5
//  1  3  -1  -3 [5  3  6] 7       6
//  1  3  -1  -3  5 [3  6  7]      7
// Therefore, return the max sliding window as [3,3,5,5,6,7].

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    var result = [],
        linkedListWithTwoEndsOps = [],
        len = nums.length,
        i;
    
    if (k > len || k === 0) {
        return result;
    }
    
    for (i = 0; i < len; i++) {
        // Remove anything that is less than the current value
        // so linkedListWithTwoEndsOps maintains values greater than the curret value
        while (linkedListWithTwoEndsOps.length > 0 && nums[linkedListWithTwoEndsOps[linkedListWithTwoEndsOps.length - 1]] < nums[i]) {
            var val = linkedListWithTwoEndsOps.pop();
        }
        
        // In case that all elements in the linkedListWithTwoEndsOps are all greater than the current one (descending order)
        // Shift out the 
        if (linkedListWithTwoEndsOps[0] < i - k + 1) {
            linkedListWithTwoEndsOps.shift();
        }
        
        linkedListWithTwoEndsOps.push(i);
        
        // For each sliding window movement, we record the highest value in that sliding window
        // i >= k - 1 to ensure that we don't prematurely record values before we get to the full range of the first sliding window
        // e.g. [1  3  -1] -3  5  3  6  7       3
        // this ensure that i is at least at -1 (index 2)
        if (i >= k - 1) {
            result.push(nums[linkedListWithTwoEndsOps[0]]);
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>24 Swap nodes in Pairs.js</h3>
<a name="24-swap-nodes-in-pairs-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    var dummy = new ListNode(0);
    dummy.next = head;
    var n1 = dummy;
    var n2 = head;
    
    while(n2 !== null && n2.next !== null){
        var nextStart = n2.next.next;
        
        n1.next = n2.next;
        n1.next.next = n2;
        n2.next = nextStart;
        
        n1 = n2;
        n2 = n2.next;
    }
    
    return dummy.next;
};
</pre>
<hr />
</div>

<div>
<h3>240 Search a 2D Matrix II.js</h3>
<a name="240-search-a-2d-matrix-ii-js"></a>
<pre>
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function(matrix, target) {
    var row = matrix.length;
    
    if(row === 0) {
        return false;
    }
    
    var col = matrix[0].length;
    
    if(col === 0) {
        return false;
    }
    
    var j = col - 1;
    for(var i = 0; i < row; i++) {
        while(j && matrix[i][j] > target) {
            j--;
        }
        if(matrix[i][j] === target) {
            return true;
        }
    }
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>241 Different Ways to Add Parentheses.js</h3>
<a name="241-different-ways-to-add-parentheses-js"></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>242 Valid Anagram.js</h3>
<a name="242-valid-anagram-js"></a>
<pre>
// Given two strings s and t, write a function to determine if t is an anagram of s.

// For example,
// s = "anagram", t = "nagaram", return true.
// s = "rat", t = "car", return false.



/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
   var slen = s.length;
   var tlen = t.length;
   
   if(slen !== tlen) {
       return false;
   }
   
   var hash = {};
   
   for(var i = 0; i < slen; i++) {
       var char = s[i];
       hash[char] = hash[char] || 0;
       hash[char]++;
   }
   
   for(i = 0; i < tlen; i++) {
       char = t[i];
       
       if(hash[char] === undefined || hash[char] === 0) {
           return false;
       }
       
       hash[char]--;
   }
   
   return true;
};
</pre>
<hr />
</div>

<div>
<h3>243 Shortest Word Distance.js</h3>
<a name="243-shortest-word-distance-js"></a>
<pre>
// Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.

// For example,
// Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

// Given word1 = coding, word2 = practice, return 3.
// Given word1 = "makes", word2 = "coding", return 1.

// Note:
// You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.

// Hide Company Tags LinkedIn
// Hide Tags


var shortestDistance = function(words, word1, word2) {
    var idx1 = -1;
    var idx2 = -1;
    var dist = words.length - 1;
    
    for(var i = 0; i < words.length; i++) {
        if(words[i] === word1) {
            idx1 = i;
        } else if(words[i] === word2) {
            idx2 = i;
        }
      
        if(idx1 !== -1 && idx2 !== -1) {
          dist = Math.min(dist, Math.abs(idx1 - idx2))
        }
    }
    
    return dist;
};
</pre>
<hr />
</div>

<div>
<h3>244 Shortest Word Distance II.js</h3>
<a name="244-shortest-word-distance-ii-js"></a>
<pre>
// This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?

// Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.

// For example,
// Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

// Given word1 = coding, word2 = practice, return 3.
// Given word1 = "makes", word2 = "coding", return 1.

// Note:
// You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.

// Hide Company Tags LinkedIn
// Hide Tags Hash Table Design
// Show Similar Problems


/**
 * @constructor
 * @param {string[]} words
 */
var WordDistance = function(words) {
    this.positions = {};
    
    for(var i = 0; i < words.length; i++) {
        var word = words[i];
        
        this.positions[word] = this.positions[word] || [];
        this.positions[word].push(i);
    }
};

/**
 * @param {string} word1
 * @param {string} word2
 * @return {integer}
 */
WordDistance.prototype.shortest = function(word1, word2) {
    var i = 0;
    var j = 0;
    var dist = Infinity;
    var pos1 = this.positions[word1];
    var pos2 = this.positions[word2];
    
    while(i < pos1.length && j < pos2.length) {
        var i1 = pos1[i];
        var i2 = pos2[j];
        
        dist = Math.min(dist, Math.abs(i1 - i2));
        
        if(i1 < i2) {
            i++;
        } else {
            j++;
        }
    }
    
    return dist;
};

/**
 * Your WordDistance object will be instantiated and called as such:
 * var wordDistance = new WordDistance(words);
 * wordDistance.shortest("word1", "word2");
 * wordDistance.shortest("anotherWord1", "anotherWord2");
 */
</pre>
<hr />
</div>

<div>
<h3>245 Shortest Word Distance III.js</h3>
<a name="245-shortest-word-distance-iii-js"></a>
<pre>
// This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.

// Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.

// word1 and word2 may be the same and they represent two individual words in the list.

// For example,
// Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

// Given word1 = makes, word2 = coding, return 1.
// Given word1 = "makes", word2 = "makes", return 3.

// Note:
// You may assume word1 and word2 are both in the list.

// Hide Company Tags LinkedIn
// Hide Tags Array
// Hide Similar Problems


/**
 * @param {string[]} words
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var shortestWordDistance = function(words, word1, word2) {
    var idx1 = -1;
    var idx2 = -1;
    var dist = words.length - 1;
    
    for(var i = 0; i < words.length; i++) {
        if(words[i] === word1) {
            if(words[idx1] === word1 && word1 === word2) {
                idx2 = idx1;
            }
            
            idx1 = i;
        } else if(words[i] === word2) {
            idx2 = i;
        }
      
        if(idx1 !== -1 && idx2 !== -1) {
          dist = Math.min(dist, Math.abs(idx1 - idx2))
        }
    }
    
    return dist;
};
</pre>
<hr />
</div>

<div>
<h3>249 Group Shifted Strings.js</h3>
<a name="249-group-shifted-strings-js"></a>
<pre>
// Given a string, we can "shift" each of its letter to its successive letter, for example: "abc" -> "bcd". We can keep "shifting" which forms the sequence:

// "abc" -> "bcd" -> ... -> "xyz"
// Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.

// For example, given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], 
// A solution is:

// [
//   ["abc","bcd","xyz"],
//   ["az","ba"],
//   ["acef"],
//   ["a","z"]
// ]
// reference: http://blog.csdn.net/pointbreak1/article/details/48780345

/**
 * @param {string[]} strings
 * @return {string[][]}
 */
var groupStrings = function(strings) {
    var result = [];
    var map = new Map();
    
    for(var i = 0; i < strings.length; i++) {
        var shift = '';
        var string = strings[i]
        for(var j = 0; j < string.length; j++) {
            shift += (string.charCodeAt(j) - string.charCodeAt(0) + 26)%26;
            shift += ' ';
        }
        if(map.has(shift)) {
            map.get(shift).push(string);
        } else {
            map.set(shift, [string]);
        }
    }

    map.forEach((value, key)=> {
        result.push(value);
    });
    
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>25 Reverse Nodes in k-Group.js</h3>
<a name="25-reverse-nodes-in-k-group-js"></a>
<pre>

// Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

// If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

// You may not alter the values in the nodes, only nodes itself may be changed.

// Only constant memory is allowed.

// For example,
// Given this linked list: 1->2->3->4->5

// For k = 2, you should return: 2->1->4->3->5

// For k = 3, you should return: 3->2->1->4->5


/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */

 // http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/
var reverseKGroup = function(head, k) {
    var cur = head;
    var pre = null;
    var post = null;
    var count = 0;
    
    while(cur !== null && count < k) {
        cur = cur.next;
        count++;   
    }
    
    if(count !== k) {
        return head;
    }
    
    cur = head;

    while(cur !== null && count > 0) {
        post = cur.next;
        cur.next = pre;
        pre = cur;
        cur = post;
        count--;
    }
    
    // post is now a pointer to (k+1)th node
    // recursively call for the list starting from cur
    if(post !== null) {
        head.next = reverseKGroup(post, k);
    }
    
    return pre;
};
</pre>
<hr />
</div>

<div>
<h3>252 Meeting Rooms.js</h3>
<a name="252-meeting-rooms-js"></a>
<pre>
// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.

// For example,
// Given [[0, 30],[5, 10],[15, 20]],
// return false.

// Hide Company Tags Facebook
// Hide Tags Sort
// Hide Similar Problems (H) Merge Intervals (M) Meeting Rooms II


/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {boolean}
 */

// 132 ms
var canAttendMeetings = function(intervals) {
    // sort by starting time
    intervals.sort((interval1, interval2)=> interval1.start > interval2.start ? 1 : -1);
    
    for(var i = 1; i < intervals.length; i++) {
        var pre = intervals[i-1];
        var cur = intervals[i];
        
        if(pre.end > cur.start) {
            return false;
        }
    }
    
    return true;
};




// second attempt

var canAttendMeetings = function(intervals) {
    intervals.sort((a,b) => {
        return a.start > b.start ? 1 : -1;
    });
    
    for(var i = 1; i < intervals.length; i++) {
        if(intervals[i - 1].end > intervals[i].start) {
            return false;
        }
    }
    
    return true;
};
</pre>
<hr />
</div>

<div>
<h3>253 Meeting Rooms II.js</h3>
<a name="253-meeting-rooms-ii-js"></a>
<pre>
// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei),
// find the minimum number of conference rooms required.

// For example,
// Given [[0, 30],[5, 10],[15, 20]],
// return 2.

// Hide Company Tags Google Facebook
// Hide Tags Heap Greedy Sort
// Hide Similar Problems (H) Merge Intervals (E) Meeting Rooms


/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @return {number}
 */

var minMeetingRooms = function(intervals) {
    var schedule = {};
    
    intervals.forEach((interval)=>{
        schedule[interval.start] = schedule[interval.start] || 0;
        schedule[interval.start]++;
        
        schedule[interval.end] = schedule[interval.end] || 0;
        schedule[interval.end]--;
    });
    
    var maxRooms = 0;
    var rooms = 0;
    
    for(var i in schedule) {
        rooms += schedule[i];
        maxRooms = Math.max(maxRooms, rooms);
    }
    
    return maxRooms;
};

var data = [
  {start: 9, end: 12},
  {start: 2, end: 7},
  {start: 5, end: 17},
  {start: 12, end: 17},
]

console.log(minMeetingRooms(data));
</pre>
<hr />
</div>

<div>
<h3>254 Factor Combinations.js</h3>
<a name="254-factor-combinations-js"></a>
<pre>
// Numbers can be regarded as product of its factors. For example,

// 8 = 2 x 2 x 2;
//   = 2 x 4.
// Write a function that takes an integer n and return all possible combinations of its factors.

// Note: 
// You may assume that n is always positive.
// Factors should be greater than 1 and less than n.
// Examples: 
// input: 1
// output: 
// []
// input: 37
// output: 
// []
// input: 12
// output:
// [
//   [2, 6],
//   [2, 2, 3],
//   [3, 4]
// ]
// input: 32
// output:
// [
//   [2, 16],
//   [2, 2, 8],
//   [2, 2, 2, 4],
//   [2, 2, 2, 2, 2],
//   [2, 4, 4],
//   [4, 8]
// ]
// Hide Company Tags LinkedIn Uber
// Hide Tags Backtracking
// Show Similar Problems


/**
 * @param {number} n
 * @return {number[][]}
 */
 
// reference: http://www.cnblogs.com/airwindow/p/4822572.html
var getFactors = function(n) {
    var result = [];
    gatherResult(n, 2, [], result);
    return result;
};

function gatherResult(n, start, currentResult, finalResult) {
    if(n === 1) {
        if(currentResult.length > 1) {
            finalResult.push(currentResult.slice());
        }
        
        return;
    }
    // i = start will ensure ascending order
    for(var i = start; i <= n; i++) {
        if(n%i === 0) {
            currentResult.push(i);
            gatherResult(n/i, i, currentResult, finalResult);
            currentResult.pop();    
        }
    }
}
    
</pre>
<hr />
</div>

<div>
<h3>256 Paint House.js</h3>
<a name="256-paint-house-js"></a>
<pre>
// There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

// The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.

// Note:
// All costs are positive integers.

// Hide Company Tags LinkedIn
// Show Tags
// Show Similar Problems

// reference: https://segmentfault.com/a/1190000003903965
/**
 * @param {number[][]} costs
 * @return {number}
 */

 // space O(1) time O(n)
var minCost = function(costs) {
    if(!costs || costs.length === 0)   {
        return 0;
    }
    
    for(var i = 1; i < costs.length; i++) {
        // The colors that can be painted depends on the color we used for the previous houses,
        // pick the min cost from previous colors
        costs[i][0] += Math.min(costs[i-1][1], costs[i-1][2]);
        costs[i][1] += Math.min(costs[i-1][0], costs[i-1][2]);
        costs[i][2] += Math.min(costs[i-1][0], costs[i-1][1]);
    }
    
    i--;
    return Math.min.apply(null, costs[i]);
};
</pre>
<hr />
</div>

<div>
<h3>257 Binary Tree Paths.js</h3>
<a name="257-binary-tree-paths-js"></a>
<pre>
// Given a binary tree, return all root-to-leaf paths.

// For example, given the following binary tree:

//    1
//  /   \
// 2     3
//  \
//   5
// All root-to-leaf paths are:

// ["1->2->5", "1->3"]
// Credits:
// Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

// Hide Company Tags Google Apple Facebook
// Hide Tags Tree Depth-first Search
// Hide Similar Problems (M) Path Sum II

 /**
  * Definition for a binary tree node.
  * function TreeNode(val) {
  *     this.val = val;
  *     this.left = this.right = null;
  * }
  */
 /**
  * @param {TreeNode} root
  * @return {string[]}
  */

 var binaryTreePaths = function(root) {
     var res = [];
     
     function dfs(node, curr, res) {
         if(node === null) {
             return;
         }
         
         curr.push(node.val);
         
         if(node.left === null && node.right === null) {
             res.push(curr.join('->'));
         } else {
             dfs(node.left, curr, res);
             dfs(node.right, curr, res);
         }
         
         curr.pop();
     }
     
     dfs(root, [], res);
     
     return res;
 };
</pre>
<hr />
</div>

<div>
<h3>26 Remove Duplicates from Sorted Array.js</h3>
<a name="26-remove-duplicates-from-sorted-array-js"></a>
<pre>
// Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

// Do not allocate extra space for another array, you must do this in place with constant memory.

// For example,
// Given input array nums = [1,1,2],

// Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.


/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    if(!nums || nums.length === 0) {
        return 0;
    }
  
    var end = 0;
    
    // index: 012345678
    // vals:  111222333
    // first swap happen when end = 0; i points at index 3 with val 2
    // end++ becomes end points at index 1 and swap with index 3
    // after that vals become:
    // vals:  121122333
    // i at at index 4 and end is at index 2
    
    for(var i = 1; i < nums.length; i++) {
        if(nums[i] !== nums[end]) {
            end++;
            
            if(i !== end) {
                nums[end] = nums[i];
            }
        }
    }
    
    return end+1;
};



// second attempt

var removeDuplicates = function(nums) {
    var sorted = 0;
    
    for(var i = 1; i < nums.length; i++) {
        if(nums[i] !== nums[sorted]) {
            sorted++;
            nums[sorted] = nums[i];
        }
    }
    
    return sorted + 1;
};


// [tricky]
</pre>
<hr />
</div>

<div>
<h3>260. Single Number III.js</h3>
<a name="260-single-number-iii-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function(nums) {
    if(nums === null || nums.length <= 2) {
        return nums;
    }

    var xor = nums[0];
    for(var i = 1; i < nums.length; i++) {
        xor ^= nums[i];
    }

    var exp = 1;
    while(!(exp & xor)) {

        exp = exp * 2;
    }
    console.log(exp);
    var xorBit0 = 0;
    var xorBit1 = 0;

    for(var j = 0; j < nums.length; j++) {
        if(exp & nums[j]){
            xorBit1 ^= nums[j];
            console.log("with 1:  " + nums[j]);
        } else {
            console.log("with 0:  " + nums[j]);
            xorBit0 ^= nums[j];
        }
    }

    return [xorBit0, xorBit1];
};

</pre>
<hr />
</div>

<div>
<h3>261 Graph Valid Tree.js</h3>
<a name="261-graph-valid-tree-js"></a>
<pre>
// Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

// For example:

// Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.

// Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.

// Show Hint 
// Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

// Hide Company Tags Google Facebook Zenefits
// Hide Tags Depth-first Search Breadth-first Search Graph Union Find
// Hide Similar Problems (M) Course Schedule (M) Number of Connected Components in an Undirected Graph


/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */


// reference: https://segmentfault.com/a/1190000003791051

var validTree = function(n, edges) {
    var unionFind = new UnionFind(n);
    
    for(var i = 0; i < edges.length; i++) {
        if(!unionFind.union(edges[i][0], edges[i][1])) {
            return false;
        }
    }
    
    return unionFind.count() === 1;
};

// reference: http://blog.csdn.net/dm_vincent/article/details/7655764
class UnionFind {
    constructor(size) {
        this.ids = [];
        
        for(var i = 0; i < size; i++) {
            this.ids[i] = i;
        }
        
        this.count = size;
    }
    
    union(m, n) {
        var src = this.find(m);
        var dest = this.find(n);
        
        if(src === dest) {
            return false;
        }
        
        for(var i = 0; i < this.ids.length; i++) {
            if(this.ids[i] === src) {
                this.ids[i] = dest;
            }
        }
        
        // once union, count-- -> count === 1 means it's a tree with no circle
        this.count--;
        
        return true;
    }
    
    find(m) {
        return this.ids[m];
    }
    
    areConnected(m, n) {
        return this.find(m) === this.find(n);
    }
    
    count() {
        return this.count;
    }
}






// second attempt

var validTree = function(n, edges) {
    var unions = [];
    for(var i = 0; i < n; i++) {
        unions.push(i);
    }
    
    for(i = 0; i < edges.length; i++) {
        var edge = edges[i];
        if(isConnected(unions, edge[1], edge[0])) {
            return false; 
        }
    }
    
    var visited = {};
    var diff = 0;
    
    for(i = 0; i < unions.length; i++) {
        var union = unions[i];
        if(visited[union]) {
            continue;
        }
        
        visited[union] = true;
        diff++;
    }
    
    return diff === 1;
};

function isConnected(unions, i, j) {
    var group1 = unions[i];
    var group2 = unions[j];

    if(group1 === group2) {
        return true
    }
    
    for(var k = 0; k < unions.length; k++) {
        if(unions[k] === group2) {
            unions[k] = group1;
        }
    }

    return false;
}

</pre>
<hr />
</div>

<div>
<h3>263 Ugly Number.js</h3>
<a name="263-ugly-number-js"></a>
<pre>
// 263. Ugly Number

// Write a program to check whether a given number is an ugly number.

// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.

// Note that 1 is typically treated as an ugly number.

/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
    while(num >= 2) {
        if(num%2 === 0) {
            num /= 2;
        } else if(num%3 === 0) {
            num /= 3;
        } else if(num%5 === 0) {
            num /= 5;
        } else {
            return false;
        }
    }
    
    return num === 1;
};
</pre>
<hr />
</div>

<div>
<h3>264 Ugly Number II.js</h3>
<a name="264-ugly-number-ii-js"></a>
<pre>
// 264. Ugly Number II

// Write a program to find the n-th ugly number.

// Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

// Note that 1 is typically treated as an ugly number.

/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
    var uglys = [1];
    var p2 = 0;
    var p3 = 0;
    var p5 = 0;
    
    while(uglys.length < n) {
        var ugly2 = uglys[p2]*2;
        var ugly3 = uglys[p3]*3;
        var ugly5 = uglys[p5]*5;
        
        var minV = Math.min(ugly2, ugly3, ugly5);
        
        if(minV === ugly2) {
            p2++;
        }
        if(minV === ugly3) {
            p3++;
        }
        if(minV === ugly5) {
            p5++;
        }
        if(minV !== uglys[uglys.length - 1]) {
            uglys.push(minV);
        }
    }
    
    return uglys[n-1];
};
</pre>
<hr />
</div>

<div>
<h3>265 Paint House II.js</h3>
<a name="265-paint-house-ii-js"></a>
<pre>
// There are a row of n houses, each house can be painted with one of the k colors.
// The cost of painting each house with a certain color is different.
// You have to paint all the houses such that no two adjacent houses have the same color.

// The cost of painting each house with a certain color is represented by a n x k cost matrix.
// For example, costs[0][0] is the cost of painting house 0 with color 0;
// costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.

// Note:
// All costs are positive integers.

// Follow up:
// Could you solve it in O(nk) runtime?

// Hide Company Tags Facebook
// Show Tags
// Show Similar Problems

/**
 * @param {number[][]} costs
 * @return {number}
 */
 
//  reference https://segmentfault.com/a/1190000003903965
var minCostII = function(costs) {
    if(costs === null || costs.length === 0) {
        return 0;
    }
    
    var min1Idx = -1;
    var min1 = 0;
    var min2 = 0;
    
    for(var i = 0; i < costs.length; i++) {
        // min1 and min2 for recording the smallest and the second smallest
        // The min cost of using the current paint k:
        //  is equal to: the min cost of previous paint j (k !== j)
        // In order to find the min cost which k !== j, we can use 2 variable min1 and min2 
        
        var oldMin1Idx = min1Idx;
        var oldMin1 = min1;
        var oldMin2 = min2;
        
        min1Idx = -1;
        min1 = Infinity;
        min2 = Infinity;
        
        for(var j = 0; j < costs[i].length; j++) {
            if(j === oldMin1Idx) {
                costs[i][j] += oldMin2;
            } else {
                costs[i][j] += oldMin1;
            }
            
            if(costs[i][j] < min1) {
                min2 = min1;
                min1 = costs[i][j];
                min1Idx = j;
            } else if(costs[i][j] < min2) {
                min2 = costs[i][j];
            }
        }
    }

    return min1;
};
</pre>
<hr />
</div>

<div>
<h3>266 Palindrome Permutation.js</h3>
<a name="266-palindrome-permutation-js"></a>
<pre>
// Given a string, determine if a permutation of the string could form a palindrome.

// For example,
// "code" -> False, "aab" -> True, "carerac" -> True.


/**
 * @param {string} s
 * @return {boolean}
 */
var canPermutePalindrome = function(s) {
    var countMap = {};
    
    for(var i = 0; i < s.length; i++) {
        var c = s[i];
        
        countMap[c] = countMap[c] || 0;
        countMap[c]++;
    }
    var oddCount = 0;
    
    for(i in countMap) {
        if(countMap[i]%2 === 1) {
            oddCount++;
        }
    }
    
    return oddCount < 2;
};

// Solution (2) that assume it's ascii 256 chars only

var canPermutePalindrome = function(s) {
    // assume that s is only contact 256 english letters
    var letters = Array(256).fill(0);
    var odd = 0;
    for(var i = 0; i < s.length; i++) {
        var letterIndex = s[i].charCodeAt(0);
        odd += (++letters[letterIndex] & 1) === 1 ? 1 : -1;
    }
    return odd < 2;
};
</pre>
<hr />
</div>

<div>
<h3>268 Missing Number.js</h3>
<a name="268-missing-number-js"></a>
<pre>
// Leetcode 268
// Language: Javascript
// Problem: https://leetcode.com/problems/missing-number/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number}
 */

 var missingNumber = function(nums) {
    var res = 0;
    
    // nums = [0, 1, 3, 4, 5]
    // index go from 1 to 5
    // res starts with 0
    // perform xor so that index and num will cancel out leaving the odd num alone
    for(var i = 1; i <= nums.length; i++) {
        res = res ^ i ^ nums[i - 1];
    }
 
    return res;
};
</pre>
<hr />
</div>

<div>
<h3>269 Alien Dictionary.js</h3>
<a name="269-alien-dictionary-js"></a>
<pre>
// There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

// For example,
// Given the following words in dictionary,

// [
//   "wrt",
//   "wrf",
//   "er",
//   "ett",
//   "rftt"
// ]
// The correct order is: "wertf".

// Note:
// You may assume all letters are in lowercase.
// If the order is invalid, return an empty string.
// There may be multiple valid order of letters, return any one of them is fine.
// Hide Company Tags Google Airbnb Facebook Twitter Snapchat Pocket Gems
// Hide Tags Graph Topological Sort
// Hide Similar Problems (M) Course Schedule II

/**
 * @param {string[]} words
 * @return {string}
 */
var alienOrder = function(words) {
    if (words.length === 0) {
        return '';
    }
    
    const len = words.length;
    let requiredCharMap = {}; // value is the prerequisite of key
    let charPreReqCount = {};
    let i;
    let queue = [];
    let result = [];
    let hasCycle = false;
    
    for (i = 0; i < len; i++) {
        // wert and woo
        // requiredCharMap : { w: [], e: [ 'o' ], r: [], t: [], o: [] } 
        // charPreReqCount : { w: 0, e: 0, r: 0, t: 0, o: 1 } 
        const chars = words[i].split('');
        
        let j = 0;
        
        for (j = 0; j < chars.length; j++) {
            if (!requiredCharMap[chars[j]]) {
                requiredCharMap[chars[j]] = [];
                charPreReqCount[chars[j]] = 0;
            }
        }
      
        // skip the first one || the same word
        if (i === 0 || words[i] === words[i - 1]) {
            continue;
        }
        
        const cur = words[i];
        const prev = words[i - 1];
        j = 0;
        
      
        // skip same words such as wert and woo will skip w and compare only ert vs oo
        while(j < cur.length && j < prev.length && cur.charAt(j) === prev.charAt(j)) {
            j++;
        }
      
      
        // since words are in lexico order. wert and woo after skipping w, they becomes ert and oo, e will have higher order than oo
        if (j < prev.length && requiredCharMap[prev.charAt(j)].indexOf(cur.charAt(j)) === -1) {
            requiredCharMap[prev.charAt(j)].push(cur.charAt(j));
            // number of prerequisite for using that char in this case it will be o: 1 since o has prerequisite e
            // { w: [], e: [ 'o' ], r: [], t: [], o: [] } 
            // { w: 0, e: 0, r: 0, t: 0, o: 1 } 
            charPreReqCount[cur.charAt(j)]++;
        }
    }
  
  
    // these will be the roots since there are no prerequisite needed to use them
    Object.keys(charPreReqCount).forEach(char => {
        if (charPreReqCount[char] === 0) {
            queue.push(char);
        }
    });
  
    // for those that we know are root
    while(queue.length > 0) {
        const rootChar = queue.shift();
        
        result.push(rootChar);
        
        for (i = 0; i < requiredCharMap[rootChar].length; i++) {
            var charRequiresRoot = requiredCharMap[rootChar][i];
            charPreReqCount[charRequiresRoot]--;
            
            if (charPreReqCount[charRequiresRoot] === 0) {
                queue.push(charRequiresRoot);
            }
        }
    }
  
    Object.keys(charPreReqCount).forEach((char) => {
        if (charPreReqCount[char] !== 0) {
            hasCycle = true;
        }
    });
  
    return hasCycle ? '' : result.join('');
}



// var words = [
//   "wrt",
//   "wrf",
//   "er",
//   "ett",
//   "rftt"
// ];


var words =[
  'wert',
  'woo'
];

console.log('ans', alienOrder(words));
</pre>
<hr />
</div>

<div>
<h3>27 Remove Element.js</h3>
<a name="27-remove-element-js"></a>
<pre>
// Leetcode 27
// Language: Javascript
// Problem: https://leetcode.com/problems/remove-element/
// Author: Chihung Yu
/**
 * @param {number[]} A
 * @param {number} elem
 * @returns {number}
 */
var removeElement = function(A, elem) {
    var i = 0;
    var j = A.length-1;
    
    while(i <= j){
        if(A[i] === elem){
            var temp = A[i];
            A[i] = A[j];
            A[j] = temp;
            j--;
        } else {
            i++;
        }
    }
    
    return i;
};
</pre>
<hr />
</div>

<div>
<h3>277 Find the Celebrity.js</h3>
<a name="277-find-the-celebrity-js"></a>
<pre>
// Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.

// Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

// You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.

// Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.

// Hide Company Tags LinkedIn Facebook
// Show Tags



/**
 * Definition for knows()
 * 
 * @param {integer} person a
 * @param {integer} person b
 * @return {boolean} whether a knows b
 * knows = function(a, b) {
 *     ...
 * };
 */

/**
 * @param {function} knows()
 * @return {function}
 */
var solution = function(knows) {
    /**
     * @param {integer} n Total people
     * @return {integer} The celebrity
     */
    return function(n) {
        var candidate = 0;
        
        // iterate through the list,
        // if candidate is known by i -> continue
        // if i doesnt know candidate, i becomes the candidate
        for(var i = 1; i < n; i++) {
            if(!knows(i, candidate)) {
                candidate = i;
            }
        }
        
        for(i = 0; i < n; i++) {
            if(i === candidate) {
                continue;
            }
            
            // if candidate is not known by i or candidate know i
            if(!knows(i, candidate) || knows(candidate, i)) {
                return -1;
            }
        }
        
        return candidate;
    };
};
</pre>
<hr />
</div>

<div>
<h3>278 First Bad Version.js</h3>
<a name="278-first-bad-version-js"></a>
<pre>
// You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

// Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

// You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

// Credits:
// Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

// Hide Company Tags Facebook
// Hide Tags Binary Search
// Hide Similar Problems (M) Search for a Range (M) Search Insert Position (E) Guess Number Higher or Lower


/**
 * Definition for isBadVersion()
 * 
 * @param {integer} version number
 * @return {boolean} whether the version is bad
 * isBadVersion = function(version) {
 *     ...
 * };
 */

/**
 * @param {function} isBadVersion()
 * @return {function}
 */
var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n) {
        var beg = 0;
        var end = n;
        var lastBad;
        
        while(beg <= end) {
            var mid = beg + Math.floor((end - beg)/2);
            if(isBadVersion(mid)) {
                // everything including and after are bad version
                lastBad = mid;
                end = mid - 1;
            } else {
                beg = mid + 1; 
            }
        }
        
        return lastBad;
    };
};
</pre>
<hr />
</div>

<div>
<h3>279. Perfect Squares.js</h3>
<a name="279-perfect-squares-js"></a>
<pre>
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
    
};
</pre>
<hr />
</div>

<div>
<h3>28 Implement strStr().js</h3>
<a name="28-implement-strstr-js"></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>282 Expression Add Operators.js</h3>
<a name="282-expression-add-operators-js"></a>
<pre>
// Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.

// Examples: 
// "123", 6 -> ["1+2+3", "1*2*3"] 
// "232", 8 -> ["2*3+2", "2+3*2"]
// "105", 5 -> ["1*0+5","10-5"]
// "00", 0 -> ["0+0", "0-0", "0*0"]
// "3456237490", 9191 -> []
// Credits:
// Special thanks to @davidtan1890 for adding this problem and creating all test cases.

// Hide Company Tags Google Facebook
// Hide Tags Divide and Conquer
// Hide Similar Problems (M) Evaluate Reverse Polish Notation (H) Basic Calculator (M) Basic Calculator II (M) Different Ways to Add Parentheses


// reference: http://blog.csdn.net/pointbreak1/article/details/48596115

var addOperators = function(num, target) {
  function opRecur(num, target, lastOp, result, expression, results) {
    if(num.length === 0) {
      if(target === result) {
        results.push(expression);
      }
      return;
    }

    for(var i = 1; i <= num.length; i++) {
      var curr = num.substring(0, i);
      if(curr.length > 1 && curr[0] === '0') {
        continue;
      }

      var rest = num.substring(i);
      var currVal = parseInt(curr);

      if(expression.length === 0) {
        opRecur(rest, target, currVal, currVal, expression + curr, results);
      } else {
        opRecur(rest, target, currVal, result + currVal, expression + "+" + curr, results);  
        opRecur(rest, target,-currVal, result - currVal, expression + "-" + curr, results);  
        opRecur(rest, target, currVal * lastOp, result - lastOp + lastOp * currVal, expression + "*" + curr, results);  
        // need to record the last oprand for handling mulitiplication. 
        // result - lastOP + lastOP * curVaule 
        // e.g 4+3*2 when dealing with *2, we have 4+3 then -3 then do 3*2
        // The operation for the function will look like 4 + 3 - 3 + 3 * 2
      }
    }
  }

  var results = [];
  opRecur(num, target, 0, 0, '', results);
  return results;
};

console.log(addOperators('01023', 3));
</pre>
<hr />
</div>

<div>
<h3>283 Move Zeroes.js</h3>
<a name="283-move-zeroes-js"></a>
<pre>
// Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

// For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

// Note:
// You must do this in-place without making a copy of the array.
// Minimize the total number of operations.
// Credits:
// Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

// Hide Company Tags Bloomberg Facebook
// Hide Tags Array Two Pointers
// Hide Similar Problems (E) Remove Element



/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
// var moveZeroes = function(nums) {
//     var x = 0;
//     var i = 0;
//     while(i < nums.length) {
//         if(nums[i] !== 0 && nums[x] === 0) {
//           nums[x++] = nums[i];
//           nums[i++] = 0;
//         }

//         while(nums[x] !== 0 && x < nums.length) {
//             x++;
//         }
      
//         if(i <= x) {
//           i = x + 1;
//         }
              
//         while(nums[i] === 0) {
//           i++;
//         }
//     }
// };




// // Simpler but slower algo
var moveZeroes = function(nums) {
    y = 0; // y is none zero pointer

    // y only increase when i found a none zero number
    // i only swap if i found a none zero number
    for (var i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            var tmp = nums[i];
            nums[i] = nums[y];
            nums[y] = tmp;
            y++;
        }
    }

    return nums;
};
console.log(moveZeroes([0,1,0,3,12]));
</pre>
<hr />
</div>

<div>
<h3>285 Inorder Successor in BST.js</h3>
<a name="285-inorder-successor-in-bst-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @return {TreeNode}
 */
var inorderSuccessor = function(root, p) {
    if(p.right) { // handle p = 14 or p = 27
        p = p.right;
        while(p.left) {
            p = p.left;
        }
        return p;
    }

    // if p has no right child
    
    //          20
    //       10       25
    //   6     14  22      27
    // 1    9
    //    8
    
    var succ = null;
    while(root !== p) {
        if(root.val > p.val) { // root is on the right hand side of p, handle case p = 1
            succ = root;
            root = root.left;
        } else if(root.val < p.val && root.right) { // handle case p = 8
            root = root.right;
        } else {
            break;
        }
    }
    return succ;
};
</pre>
<hr />
</div>

<div>
<h3>286 Walls and Gates.js</h3>
<a name="286-walls-and-gates-js"></a>
<pre>
// You are given a m x n 2D grid initialized with these three possible values.

// -1 - A wall or an obstacle.
// 0 - A gate.
// INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
// Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.

// For example, given the 2D grid:
// INF  -1  0  INF
// INF INF INF  -1
// INF  -1 INF  -1
//   0  -1 INF INF
// After running your function, the 2D grid should be:
//   3  -1   0   1
//   2   2   1  -1
//   1  -1   2  -1
//   0  -1   3   4
// Hide Company Tags Google Facebook
// Show Tags
// Show Similar Problems

var wallsAndGates = function(rooms) {
    var gates = [];
    
    if(!rooms || rooms.length === 0) {
        return;
    }
    
    var rows = rooms.length;
    var cols = rooms[0].length;
    
    
    for(var i = 0; i < rows; i++) {
        for(var j = 0; j < cols; j++) {
            // find all gates
            if(rooms[i][j] === 0) {
                traverse(rooms, i, j, rows, cols, 0);
            }
        }
    }
};

function traverse(rooms, i, j, rows, cols, dist) {
    if(i >= 0 && i < rows && j >= 0 && j < cols) {
        if(rooms[i][j] !== -1 && rooms[i][j] >= dist) {
            rooms[i][j] = dist;
            traverse(rooms, i + 1, j, rows, cols, dist + 1);
            traverse(rooms, i, j + 1, rows, cols, dist + 1);
            traverse(rooms, i - 1, j, rows, cols, dist + 1);
            traverse(rooms, i, j - 1, rows, cols, dist + 1);
        }
    }
}




// second attempt

/**
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */
var wallsAndGates = function(rooms) {
    for(var i = 0; i < rooms.length; i++) {
        for(var j = 0; j < rooms[i].length; j++) {
            if(rooms[i][j] === 0) {
                dfs(rooms, i, j, 0);
            }
        }
    }
    
    function dfs(rooms, i, j, dist) {
        if(i >= 0 && i < rooms.length && j >= 0 && j < rooms[i].length) {
        
            if(rooms[i][j] === -1 || rooms[i][j] < dist) {
                return;
            }
            
            if(rooms[i][j] > dist) {
               rooms[i][j] = dist; 
            }
            
            dfs(rooms, i + 1, j, dist + 1);
            dfs(rooms, i - 1, j, dist + 1);
            dfs(rooms, i, j + 1, dist + 1);
            dfs(rooms, i, j - 1, dist + 1);
        }
    }
};
</pre>
<hr />
</div>

<div>
<h3>289. Game of Life.js</h3>
<a name="289-game-of-life-js"></a>
<pre>
/**
 * @param {number[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var gameOfLife = function(board) {
    // 3 over-population or under population
    // 2 means reproduction
    // 1 is alive
    // 0 is dead
    // if mod 2 === 1 means the current state is alive else dead
    
    
    var rows = board.length;
    var cols = board[0].length;
    var dirX = [-1, 0, 1, 1, 1, 0,-1,-1];
    var dirY = [-1,-1,-1, 0, 1, 1, 1, 0];
    
    for(var i = 0; i < rows; i++) {
        for(var j = 0; j < cols; j++) {
            var cur = board[i][j];
            var count = 0;

            for(var k = 0; k < 8; k++) {
                var x = i + dirX[k];
                var y = j + dirY[k];
                if(x >= 0 && x <= rows && y >= 0 && y <= cols && board[x][y]%2 === 1) {
                    count++;
                }
            }
            
            if(board[i][j] === 1) {
                if(count > 3 || count < 2) {


                    board[i][j] = 3;
                }
            } else {
                if(count === 3) {
                    board[i][j] = 2;
                }
            }
        }
    }
      
    for(i = 0; i < rows; i++) {
        for(j = 0; j < cols; j++) {
            if(board[i][j] === 3) {
                board[i][j] = 0;
            } else if(board[i][j] === 2) {
                board[i][j] = 1;
            }
        }
    }
};
</pre>
<hr />
</div>

<div>
<h3>293 Flip Game.js</h3>
<a name="293-flip-game-js"></a>
<pre>
// You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner.

// Write a function to compute all possible states of the string after one valid move.

// For example, given s = "++++", after one move, it may become one of the following states:

// [
//   "--++",
//   "+--+",

//   "++--"
// ]
// If there is no valid move, return an empty list [].

// Hide Company Tags Google
// Hide Tags String
// Hide Similar Problems (M) Flip Game II


/**
 * @param {string} s
 * @return {string[]}
 */
var generatePossibleNextMoves = function(s) {
    var result = [];
    var arr = s.split('');
    
    for(var i = 0; i < s.length - 1; i++) {
        if(arr[i] === '+' && arr[i+1] === '+') {
            arr[i] = '-';
            arr[i+1] = '-';
            result.push(arr.join(''));
            arr[i] = '+';
            arr[i+1] = '+';
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>294 Flip Game II.js</h3>
<a name="294-flip-game-ii-js"></a>
<pre>
// You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive "++" into "--". The game ends when a person can no longer make a move and therefore the other person will be the winner.

// Write a function to determine if the starting player can guarantee a win.

// For example, given s = "++++", return true. The starting player can guarantee a win by flipping the middle "++" to become "+--+".

// Follow up:
// Derive your algorithm's runtime complexity.

// Hide Company Tags Google
// Hide Tags Backtracking
// Hide Similar Problems (E) Nim Game (E) Flip Game (M) Guess Number Higher or Lower II



/**
 * @param {string} s
 * @return {boolean}
 */
var canWin = function(s) {
    if(s === null || s.length === 0)   {
        return false;
    }
    
    var arr = s.split('');
    

    // player 1 can guarantee win if the move player 1 made can lead to player 2 no win of winning
    function checkCanWin(arr) {
        for(var i = 0; i < arr.length - 1; i++) {
            if(arr[i] === '+' && arr[i+1] === '+') {
                arr[i] = arr[i+1] = '-';
                
                var win = !checkCanWin(arr);
                
                arr[i] = arr[i+1] = '+';
                
                if(win) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    
    return checkCanWin(arr);
};
</pre>
<hr />
</div>

<div>
<h3>295 Find Median From Data Stream.js</h3>
<a name="295-find-median-from-data-stream-js"></a>
<pre>
/**
 * @constructor
 */
var MedianFinder = function() {
    this.large = new MinHeap();
    this.small = new MaxHeap();  
};

/**
 * @param {integer} word
 * @return {void}
 * Adds a num into the data structure.
 */
MedianFinder.prototype.addNum = function(num) {
  var lg = this.large.peek(); // lg peek is the minimum of large set
  var sm = this.small.peek(); // sm peek is the maximum of small set
  
  if(num <= sm) {
    this.small.add(num);
  } else {
    this.large.add(num);
  }
  
  var diff = this.small.size() - this.large.size();
  if(diff > 1) {
    this.large.add(this.small.pop());
  } else if(diff < 0) {
    this.small.add(this.large.pop());
  }
};


/**
 * @return {double}
 * Return median of current data stream
 */
MedianFinder.prototype.findMedian = function() {
    return this.small.size() > this.large.size() ? 
        this.small.peek() : (this.small.peek() + this.large.peek())/2;
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var mf = new MedianFinder();
 * mf.addNum(1);
 * mf.findMedian();
 */

class MaxHeap {
  constructor() {
    this.arr = [];
  }

  peek() {
    return this.arr[0] || null;
  }

  size() {
    return this.arr.length;
  }

  pop() {
    var arr = this.arr;
    var len = arr.length;

    if(len === 0) {
      return null;
    }

    var max = arr[0];
    arr[0] = arr[len - 1] // swap the last value with max value

    arr.pop();

    this.sinkDown(0);

    return max;
  }

  add(val) {
    var arr = this.arr;
    arr.push(val);
    this.bubbleUp(arr.length - 1);
  }

  bubbleUp(n) {
    var arr = this.arr;

    while(n > 0) {
      var parentN = Math.floor((n + 1)/2) - 1; // [1,2,3] 1 as root 2 as left child and 3 as right child      2 has idx = 1 and 3 has idx = 2    1/2 will result in parent idx = 0 and 2/2 will result in parent idx = 1. So we need to add one to them and -1 at the end

      if(arr[parentN] > arr[n]) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[parentN];
      arr[parentN] = tmp;
      n = parentN;
    } 
  }

  sinkDown(n) {
    var arr = this.arr;
    var len = arr.length;
    var val = arr[n];
  
    while(true) {
      
      var swap = null;
      var child2N = (n+1)*2; // root = 0 right child idx is (0 + 1)*2 = 2
      var child1N = child2N - 1; // right child idx - 1 = 1 for root's left child
      
      if(child1N < len && arr[child1N] > val) {
        swap = child1N;
      }

      if(child2N < len && arr[child2N] > val && arr[child2N] >= arr[child1N]) {
        swap = child2N;
      }
    
      if(swap === null) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[swap];
      arr[swap] = tmp;
      n = swap;
    } 
  }
}


class MinHeap {
  constructor() {
    this.arr = [];
  }

  peek() {
    return this.arr[0] || null;
  }

  size() {
    return this.arr.length;
  }

  pop() {
    var arr = this.arr;
    var len = arr.length;

    if(len === 0) {
      return null;
    }

    var min = arr[0];
    arr[0] = arr[len - 1] // swap the last value with min value

    arr.pop();

    this.sinkDown(0);

    return min;
  }

  add(val) {
    var arr = this.arr;
    arr.push(val);
    this.bubbleUp(arr.length - 1);
  }

  bubbleUp(n) {
    var arr = this.arr;

    while(n > 0) {
      var parentN = Math.floor((n + 1)/2) - 1; // [1,2,3] 1 as root 2 as left child and 3 as right child      2 has idx = 1 and 3 has idx = 2    1/2 will result in parent idx = 0 and 2/2 will result in parent idx = 1. So we need to add one to them and -1 at the end

      if(arr[parentN] <= arr[n]) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[parentN];
      arr[parentN] = tmp;
      n = parentN;
    } 
  }

  sinkDown(n) {
    var arr = this.arr;
    var len = arr.length;
    var val = arr[n]

    while(true) {
      var swap = null;
      var child2N = (n+1)*2; // root = 0 right child idx is (0 + 1)*2 = 2
      var child1N = child2N - 1; // right child idx - 1 = 1 for root's left child
      if(child1N < len && arr[child1N] < val) {
        swap = child1N;
      }

      if(child2N < len && arr[child2N] < val && arr[child2N] <= arr[child1N]) {
        swap = child2N;
      }

      if(swap === null) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[swap];
      arr[swap] = tmp;
      n = swap;
    } 
  }
}
</pre>
<hr />
</div>

<div>
<h3>296 Best Meeting Point.js</h3>
<a name="296-best-meeting-point-js"></a>
<pre>
// A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.

// For example, given three people living at (0,0), (0,4), and (2,2):

// 1 - 0 - 0 - 0 - 1
// |   |   |   |   |
// 0 - 0 - 0 - 0 - 0
// |   |   |   |   |
// 0 - 0 - 1 - 0 - 0
// The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.

// Show Hint 
// Show Company Tags
// Show Tags
// Show Similar Problems


/**
 * @param {number[][]} grid
 * @return {number}
 */
var minTotalDistance = function(grid) {
    var xpos = [];
    var ypos = [];
    
    // get all positions
    for(var x = 0; x < grid.length; x++) {
        for(var y = 0; y < grid[0].length; y++) {
            if(grid[x][y] === 1) {
                xpos.push(x);
                ypos.push(y);
            }
        }
    }
    
    // no need to sort x
    return getMedianPoint(xpos) + getMedianPoint(ypos, true);
};

var getMedianPoint = function(arr, shouldSort) {
    if(shouldSort) {
        arr.sort((a,b)=> {
            return a > b ? 1 : -1;
        });
    }
    
    var beg = 0;
    var end = arr.length - 1;
    var res = 0;
    
    while(beg < end) {
        res += arr[end--] - arr[beg++];
    }
    
    return res;
}
</pre>
<hr />
</div>

<div>
<h3>297 Serialize and Deserialize Binary Tree My Submissions Question.js</h3>
<a name="297-serialize-and-deserialize-binary-tree-my-submissions-question-js"></a>
<pre>
// Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

// Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

// For example, you may serialize the following tree

//     1
//    / \
//   2   3
//      / \
//     4   5
// as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
// Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

// Credits:
// Special thanks to @Louis1992 for adding this problem and creating all test cases.

// Hide Company Tags LinkedIn Google Uber Facebook Amazon Microsoft Yahoo Bloomberg
// Show Tags
// Show Similar Problems


/*
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
//  http://fisherlei.blogspot.com/2013/03/interview-serialize-and-de-serialize.html

// only pre order travesal can provide information about the root node
// the other technique that we can use is to use level order traversal
var serialize = function(root) {
    var result = [];
    serializer(root, result);
    
    return result.join(",");
};

var serializer = function(node, output) {
    if(node === null) {
        output.push("#");
        return;
    }
    
    output.push(node.val);
    serializer(node.left, output);
    serializer(node.right, output);
}

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    data = data.split(",");
    var index = 0;
   
    function deserializer(data) {
        if(index > data.length || data[index] === "#") {
            return null;
        }
        
        var node = new TreeNode(parseInt(data[index]));
        index++;
        node.left = deserializer(data);
        index++;
        node.right = deserializer(data);
        return node;
    }
    
    return deserializer(data);
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */


/*
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
// var serialize = function(root) {
//     if(!root) {
//         return "";
//     }
    
//     var result = [];
//     var curLvl = [];
//     var nextLvl = [];
//     curLvl.push(root);

//     while(curLvl.length) {
//         var node = curLvl.shift();
        
//         if(node) {
//             result.push(node.val);
            
//             if(node.left) {
//                 nextLvl.push(node.left);
//             } else {
//                 nextLvl.push(null);
//             }
            
//             if(node.right) {
//                 nextLvl.push(node.right);
//             } else {
//                 nextLvl.push(null);
//             }
//         } else {
//             result.push(null);
//         }
        
//         if(curLvl.length === 0) {
//             curLvl = nextLvl;
//             nextLvl = [];
//         }
//     }
    
//     console.log('serialize: ',result)
    
//     return result.join(',');
// };

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
// var deserialize = function(data) {
//     if(data === "") {
//         return null
//     }
    
//     data = data.split(',');
    
//     var val = data.shift();
//     var root = new TreeNode(val);
    
//     var curLvlCnt = 1;
//     var nextLvlCnt = 0;
//     var lvl = [];
//     lvl.push(root);

//     while(data.length) {
//         var node = lvl.shift();
//         curLvlCnt--;
        
//         var leftVal = data.shift();
//         var rightVal = data.shift();
        
//         if(leftVal) {
//             node.left = new TreeNode(leftVal);
//             nextLvlCnt++;
//             lvl.push(node.left);
//         } else {
//             node.left = null;
//         }
        
//         if(rightVal) {
//             node.right = new TreeNode(rightVal);
//             nextLvlCnt++;
//             lvl.push(node.right);
//         } else {
//             node.right = null;
//         }
        
//         if(curLvlCnt === 0) {
//             curLvlCnt = nextLvlCnt;
//             nextLvlCnt = 0;
//         }
//     }
    
//     console.log('deserialize: ',root)
    
//     return root;
// };

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 
</pre>
<hr />
</div>

<div>
<h3>3 Longest Substring Without Repeating Characters.js</h3>
<a name="3-longest-substring-without-repeating-characters-js"></a>
<pre>
/**
 * @param {string} s
 * @return {number}
 */

/**
 * Given a string, find the length of the longest substring without repeating characters.
 * For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.
 */
var lengthOfLongestSubstring = function(s) {
    if(s === null || s.length === 0){
        return 0;
    }
    
    var map = {};
    var len = 0;
    var maxLen = len;
    var start = 0;

    // scan from left to right.    
    for(var i = start; i < s.length; i++){
        c = s[i];

        if(map[c] !== undefined && map[c] >= start) {
            start = map[c] + 1; // start new search with repeated word's last location + 1
            len = i - start; // real length -> from for example 3 to 5 is 3, so it's 5-3+1 and + 1 happens later
        }
        
        len++; // real length -> from for example 3 to 5 is 3, so it's 5-3+1 and + 1 happens later
        
        if(len > maxLen){
            maxLen = len;
        }
        
        map[c] = i;
    }
    
    return maxLen;
};
</pre>
<hr />
</div>

<div>
<h3>300 Longest Increasing Subsequence.js</h3>
<a name="300-longest-increasing-subsequence-js"></a>
<pre>
// Given an unsorted array of integers, find the length of longest increasing subsequence.

// For example,
// Given [10, 9, 2, 5, 3, 7, 101, 18],
// The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.

// Your algorithm should run in O(n2) complexity.

// Follow up: Could you improve it to O(n log n) time complexity?

// Credits:
// Special thanks to @pbrother for adding this problem and creating all test cases.

// Hide Company Tags Microsoft
// Show Tags
// Show Similar Problems
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    var size = nums.length;
    
    if(size === 0) {
        return 0;
    }
    
    dp = Array(size).fill(1);
    
    for(var i = 1; i < size; i++) {
        for(var j = 0; j < i; j++) {
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return Math.max.apply(null, dp);
};



console.log(Infinity < Infinity)
</pre>
<hr />
</div>

<div>
<h3>301 Remove Invalid Parentheses.js</h3>
<a name="301-remove-invalid-parentheses-js"></a>
<pre>
// Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

// Note: The input string may contain letters other than the parentheses ( and ).

// Examples:
// "()())()" -> ["()()()", "(())()"]
// "(a)())()" -> ["(a)()()", "(a())()"]
// ")(" -> [""]
// Credits:
// Special thanks to @hpplayer for adding this problem and creating all test cases.

// Hide Company Tags Facebook
// Hide Tags Depth-first Search Breadth-first Search
// Hide Similar Problems (E) Valid Parentheses


/**
 * @param {string} s
 * @return {string[]}
 */

function isValid(s) {
    var count = 0;
    
    for(var i = 0; i < s.length; i++) {
        if(s[i] === '(') {
            count++;
        } else if(s[i] === ')') {
            count--;
        }
        
        if(count < 0) {
            return false;
        }
    }
    
    return count === 0;
}

var removeInvalidParentheses = function(s) {
    var queue = [];
    queue.push(s);
    var visited = {};
    var res = [];
    var found = false;
    

    // breadth first search since we are looking for the minimum changes
    while(queue.length > 0) {
        s = queue.shift();
        
        // things stored in the queue represent the same level (same number of changes)
        // once we found a valid one, we should not look further into the next level (by setting found to true)
        if(isValid(s)) {
            res.push(s);
            found = true;
        }
        
        if(found) {
            continue;
        }
        
        // if nothing found, then loop through the entire string and remove one of the parenthesis.
        for(var i = 0; i < s.length; i++) {
            if(s[i] !== '(' && s[i] !== ')') {
                continue;
            }
            
            var newS = s.substring(0,i) + s.substring(i + 1);
            
            if(!visited[newS]) {
                visited[newS] = true;
                queue.push(newS);
            }
        }
    }
    
    return res;
};
</pre>
<hr />
</div>

<div>
<h3>307 Range Sum Query - Mutable.js</h3>
<a name="307-range-sum-query-mutable-js"></a>
<pre>
// http://bookshadow.com/weblog/2015/08/13/segment-tree-set-1-sum-of-given-range/
</pre>
<hr />
</div>

<div>
<h3>31 Next Permutation.js</h3>
<a name="31-next-permutation-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
//  http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html
var nextPermutation = function(nums) {
    var vioIndex = nums.length - 1;
    
    while(vioIndex > 0) {
        if(nums[vioIndex - 1] < nums[vioIndex]) {
            break;
        }
        vioIndex--;
    }
    
    if(vioIndex > 0) {
        vioIndex--;
        var first = nums.length - 1;
        while(first > vioIndex && nums[first] <= nums[vioIndex]){
            first--;
        }
        
        var temp = nums[vioIndex];
        nums[vioIndex] = nums[first];
        nums[first] = temp;
        
        vioIndex++;
    }
    
    var end = nums.length - 1;
    
    while(end > vioIndex) {
        temp = nums[end];
        nums[end] = nums[vioIndex];
        nums[vioIndex] = temp;
        
        end--;
        vioIndex++;
    }
};
</pre>
<hr />
</div>

<div>
<h3>311 Sparse Matrix Multiplication.js</h3>
<a name="311-sparse-matrix-multiplication-js"></a>
<pre>
// Given two sparse matrices A and B, return the result of AB.

// You may assume that A's column number is equal to B's row number.

// Example:

// A = [
//   [ 1, 0, 0],
//   [-1, 0, 3]
// ]

// B = [
//   [ 7, 0, 0 ],
//   [ 0, 0, 0 ],
//   [ 0, 0, 1 ]
// ]


//      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
// AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
//                   | 0 0 1 |
// Hide Company Tags LinkedIn Facebook
// Hide Tags Hash Table


/**
 * @param {number[][]} A
 * @param {number[][]} B
 * @return {number[][]}
 */

// normal matrix mulitplication
// slower version
var multiply1 = function(A, B) {
    var result = [];

    var rowA = A.length;
    var colA = A[0].length;
    var rowB = B.length;
    var colB = B[0].length

    for(var i = 0; i < rowA; i++) {
        result.push(Array(colB).fill(0));
        
        for(var j = 0; j < colB; j++) {
            
            for(var k = 0; k < colA; k++) {
                result[i][j] += A[i][k]*B[k][j]    
            }
            
        }
    }
    
    return result;
};

// faster
// skip
multiply = function(A, B) {
    var result = [];
    var i,j,k;

    var rowA = A.length;
    var colA = A[0].length;
    var colB = B[0].length

    for(var i = 0; i < rowA; i++) {
        result.push(Array(colB).fill(0));
    }

    for(i = 0; i < rowA; i++) {
        for(k = 0; k < colA; k++) {
            if(A[i][k] !== 0) {
                for(j = 0; j < colB; j++) {
                    if(B[k][j] !== 0) {
                        result[i][j] += A[i][k]*B[k][j];
                    }
                }    
            }
        }
    }
    
    return result;
};



// var data1 = [[0,1],[0,0],[0,1]];
// var data2 = [[1,0],[1,0]];

// var data1 = [[1,0,0],[-1,0,3]];
// var data2 = [[7,0,0],[0,0,0],[0,0,1]];

var data1 = [[1,-5]];
var data2 = [[12],[-1]];

console.log(multiply(data1,data2));
</pre>
<hr />
</div>

<div>
<h3>314 Binary Tree Vertical Order Traversal.js</h3>
<a name="314-binary-tree-vertical-order-traversal-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */

var verticalOrder = function(root) {
    var res = [];
    
    if(root === null) {
        return res;
    }
    
    var hash = {};
    var queue = [];
    queue.push([root, 0]);
    var min = Infinity;
    var max = -Infinity;
    
    while(queue.length) {
        var len = queue.length;
        
        for(var i = 0; i < len; i++) {
            var pair = queue.shift();
            var node = pair[0];
            var order = pair[1];
            
            hash[order] = hash[order] || [];
            hash[order].push(node.val);
            
            min = Math.min(order, min);
            max = Math.max(order, max);
            
            if(node.left) {
                queue.push([node.left, order - 1]);
            }
            
            if(node.right) {
                queue.push([node.right, order + 1]);
            }
        }
    }
    
    while(min <= max) {
        if(hash[min].length) {
            res.push(hash[min]);
        }
        min++;
    }
    
    return res;
};
</pre>
<hr />
</div>

<div>
<h3>317 Shortest Distance From All Buildings.js</h3>
<a name="317-shortest-distance-from-all-buildings-js"></a>
<pre>
/**
 * @param {number[][]} grid
 * @return {number}
 */
var shortestDistance = function(grid) {
    var rows = grid.length;
    if(rows === 0) {
        return -1;
    }
    
    var cols = grid[0].length;
    // 2D array that records sum distances to all buildings
    var dist = [];
    
    // 2D array that records how many buildings can visit here
    var nums = [];
    
    for(var row = 0; row < rows; row++) {
        dist.push([]);
        nums.push([]);
        
        for(var col = 0; col < cols; col++) {
            dist[row][col] = 0;
            nums[row][col] = 0;
        }
    }
    
    var buildingNum = 0;
    
    for(row = 0; row < rows; row++) {
        for(col = 0; col < cols; col++) {
            if(grid[row][col] === 1) {
                buildingNum++;
                bfs(grid, row, col, dist, nums);
            }
        }
    }  
    
    var min = Infinity;
    
    for(row = 0; row < rows; row++) {
        for(col = 0; col < cols; col++) {
            if(grid[row][col] === 0 && dist[row][col] !== 0 && nums[row][col] === buildingNum) {
                min = Math.min(min, dist[row][col]);
            }
        }
    }
    
    if(min < Infinity) {
        return min;
    }
    
    return -1;
};

function bfs(grid, begCol, begRow, dist, nums) {
    var rows = grid.length;
    var cols = grid[0].length;
    var queue = [];
    queue.push([begRow, begCol]);
    var dirs = [[-1,0],[0,1],[1,0],[0,-1]];
    var level = 0;
    
    // record if location is visited
    var visited = [];
    // init visited to all false
    for(var row = 0; row < rows; row++) {
        visited.push([]);
        for(var col = 0; col < cols; col++) {
            visited[row][col] = false;
        }
    }
     
    while(queue.length !== 0) {
        level++;
        var len = queue.length;
        
        for(var i = 0; i < len; i++) {
            var coords = queue.shift();
            for(var j =0; j < dirs.length; j++) {
                var x = coords[0] + dirs[j][0];
                var y = coords[1] + dirs[j][1];
                
                if(x >= 0 && x < rows && y >= 0 && y < cols && !visited[x][y] && grid[x][y] === 0) {
                    visited[x][y] = true;
                    
                    dist[x][y] += level;
                    nums[x][y]++;
                    queue.push([x,y]);
                }
            }
        }
    }
}


function init2D
</pre>
<hr />
</div>

<div>
<h3>318 Maximum Product of Word Lengths My Submissions Question.js</h3>
<a name="318-maximum-product-of-word-lengths-my-submissions-question-js"></a>
<pre>
// Leetcode 318
// Language: Javascript
// Problem: https://leetcode.com/problems/maximum-product-of-word-lengths/
// Author: Chihung Yu
/**
 * @param {string[]} words
 * @return {number}
 */
var maxProduct = function(words) {
    var processed = [];
    
    for(var i = 0; i < words.length; i++) {
        processed.push(compute(words[i]));
    }

    var result = [];
    var max = 0;
    
    for(i = 0; i < words.length; i++) {
        for(var j = i + 1; j < words.length; j++) {
            if((processed[i] & processed[j]) === 0) {
                var cur = words[i].length * words[j].length;
                
                if(cur > max) {
                    max = cur;
                }
            }
        }
    }
    
    return max;
};

function compute(word) {
    var val = 0;
    var base = "a".charCodeAt(0);
    
    for(i = 0; i < word.length; i++){
        val |= (1 << (word.charCodeAt(i) - base));
        
    }
    return val;
}
</pre>
<hr />
</div>

<div>
<h3>320 Generalized Abbreviation.js</h3>
<a name="320-generalized-abbreviation-js"></a>
<pre>
// Write a function to generate the generalized abbreviations of a word.

// Example:
// Given word = "word", return the following list (order does not matter):
// ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
// Hide Company Tags Google
// Hide Tags

/**
 * @param {string} word
 * @return {string[]}
 */
var generateAbbreviations = function(word) {
    var result = [];
    dfs(result, word, 0, '', 0);
    return result;
};

var dfs = function(result, word, pos, cur, count) {
    if(pos === word.length) {
        if(count > 0) {
            cur += count;
        }
        result.push(cur);
        return;
    }
    
    dfs(result, word, pos + 1, cur, count + 1);
    dfs(result, word, pos + 1, cur + (count > 0 ? count : '') + word[pos], 0);
}

</pre>
<hr />
</div>

<div>
<h3>322 Coin Change.js</h3>
<a name="322-coin-change-js"></a>
<pre>
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {    
    var dp = [0];
    for(var i = 1; i <= amount; i++) {
        dp.push(-1);
    }
    

    for(var a = 0; a < amount; a++) {
        if(dp[a] < 0) {
            continue;
        }
        
        for(var c = 0; c < coins.length; c++) {
            var coin = coins[c];
            
            if((a + coin) > amount) {
                continue;
            }
            
            // if(dp[a + coin] < 0 || dp[a + coin] > dp[a] + 1) {
            if(dp[a + coin] < 0) {
                dp[a + coin] = dp[a] + 1;
            }
        }
    }
    console.log(dp)
    console.log(dp[amount])
    return dp[amount];
};

coinChange([1,2,5,10,25], 25);
</pre>
<hr />
</div>

<div>
<h3>325 Maximum Size Subarray Sum Equals k.js</h3>
<a name="325-maximum-size-subarray-sum-equals-k-js"></a>
<pre>
// Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

// Example 1:
// Given nums = [1, -1, 5, -2, 3], k = 3,
// return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

// Example 2:
// Given nums = [-2, -1, 2, 1], k = 1,
// return 2. (because the subarray [-1, 2] sums to 1 and is the longest)

// Follow Up:
// Can you do it in O(n) time?

// Hide Company Tags Palantir Facebook
// Hide Tags Hash Table
// Hide Similar Problems (M) Minimum Size Subarray Sum (E) Range Sum Query - Immutable


/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxSubArrayLen = function(nums, k) {
    var maxLen = 0;
    var currSum = 0;
    var dict = { 0: -1 };
    
    for(var i = 0; i < nums.length; i++) {
        currSum += nums[i];
        
        // since we are looking for the maxlen, dict is used to store the very first
        // location where currSum occurred      
        if(dict[currSum] === undefined) {
            dict[currSum] = i;
        }
        
        if(dict[currSum - k] !== undefined) {
            maxLen = Math.max(maxLen, i - dict[currSum - k]);
        }
    }
    
    return maxLen;
};
</pre>
<hr />
</div>

<div>
<h3>33 Search in Rotated Sorted Array.js</h3>
<a name="33-search-in-rotated-sorted-array-js"></a>
<pre>
// Suppose a sorted array is rotated at some pivot unknown to you beforehand.

// (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

// You are given a target value to search. If found in the array return its index, otherwise return -1.

// You may assume no duplicate exists in the array.


/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    var left = 0;
    var right = nums.length - 1;
    
    while(left <= right) {
        var mid = parseInt((left + right)/2);
        if(nums[mid] === target) {
            return mid;
        }
        
        if(nums[mid] >= nums[left]) { // correct order
            
            if(nums[left] <= target && target < nums[mid]) {
                // target is within the correct order part
                right = mid - 1;
            } else {
                // target is not within the correct order part
                left = mid + 1;
            }
        } else { // incorrect order
            if(nums[mid] < target && target <= nums[right]) {
                // target is within the correct order part
                left = mid + 1;
            } else {
                // target is not within the correct order part
                right = mid - 1;
            }
        }
    }
    
    return -1;
};
</pre>
<hr />
</div>

<div>
<h3>334 Increasing Triplet Subsequence.js</h3>
<a name="334-increasing-triplet-subsequence-js"></a>
<pre>
// Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

// Formally the function should:
// Return true if there exists i, j, k 
// such that arr[i] < arr[j] < arr[k] given 0 = i < j < k = n-1 else return false.
// Your algorithm should run in O(n) time complexity and O(1) space complexity.

// Examples:
// Given [1, 2, 3, 4, 5],
// return true.

// Given [5, 4, 3, 2, 1],
// return false.

// Credits:
// Special thanks to @DjangoUnchained for adding this problem and creating all test cases.

// Hide Company Tags Facebook
// Hide Similar Problems (M) Longest Increasing Subsequence


/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    var min1 = Infinity;
    var min2 = Infinity;
    
    for(var i = 0; i < nums.length; i++) {
        if(nums[i] <= min1) {
            min1 = nums[i];
        } else if(nums[i] <= min2) {
            min2 = nums[i];
        } else {
            return true;
        }
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>335 Self Crossing.js</h3>
<a name="335-self-crossing-js"></a>
<pre>
/**
 * @param {number[]} x
 * @return {boolean}
 */
 
//  http://www.cnblogs.com/grandyang/p/5216856.html
var isSelfCrossing = function(x) {
    
    for(var i = 3; i < x.length; i++) {
        if (x[i] >= x[i - 2] && x[i - 3] >= x[i - 1]) {
            return true;
        }
        if(i >= 4 && x[i-1] == x[i-3] && x[i] >= (x[i-2] - x[i-4])) {
            return true;
        }
        if(i >= 5 && x[i-2] >= x[i-4] && x[i-3] >= x[i-1] && x[i-1] >= (x[i-3] - x[i-5]) && x[i] >= (x[i-2] - x[i-4])) {
            return true;
        }
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>337 House Robber III.js</h3>
<a name="337-house-robber-iii-js"></a>
<pre>
// The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.

// Determine the maximum amount of money the thief can rob tonight without alerting the police.

// Example 1:
//      3
//     / \
//    2   3
//     \   \ 
//      3   1
// Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
// Example 2:
//      3
//     / \
//    4   5
//   / \   \ 
//  1   3   1
// Maximum amount of money the thief can rob = 4 + 5 = 9.

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var rob = function(root) {
    var result = robViaDfs(root);
    return Math.max.apply(null, result);
};


// Array[0] max money when root is selected
// Array[1] max money when root is Not selected
function robViaDfs(root) {
    if (!root) {
        return [0, 0];
    }
    
    var left = robViaDfs(root.left),
        right = robViaDfs(root.right),
        includeRoot,
        notIncludeRoot;
    
    includeRoot = left[1] + right[1] + root.val; // array[1] is value from before of not including root
    notIncludeRoot = Math.max.apply(null, left) + Math.max.apply(null, right);
    
    return [includeRoot, notIncludeRoot];
}

</pre>
<hr />
</div>

<div>
<h3>338 Count Bits.js</h3>
<a name="338-count-bits-js"></a>
<pre>
// Given a non negative integer number num. For every numbers i in the range 0 = i = num calculate the number of 1's in their binary representation and return them as an array.

// Example:
// For num = 5 you should return [0,1,1,2,1,2].

// Follow up:

// It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
// Space complexity should be O(n).
// Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
// Show Hint 
// Credits:
// Special thanks to @ syedee for adding this problem and creating all test cases.

// Hide Tags Dynamic Programming Bit Manipulation
// Hide Similar Problems (E) Number of 1 Bits



var countBits = function(num) {
    var ans = [0];
    
    for(var i = 1; i <= num; i++) {
        ans[i] = (ans[i] || 0) + ans[i&(i-1)] + 1;
    }
    
    return ans;
};

// 0 0 0 1
// 0 0 1 0
// 0 0 1 1
// 0 1 0 0


console.log(countBits(3));
</pre>
<hr />
</div>

<div>
<h3>339 Nested List Weight Sum.js</h3>
<a name="339-nested-list-weight-sum-js"></a>
<pre>
// Given a nested list of integers, return the sum of all integers in the list weighted by their depth.

// Each element is either an integer, or a list -- whose elements may also be integers or other lists.

// Example 1:
// Given the list [[1,1],2,[1,1]], return 10. (four 1's at depth 2, one 2 at depth 1)

// Example 2:
// Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)

// Hide Company Tags LinkedIn
// Show Tags
// Show Similar Problems


/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @param {NestedInteger[]} nestedList
 * @return {number}
 */
 
var depthSum = function(nestedList) {
    
    function traverse(arr, lvl) {
        var sum = 0;
        
        for(var i = 0; i < arr.length; i++) {
            if(arr[i].isInteger()) {
                sum += arr[i].getInteger()*lvl;
            } else {
                sum += traverse(arr[i].getList(), lvl + 1);
            }
        }
        
        return sum;
    }
    
    return traverse(nestedList, 1);
};
</pre>
<hr />
</div>

<div>
<h3>34 Search for a Range.js</h3>
<a name="34-search-for-a-range-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
 
var searchRange = function(nums, target) {
    var l = 0;
    var r = nums.length - 1;
    var leftBound = -1;
    var rightBound = -1;
    
    while(l <= r){
        var mid = l + parseInt((r-l)/2);
        console.log(mid, nums[mid])
        if(nums[mid] === target){
            leftBound = mid;
            r = mid - 1;
        } else if(nums[mid] > target){
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    
    l = 0;
    r = nums.length - 1;
    
    while(l <= r){
        mid = l + parseInt((r-l)/2);
        if(nums[mid] === target){
            rightBound = mid;
            l = mid + 1;
        } else if(nums[mid] > target){
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    
    return [leftBound, rightBound];
};
</pre>
<hr />
</div>

<div>
<h3>340 Longest Substring With At Most K Distinct Characters.js</h3>
<a name="340-longest-substring-with-at-most-k-distinct-characters-js"></a>
<pre>
/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var lengthOfLongestSubstringKDistinct = function(s, k) {
    var longestSubstr = "";
    var maxLength = 0;
    var start = 0;
    var map = new Map();
    
    if(k === 0) {
        return 0;
    }
    
    for(var i = 0; i < s.length; i++) {
        var c = s.charAt(i);
        
        // if map already contains two distrinct chars and the char is new to the map
        if(map.size >= k && map.get(c) === undefined) {
            var leftMost = s.length;
              
            // Calc substring len before the new char
            if(i - start > maxLength) {
                // Should not include i, since i is the new distinct char's index
                longestSubstr = s.substring(start, i);
                maxLength = longestSubstr.length;
            }
            
            map.forEach((charIdx, key)=> {
                if(charIdx < leftMost) {
                    leftMost = charIdx;
                }
            });
                      
            start = leftMost + 1;
            map.delete(s[leftMost]);
        }
        
        map.set(c, i);
    }
    
    if(s.length - start > maxLength) {
        longestSubstr = s.substring(start, s.length);
        maxLength = longestSubstr.length;
    }
    
    return maxLength;  
};
</pre>
<hr />
</div>

<div>
<h3>341 Flatten Nested List Iterator.js</h3>
<a name="341-flatten-nested-list-iterator-js"></a>
<pre>
// Given a nested list of integers, implement an iterator to flatten it.

// Each element is either an integer, or a list -- whose elements may also be integers or other lists.

// Example 1:
// Given the list [[1,1],2,[1,1]],

// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].

// Example 2:
// Given the list [1,[4,[6]]],

// By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].

// Hide Company Tags Google Facebook Twitter
// Hide Tags Stack Design
// Hide Similar Problems (M) Flatten 2D Vector (M) Zigzag Iterator



/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
    this.stack = [];
    
    for(var i = nestedList.length; i--;) {
        this.stack.push(nestedList[i]);
    }
};


/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
    // keep looping until we found insert an integer in the stack
    while(this.stack.length > 0) {
        var next = this.stack[this.stack.length - 1];
        
        if(next.isInteger()) {
            return true;
        }
        
        this.stack.pop();
        var list = next.getList();
        for(var i = list.length; i--;) {
            this.stack.push(list[i]);
        }
    }
        
    return false;
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
    return this.stack.pop();
};

/**
 * Your NestedIterator will be called like this:
 * var i = new NestedIterator(nestedList), a = [];
 * while (i.hasNext()) a.push(i.next());
*/
</pre>
<hr />
</div>

<div>
<h3>348. Design Tic-Tac-Toe.java</h3>
<a name="348-design-tic-tac-toe-java"></a>
<pre>
// Design a Tic-tac-toe game that is played between two players on a n x n grid.

// You may assume the following rules:

// A move is guaranteed to be valid and is placed on an empty block.
// Once a winning condition is reached, no more moves is allowed.
// A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.
// Example:
// Given n = 3, assume that player 1 is "X" and player 2 is "O" in the board.

// TicTacToe toe = new TicTacToe(3);

// toe.move(0, 0, 1); -> Returns 0 (no one wins)
// |X| | |
// | | | |    // Player 1 makes a move at (0, 0).
// | | | |

// toe.move(0, 2, 2); -> Returns 0 (no one wins)
// |X| |O|
// | | | |    // Player 2 makes a move at (0, 2).
// | | | |

// toe.move(2, 2, 1); -> Returns 0 (no one wins)
// |X| |O|
// | | | |    // Player 1 makes a move at (2, 2).
// | | |X|

// toe.move(1, 1, 2); -> Returns 0 (no one wins)
// |X| |O|
// | |O| |    // Player 2 makes a move at (1, 1).
// | | |X|

// toe.move(2, 0, 1); -> Returns 0 (no one wins)
// |X| |O|
// | |O| |    // Player 1 makes a move at (2, 0).
// |X| |X|

// toe.move(1, 0, 2); -> Returns 0 (no one wins)
// |X| |O|
// |O|O| |    // Player 2 makes a move at (1, 0).
// |X| |X|

// toe.move(2, 1, 1); -> Returns 1 (player 1 wins)
// |X| |O|
// |O|O| |    // Player 1 makes a move at (2, 1).
// |X|X|X|
// Follow up:
// Could you do better than O(n2) per move() operation?



public class TicTacToe {
    private int[] rows;
    private int[] cols;
    private int diagonal;
    private int antiDiagonal;
    private int size;

    /** Initialize your data structure here. */
    public TicTacToe(int n) {
        rows = new int[n];
        cols = new int[n];
        size = n;
    }
    
    /** Player {player} makes a move at ({row}, {col}).
        @param row The row of the board.
        @param col The column of the board.
        @param player The player, can be either 1 or 2.
        @return The current winning condition, can be either:
                0: No one wins.
                1: Player 1 wins.
                2: Player 2 wins. */
    public int move(int row, int col, int player) {
        int toAdd = player == 1 ? 1 : -1;
        
        rows[row] += toAdd;
        cols[col] += toAdd;
        
        if(row == col) {
            diagonal += toAdd;
        }
        
        if(col == cols.length - row - 1) {
            antiDiagonal += toAdd;
        }
        
        if(Math.abs(cols[col]) == size ||
            Math.abs(rows[row]) == size ||
            Math.abs(diagonal) == size ||
            Math.abs(antiDiagonal) == size) {
                return player;
            }
        
        return 0;
    }
}

/**
 * Your TicTacToe object will be instantiated and called as such:
 * TicTacToe obj = new TicTacToe(n);
 * int param_1 = obj.move(row,col,player);
 */
</pre>
<hr />
</div>

<div>
<h3>349 Intersection of Two Arrays.js</h3>
<a name="349-intersection-of-two-arrays-js"></a>
<pre>
// Given two arrays, write a function to compute their intersection.

// Example:
// Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].

// Note:
// Each element in the result must be unique.
// The result can be in any order.
// Hide Tags Binary Search Hash Table Two Pointers Sort
// Hide Similar Problems (E) Intersection of Two Arrays II


/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    var hash = {};
    var result = [];
    var i = 0;
    while(i < nums1.length || i < nums2.length) {
        if(i < nums1.length) {
            hash[nums1[i]] = hash[nums1[i]] || [];
            hash[nums1[i]][0] = true;
        }
        
        if(i < nums2.length) {
            hash[nums2[i]] = hash[nums2[i]] || [];
            hash[nums2[i]][1] = true;
        }

        i++
    }
    
    for(i in hash) {
        if(hash[i][0] && hash[i][1]) {
            result.push(parseInt(i));
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>35 Search Insert Position.js</h3>
<a name="35-search-insert-position-js"></a>
<pre>
// Leetcode 35
// Language: Javascript
// Problem: https://leetcode.com/problems/search-insert-position/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    var left = 0;
    var right = nums.length - 1;
    
    while(left <= right){
        var mid = parseInt((left + right)/2);
        
        var val = nums[mid];
        
        if(val === target){
            return mid;
        } else if(val > target){
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    if(nums[left] < target){
        return left + 1;
    } else {
        return left;
    }
};
</pre>
<hr />
</div>

<div>
<h3>350 Intersection of Two Arrays II.js</h3>
<a name="350-intersection-of-two-arrays-ii-js"></a>
<pre>
// Given two arrays, write a function to compute their intersection.

// Example:
// Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].

// Note:
// Each element in the result should appear as many times as it shows in both arrays.
// The result can be in any order.
// Follow up:
// What if the given array is already sorted? How would you optimize your algorithm?
// What if nums1's size is small compared to nums2's size? Which algorithm is better?
// What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
// Hide Tags Binary Search Hash Table Two Pointers Sort
// Hide Similar Problems (E) Intersection of Two Arrays



/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
    var hash = {};
    var arr1, arr2;

    if(nums1.length > nums2.length) {
        arr1 = nums2;
        arr2 = nums1;
    } else {
        arr1 = nums1;
        arr2 = nums2;
    }

    var count = arr1.length;
    var result = [];
    
    for(var i = 0; i < arr1.length; i++) {
        hash[arr1[i]] = hash[arr1[i]] || 0;
        hash[arr1[i]]++;
    }
    
    for(i = 0; i < arr2.length && count !== 0; i++) {
        if(hash[arr2[i]] > 0) {
            hash[arr2[i]]--;
            count--;
            result.push(arr2[i]);
        }
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>353 Design Snake Game.js</h3>
<a name="353-design-snake-game-js"></a>
<pre>
// Design a Snake game that is played on a device with screen size = width x height. Play the game online if you are not familiar with the game.

// The snake is initially positioned at the top left corner (0,0) with length = 1 unit.

// You are given a list of food's positions in row-column order. When a snake eats the food, its length and the game's score both increase by 1.

// Each food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake.

// When a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.

// Example:
// Given width = 3, height = 2, and food = [[1,2],[0,1]].

// Snake snake = new Snake(width, height, food);

// Initially the snake appears at position (0,0) and the food at (1,2).

// |S| | |
// | | |F|

// snake.move("R"); -> Returns 0

// | |S| |
// | | |F|

// snake.move("D"); -> Returns 0

// | | | |
// | |S|F|

// snake.move("R"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )

// | |F| |
// | |S|S|

// snake.move("U"); -> Returns 1

// | |F|S|
// | | |S|

// snake.move("L"); -> Returns 2 (Snake eats the second food)

// | |S|S|
// | | |S|

// snake.move("U"); -> Returns -1 (Game over because snake collides with border)

// Credits:
// Special thanks to @elmirap for adding this problem and creating all test cases.

// Hide Company Tags Google
// Hide Tags Design Queue



public class SnakeGame {

    /** Initialize your data structure here.
        @param width - screen width
        @param height - screen height 
        @param food - A list of food positions
        E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */
        
    private Set<String> board = new HashSet<>();
    private int[][] food;
    private int eat = 0;
    private LinkedList<Position> snake = new LinkedList<>();
    private int width, height;
        
        
    private boolean eat(int y, int x) {
        if(eat >= food.length) {
            return false;
        }
        if(food[eat][0] < 0 || food[eat][0] >= height || food[eat][1] <0 || food[eat][1] >= width) {
            return false;
        }
        if(y == food[eat][0] && x == food[eat][1]) {
            return true;
        }
        
        return false;
    }
        
        
    public SnakeGame(int width, int height, int[][] food) {
        this.food = food;
        Position head = new Position(0,0);
        this.snake.add(head);
        board.add(head.toString());
        this.height = height;
        this.width = width;
    }
    
    /** Moves the snake.
        @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down 

        @return The game's score after the move. Return -1 if game over. 
        Game over when snake crosses the screen boundary or bites its body. */
    public int move(String direction) {
        Position head = snake.getFirst();
        Position next = new Position(head.y, head.x);
        
        if("U".equals(direction)) {
            next.y--;
        } else if("D".equals(direction)) {
            next.y++;
        } else if("L".equals(direction)) {
            next.x--;
        } else if("R".equals(direction)) {
            next.x++;
        } else {
            return -1;
        }
        
        if(next.y < 0 || next.y >= height || next.x < 0 || next.x >= width) {
            return -1;
        }
        
        String ns = next.toString();
        if(eat(next.y, next.x)) {
            snake.addFirst(next);
            board.add(ns);
            return ++eat;
        }
        
        Position tail = snake.getLast();
        board.remove(tail.toString());
        snake.removeLast();
        
        if(board.contains(ns)) {
            return -1;
        }
        
        snake.addFirst(next);
        board.add(ns);
        return eat;
    }
}

class Position {
    int x, y;
    
    Position(int y, int x) {
        this.y = y;
        this.x = x;
    }
    
    public String toString() {
        return y + "," + x;
    }
}

/**
 * Your SnakeGame object will be instantiated and called as such:
 * SnakeGame obj = new SnakeGame(width, height, food);
 * int param_1 = obj.move(direction);
 */
</pre>
<hr />
</div>

<div>
<h3>36 Valid Sudoku.js</h3>
<a name="36-valid-sudoku-js"></a>
<pre>
/**
 * @param {character[][]} board
 * @return {boolean}
 */
var isValidSudoku = function(board) {
    // col
    for(var i = 0; i < board.length; i++){
        var dupCheck = [];
        
        for(var j = 0; j < board[0].length; j++){
            if(board[i][j] !== '.' && dupCheck[board[i][j]]){
                return false;
            } else {
                dupCheck[board[i][j]] = true;
            }
        }
    }
    
    for(i = 0; i < board.length; i++){
        dupCheck = [];
        
        for(j = 0; j < board[0].length; j++){
            if(board[j][i] !== '.' && dupCheck[board[j][i]]){
                return false;
            } else {
                dupCheck[board[j][i]] = true;
            }
        }
    }
    
    for(i = 0; i < board.length; i+=3){
        for(j = 0; j < board.length; j+=3){
            dupCheck = [];
            
            for(var x = 0; x < 3; x++){
                for(var y = 0; y < 3; y++){
                    if(board[i+x][j+y] !== '.' && dupCheck[board[i+x][j+y]]){
                        return false;
                    } else {
                        dupCheck[board[i+x][j+y]] = true;
                    }
                }
            }
        }
    }
    
    return true;
  
  
    
};
</pre>
<hr />
</div>

<div>
<h3>364 Nested List Weight Sum II.js</h3>
<a name="364-nested-list-weight-sum-ii-js"></a>
<pre>
// Given a nested list of integers, return the sum of all integers in the list weighted by their depth.

// Each element is either an integer, or a list -- whose elements may also be integers or other lists.

// Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.

// Example 1:
// Given the list [[1,1],2,[1,1]], return 8. (four 1's at depth 1, one 2 at depth 2)

// Example 2:
// Given the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17)

// Hide Company Tags LinkedIn
// Show Tags
// Show Similar Problems

/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * function NestedInteger() {
 *
 *     Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     @return {boolean}
 *     this.isInteger = function() {
 *         ...
 *     };
 *
 *     Return the single integer that this NestedInteger holds, if it holds a single integer
 *     Return null if this NestedInteger holds a nested list
 *     @return {integer}
 *     this.getInteger = function() {
 *         ...
 *     };
 *
 *     Return the nested list that this NestedInteger holds, if it holds a nested list
 *     Return null if this NestedInteger holds a single integer
 *     @return {NestedInteger[]}
 *     this.getList = function() {
 *         ...
 *     };
 * };
 */
/**
 * @param {NestedInteger[]} nestedList
 * @return {number}
 */
var depthSumInverse = function(nestedList) {
    
    function getDepth(arr, lvl) {
        var maxDepth = lvl;
        
        for(var i = 0; i < arr.length; i++) {
            if(!arr[i].isInteger()) {
                // maxDepth represents the max depth at that level, 
                // e.g. [[[[55]]],[[31]],[99],[],75]
                // at lvl 1, we want to know which [[[55]]], [[31]], [99], [], 75
                // has the maxDepth
                maxDepth = Math.max(maxDepth, getDepth(arr[i].getList(), lvl + 1));
            }
        }
        
        return maxDepth;
    }
        
    var depth = getDepth(nestedList, 1);
    
    function traverse(arr, lvl) {
        var sum = 0;
        
        for(var i = 0; i < arr.length; i++) {
            if(arr[i].isInteger()) {
                sum += arr[i].getInteger()*lvl;
            } else {
                sum += traverse(arr[i].getList(), lvl - 1);
            }
        }
        
        return sum;
    }
    
    return traverse(nestedList, depth);
};
</pre>
<hr />
</div>

<div>
<h3>366 Find Leaves of Binary Tree.js</h3>
<a name="366-find-leaves-of-binary-tree-js"></a>
<pre>
// Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.

// Example:
// Given binary tree 
//           1
//          / \
//         2   3
//        / \     
//       4   5    
// Returns [4, 5, 3], [2], [1].

// Explanation:
// 1. Removing the leaves [4, 5, 3] would result in this tree:

//           1
//          / 
//         2          
// 2. Now removing the leaf [2] would result in this tree:

//           1          
// 3. Now removing the leaf [1] would result in the empty tree:

//           []         
// Returns [4, 5, 3], [2], [1].

// Credits:
// Special thanks to @elmirap for adding this problem and creating all test cases.

// Hide Company Tags LinkedIn
// Hide Tags Tree Depth-first Search



/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var findLeaves = function(root) {
    var result = [];
    
    while(root) {
        var leaves = []
        root = removeLeaves(root, leaves);
        result.push(leaves);
    }
    
    return result;
};

function removeLeaves(node, leaves) {
    if(!node) {
        return null;
    }
    
    if(!node.left && !node.right) {
        leaves.push(node.val);
        return null;
    }
    
    node.left = removeLeaves(node.left, leaves);
    node.right = removeLeaves(node.right, leaves);
    
    return node;
}
</pre>
<hr />
</div>

<div>
<h3>367 Valid Perfect Square.js</h3>
<a name="367-valid-perfect-square-js"></a>
<pre>
// Given a positive integer num, write a function which returns True if num is a perfect square else False.

// Note: Do not use any built-in library function such as sqrt.

// Example 1:

// Input: 16
// Returns: True
// Example 2:

// Input: 14
// Returns: False
// Credits:
// Special thanks to @elmirap for adding this problem and creating all test cases.

// Hide Company Tags LinkedIn
// Show Tags
// Show Similar Problems


/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
    var left = 0;
    var right = num;
    
    while(left <= right) {
        var mid = left + parseInt((right - left)/2);
        var pow = mid*mid;
        if(pow === num) {
            return true;
        } else if(pow < num) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;  
};
</pre>
<hr />
</div>

<div>
<h3>37 Sudoku Solver.js</h3>
<a name="37-sudoku-solver-js"></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>371 Sum of Two Integers.js</h3>
<a name="371-sum-of-two-integers-js"></a>
<pre>
// Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

// Example:
// Given a = 1 and b = 2, return 3.

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
    while(b !== 0) {
        
        // 100
        // 101
        
        // carry = a&b and carry << 1 will give 1 in the front
        // a^b will give 001 which is addition.
        // b now will become 1000 and we just need to do this one more time then we get the answer.
        var carry = a & b;
        a ^= b;
        b = carry << 1;
    }
    
    return a;
};
</pre>
<hr />
</div>

<div>
<h3>38 Count and Say.js</h3>
<a name="38-count-and-say-js"></a>
<pre>
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    if(n === null || n.length === 0){
        return "";
    }
    
    var cur = "1";
    var num = 1;
    
    while(n > 1){
        var r = "";
        
        for(var i = 0; i < cur.length; i++){
            if(i < cur.length - 1 && cur[i] === cur[i+1]){
                num++;
            } else {
                r += (num + "" + cur[i]);
                num = 1;
            }
        }
        
        cur = r;
        n--;
    }
    return cur;   
};


// var countAndSay = function(n) {
//     var str = '1';
    
//     for(var i = 1; i < n; i++) {
//         var newStr = '';
//         var count = 1;

//         for(var j = 1; j < str.length; j++) {
//             if(str[j] === str[j - 1]) {
//                 count++;
//             } else {
//                 newStr += count + str[j - 1];
//                 count = 1;
//             }
//         }
        
//         newStr += count + str[j - 1];
//         str = newStr;
//     }

//     return str;
// };


</pre>
<hr />
</div>

<div>
<h3>39 Combination Sum.js</h3>
<a name="39-combination-sum-js"></a>
<pre>
// Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

// The same repeated number may be chosen from C unlimited number of times.

// Note:
// All numbers (including target) will be positive integers.
// The solution set must not contain duplicate combinations.
// For example, given candidate set [2, 3, 6, 7] and target 7,
// A solution set is:
// [
//   [7],
//   [2, 2, 3]
// ]
// Hide Company Tags Snapchat Uber
// Hide Tags Array Backtracking
// Hide Similar Problems (M) Letter Combinations of a Phone Number (M) Combination Sum II (M) Combinations (M) Combination Sum III (M) Factor Combinations (M) Combination Sum IV



/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    var result = [];

    if(candidates === null || candidates.length === 0){
        return result;
    }

    candidates.sort(function(a,b){return a > b ? 1 : -1});

    var output = [];

    generate(candidates, result, output, target, 0);

    return result;
};

var generate = function(candidates, result, output, sum, index){
    if(sum === 0){
        result.push(output.slice());
    }
    if(sum < 0){
        return;
    }

    for(var i = index; i < candidates.length; i++){
        if(i > index && candidates[i] === candidates[i - 1]){
            continue;
        }

        if(candidates[i] <= sum){
            output.push(candidates[i]);
            generate(candidates, result, output, sum - candidates[i], i);
            output.pop();
        }
    }
}


// Another solution
var combinationSum = function(candidates, target) {
    var results = [];
    comb(candidates.sort(), 0, [], 0, target, results);
    return results;
};

var comb = function(cand, index, partial, partialSum, target, results) {
    if(target === partialSum) {
        results.push(partial);
        return;
    }
    if(cand.length === index || partialSum > target) {
        return;
    }
    comb(cand, index, partial.concat([cand[index]]), 
         partialSum + cand[index], target, results);
    comb(cand, index + 1, partial, partialSum, target, results);
};

</pre>
<hr />
</div>

<div>
<h3>4. Median of Two Sorted Arrays.js</h3>
<a name="4-median-of-two-sorted-arrays-js"></a>
<pre>
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
 
// http://blog.csdn.net/yutianzuijin/article/details/11499917
var findMedianSortedArrays = function(nums1, nums2) {
    var m = nums1.length;
    var n = nums2.length;
    var total = m + n;
    
    if(total%2 === 1) {
        return findKth(nums1, m, nums2, n, parseInt(total/2) + 1);
    } else {
        return (findKth(nums1, m, nums2, n, parseInt(total/2)) + findKth(nums1, m, nums2, n, parseInt(total/2) + 1))/2;
    }
};


function findKth(a, m, b, n, k) {
    // always assume that m is equal or smaller than n
    if(m > n) {
        return findKth(b, n, a, m, k);
    }
    
    if(m === 0) {
        return b[k-1];
    }
    
    if(k === 1) {
        return Math.min(a[0],b[0]);
    }
    
    // divide k into two parts
    var pa = Math.min(parseInt(k/2), m);
    var pb = k - pa;
    
    if(a[pa - 1] < b[pb - 1]) {
        return findKth(a.slice(pa), m - pa, b, n, k - pa);
    } else if(a[pa - 1] > b[pb - 1]) {
        return findKth(a, m, b.slice(pb), n - pb, k - pb);
    } else {
        return a[pa - 1];
    }
}
</pre>
<hr />
</div>

<div>
<h3>40 combination Sum II.js</h3>
<a name="40-combination-sum-ii-js"></a>
<pre>
// Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

// Each number in C may only be used once in the combination.

// Note:
// All numbers (including target) will be positive integers.
// The solution set must not contain duplicate combinations.
// For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, 
// A solution set is: 
// [
//   [1, 7],
//   [1, 2, 5],
//   [2, 6],
//   [1, 1, 6]
// ]
// Hide Tags Array Backtracking
// Hide Similar Problems (M) Combination Sum



/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    var result = [];
    
    if(candidates === null || candidates.length === 0){
        return result;
    }
    
    var output = [];
    candidates.sort(function(a,b){return a > b ? 1 : -1;});
    generate(candidates, target, 0, result, output);
    
    return result;
};

var generate = function(c, t, index, result, output){
    if(t < 0){
        return;
    }
    if(t === 0){
        result.push(output.slice());
        return
    }
    
    for(var i = index; i < c.length; i++){
        if(i > index && c[i] === c[i-1]) {
            continue;
        }
        var val = c[i];

        output.push(val);
        generate(c, t - val, i + 1, result, output);
        output.pop();
    }
}
</pre>
<hr />
</div>

<div>
<h3>42 Trapping Rain Water.js</h3>
<a name="42-trapping-rain-water-js"></a>
<pre>
// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

// For example, 
// Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.


// The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!


// http://bangbingsyb.blogspot.com/2014/11/leetcode-trapping-rain-water.html

/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
    // scan left max
    // scan right max
    // e.g. heights:  0 3 2 1 5 1
    // left max:      0 0 3 3 3 5
    // right max:     5 5 5 5 1 0
    // what that means is?
    // for index 1 -> height 3
    // 0 is its left max, 5 is its right max -> that gives zero volumn as it cannot hold water
    // for index 2 -> height 2
    // 3 is its left max and 5 is its right max -> min(3,5) = 3 and height 2 is the bottom of the water bed, so that gives (3-2) -> 1 volumn of water
    
    var leftMax = [];
    var rightMax=  [];
    var water = 0;
    
    // to get the left of i so we do i - 1
    for(var i = 1; i < height.length; i++) {
        leftMax[i] = leftMax[i] || 0;
        leftMax[i] = Math.max(leftMax[i - 1] || 0, height[i - 1]);
    }
    
    for(i = height.length - 2; i >= 0; i--) {
        rightMax[i] = rightMax[i] || 0;
        rightMax[i] = Math.max(rightMax[i + 1] || 0, height[i + 1]);
        
        var minHeight = Math.min(leftMax[i], rightMax[i]);
        var waterBottom = height[i];
        if(minHeight > waterBottom) {
            water += (minHeight - waterBottom);    
        }
    }
    
    return water;
};
</pre>
<hr />
</div>

<div>
<h3>43 Multiply Strings.js</h3>
<a name="43-multiply-strings-js"></a>
<pre>
// Given two numbers represented as strings, return multiplication of the numbers as a string.

// Note:
// The numbers can be arbitrarily large and are non-negative.
// Converting the input string to integer is NOT allowed.
// You should NOT use internal library such as BigInteger.
// Hide Company Tags Facebook Twitter
// Hide Tags Math String
// Hide Similar Problems (M) Add Two Numbers (E) Plus One (E) Add Binary

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function(num1, num2) {
    if(num1 === null || num2 === null || num1.length === 0 || num2.length === 0 || num1 === '0' || num2 === '0') {
        return '0';
    }
    
    var arr1 = num1.split('').reverse();
    var arr2 = num2.split('').reverse();
    var result = [];
    
    for(var i = 0; i < arr1.length; i++) {
        var carry = 0;
        var val1 = parseInt(arr1[i]);
        
        for(var j = 0; j < arr2.length; j++) {
            var val2 = parseInt(arr2[j]);
            var product = val1*val2 + carry;
            var exist = result[i+j] || 0;
            var sum = product + exist;
            var digit = sum%10;
            carry = Math.floor(sum/10);
            result[i+j] = digit;
        }
        
        if(carry > 0) {
            result[i+j] = carry;
        }
    }
    
    result.reverse();
    result = result.join('');
    
    return result;
};

multiply('123', '456')
</pre>
<hr />
</div>

<div>
<h3>44 Wildcard Matching.js</h3>
<a name="44-wildcard-matching-js"></a>
<pre>
// Implement wildcard pattern matching with support for '?' and '*'.

// '?' Matches any single character.
// '*' Matches any sequence of characters (including the empty sequence).

// The matching should cover the entire input string (not partial).

// The function prototype should be:
// bool isMatch(const char *s, const char *p)

// Some examples:
// isMatch("aa","a") ? false
// isMatch("aa","aa") ? true
// isMatch("aaa","aa") ? false
// isMatch("aa", "*") ? true
// isMatch("aa", "a*") ? true
// isMatch("ab", "?*") ? true
// isMatch("aab", "c*a*b") ? false
// Hide Company Tags Google Snapchat Facebook
// Hide Tags Dynamic Programming Backtracking Greedy String
// Hide Similar Problems (H) Regular Expression Matching



/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
 
var matchChar = function(c, p){
    return (p === '?' || p === c);
}
var isMatch = function(s, p) {
    if(s === null || p === null)   {
        return false;
    }
    
    var idxS = 0;
    var idxP = 0;
    
    var lenS = s.length;
    var lenP = p.length;
    
    var back = false;
    var preS = 0;
    var preP = 0;
    
    while(idxS < lenS) {
        var charS = s[idxS];
        var charP = p[idxP];

        if(idxP < lenP && matchChar(s[idxS], p[idxP])) {
            idxP++;
            idxS++;
        } else if(idxP < lenP && p[idxP] === '*') {
            while(idxP < lenP && p[idxP] === '*') {
                idxP++;
            }
            
            back = true;
            preS = idxS;
            preP = idxP;
        } else if(back) {
        // since * means any sequence including ''. We can use greedy approach
        // str = "abefcdgiescdfimde" pattern = "ab*cd?i*de"
        // first * is "ef" first ? is "g" second * is escdfim
            idxS = ++preS;
            idxP = preP;
        // preP is the pattern index after *
        // even idxP got advanced by first the condition idxP < lenP && matchChar(s[idxS], p[idxP])
        // when the first and second condition don't work out, we backtrack of using the last wild card position.
        } else {
            return false;
        }
    }
    
    while(idxP < lenP && p[idxP] === '*') {
        idxP++;
    }
    
    if(idxS === lenS && idxP === lenP) {
        return true;
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>45 Jump Game II.js</h3>
<a name="45-jump-game-ii-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    var curMax = 0;
    var nJumps = 0;
    var i = 0;
    var n = nums.length;
    
    while(curMax < n - 1) {
        var lastMax = curMax;
        // go through covered area
        for(; i <= lastMax; i++) {
            curMax = Math.max(curMax, i+nums[i]);
        }
        nJumps++;
        // if cannot make progress in the covered area, give up
        if(lastMax === curMax) {
            return -1;
        }
    }
    
    return nJumps;
};
</pre>
<hr />
</div>

<div>
<h3>46 Permutations.js</h3>
<a name="46-permutations-js"></a>
<pre>
// Leetcode 46
// Language: Javascript
// Problem: https://leetcode.com/problems/permutations/
// Author: Chihung Yu
/**
 * @param {number[]} nums
 * @return {number[][]}
 */

var permute = function(nums) {
    var result = [];
    generatePermute(nums, [], result);
    
    return result;
};

var generatePermute = function(nums, currentResult, finalResult) {
    if(nums.length === 0) {
        finalResult.push(currentResult.slice());
        return;
    }
    
    for(var i = 0; i < nums.length; i++) {
        var num = nums[i];
        
        currentResult.push(num);
        var newNums = nums.slice(0, i).concat(nums.slice(i + 1));
        generatePermute(newNums, currentResult, finalResult);
        currentResult.pop();
    }
}

// can be optimized by using an array to keep track of visited elements in the array which ultimately cut down the time slicing array
// consider array is of size n -> n^2 vs n! 


var permute = function(nums) {
    var result = [];
    var visited = [];
    
    generate(nums, 0, visited, [], result);
    
    return result;
};

var generate = function(nums, index, visited, output, result) {
    if(nums.length === output.length) {
        result.push(output.slice());
        return;
    }
    
    for(var i = 0; i < nums.length; i++) {
        if(!visited[i]) {
            visited[i] = true;
            output.push(nums[i]);
            generate(nums, index+1, visited, output, result);    
            output.pop();
            visited[i] = false;
        }
        
    }
}


// Another clear solution
var permute = function(nums) {
    return permuteAux(nums, []);
};

var permuteAux = function(nums, partialNums) {
  if(nums === null || nums.length === 0) {
      return [partialNums];
  }
  var listArrays = [];
  for(var i = 0; i < nums.length; i++) {
      var withoutI = nums.slice(0,i).concat(nums.slice(i + 1, nums.length));
      var partial = partialNums.concat([nums[i]]);
      var sol = permuteAux(withoutI, partial);
      if(sol.legnth !== 0) {
        listArrays = listArrays.concat(sol);
      }
  }
  return listArrays;
};






</pre>
<hr />
</div>

<div>
<h3>47 Permutations II.js</h3>
<a name="47-permutations-ii-js"></a>
<pre>
// Given a collection of numbers that might contain duplicates, return all possible unique permutations.

// For example,
// [1,1,2] have the following unique permutations:
// [
//   [1,1,2],
//   [1,2,1],
//   [2,1,1]
// ]
// Hide Company Tags LinkedIn Microsoft
// Show Tags
// Hide Similar Problems (M) Next Permutation (M) Permutations (M) Palindrome Permutation II


/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
    nums.sort((a,b)=> a > b ? 1 : -1);
    
    var result = [];
    var visited = Array(nums.length).fill(false);
    generatePermute(nums, 0, [], visited, result);
    
    return result;
};


var generatePermute = function(nums, step, currentResult, visited, finalResult) {
    // Since we might have duplicate and skipped some nums, so the currentResult.length might not equal to nums.length even when we are already done traversing
    // if(nums.length === currentResult.length) {
    if(step === nums.length) {
        finalResult.push(currentResult.slice());
        return;
    }
    
    for(var i = 0; i < nums.length; i++) {
        if(!visited[i]) {
            // !!! important: nums[i] === nums[i-1] && !visited[i-1]
            if(i > 0 && nums[i] === nums[i-1] && !visited[i-1]) {
                continue;
            }
                
            visited[i] = true;
            var num = nums[i];
            currentResult.push(num);
            generatePermute(nums, step + 1, currentResult, visited, finalResult);
            currentResult.pop();
            visited[i] = false;
        }
    }
}

//Another Solution, similar approach that Permutation.js
var permuteUnique = function(nums) {
    return permut(nums.sort(), []);
};

var permut = function(nums, partial) {
    if(nums.length === 0) {
        return [partial];
    }
    var listSol = [];
    for(var i = 0; i < nums.length; i++) {
        var endRepeated = i;
        while(endRepeated < nums.length && nums[i] === nums[endRepeated]) {
            endRepeated++;
        }
        
        var arrayWithoutI = nums.slice(0,i).concat(nums.slice(i + 1, nums.length));
        var partialSol = partial.concat([nums[i]]);
        var sol = permut(arrayWithoutI, partialSol);
        if(sol.length > 0){
            listSol = listSol.concat(sol);
        }
        i = endRepeated - 1;
    }
    return listSol;
};


</pre>
<hr />
</div>

<div>
<h3>48 Rotate Image.js</h3>
<a name="48-rotate-image-js"></a>
<pre>
// You are given an n x n 2D matrix representing an image.

// Rotate the image by 90 degrees (clockwise).

// Follow up:
// Could you do this in-place?

/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function(matrix) {
    var row = matrix.length;

    if(row === 0) {
        return;
    }

    var col = matrix[0].length;

    // swap them in diagonal
    for(var i = 0; i < row; i++) {
        for(var j = 0; j < col - i; j++) {
            swap(matrix, i, j, row - 1 - j, col  - 1 - i);
        }
    }

    // swap in middle
    for(i = 0; i < Math.floor(row/2); i++) {
        for(j = 0; j < col; j++) {
            swap(matrix, i, j, row - 1 - i, j);
        }
    }
};

function swap(matrix, x1, y1, x2, y2) {
    var tmp = matrix[x1][y1];
    matrix[x1][y1] = matrix[x2][y2];
    matrix[x2][y2] = tmp;
}

//Clearer Solution
var rotate = function(matrix) {
    rotateColumns(matrix);
    rotateEachDiagonal(matrix);
};

var rotateColumns = function(matrix) {
    for(var j = 0; j < matrix.length; j++) {
        var low = 0;
        var ceil = matrix.length -1;
        while(low < ceil) {
            swap(matrix, low, j, ceil, j);
            low++;
            ceil--;
        }
    }
};

var rotateEachDiagonal = function(matrix){
    for(var i = 0; i < matrix.length; i++) {
        for(var j = i; j < matrix.length; j++) {
            swap(matrix, i, j, j, i);
        }
    }
};

var swap = function(matrix, i1, j1, i2, j2) {
    var aux = matrix[i1][j1];
    matrix[i1][j1] = matrix[i2][j2];
    matrix[i2][j2] = aux;
};


</pre>
<hr />
</div>

<div>
<h3>49 Anagrams.js</h3>
<a name="49-anagrams-js"></a>
<pre>
/**
 * @param {string[]} strs
 * @return {string[]}
 */
var anagrams = function(strs) {
    var result = [];
    var hash = {};
    var keyList = {};
    
    for(var i = 0; i < strs.length; i++){
        var str = strs[i];
        var key = getKey(str);
        
        if(hash[key]){
            keyList[key] = true;
        } else {
            hash[key] = [];
        }
        
        hash[key].push(str);
    }
    
    for(i in keyList){
        result = result.concat(hash[i]);
    }
    
    return result;
};

var getKey = function(str){
    var key = ""
    var arr = [];
    for(var i = 0; i < str.length; i++){
        var val = str.charCodeAt(i) - 'a'.charCodeAt(0);
        arr[val] = arr[val] || 0;
        arr[val]++;
    }
    
    return arr.join('_');
}
</pre>
<hr />
</div>

<div>
<h3>49 Group Anagrams.js</h3>
<a name="49-group-anagrams-js"></a>
<pre>
// Given an array of strings, group anagrams together.

// For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
// Return:

// [
//   ["ate", "eat","tea"],
//   ["nat","tan"],
//   ["bat"]
// ]
// Note: All inputs will be in lower-case.
/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    var hash = {};
    
    for(var i = 0; i < strs.length; i++) {
        var str = strs[i];
        
        var key = sort(str);
        
        hash[key] = hash[key] || [];
        hash[key].push(str);
    }
    
    var result = [];
    for(i in hash) {
        result.push(hash[i]);
    }
    
    return result;
};


var sort = function(s) {
    var arr = s.split('');
    
    arr.sort((a,b)=> a > b ? 1 : -1);
    return arr.join('');
}



// Use bucket sort, much faster

/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    var hash = {};
    var base = 'a'.charCodeAt(0);
    
    for(var i = 0; i < strs.length; i++) {
        var arr = Array(26).fill(0);
        for(var j = 0; j < str.length; j++) {
            var code = str[j].charCodeAt(0) - base;
            arr[code]++;
        }

        var key = arr.join('');
        hash[key] = hash[key] || [];
        hash[key].push(strs[i]);
    }
    
    var res = [];
    
    for(i in hash) {
        res.push(hash[i]);
    }
    
    return res;
};

</pre>
<hr />
</div>

<div>
<h3>5 Longest Palindromic Substring.js</h3>
<a name="5-longest-palindromic-substring-js"></a>
<pre>
// Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
// Amazon Microsoft Bloomberg
// Show Tags
// Show Similar Problems

/**
 * @param {string} s
 * @return {string}
 */



var longestPalindrome = function(s) {
    if(s === null || s.length === 0){
        return "";
    }    
    
    var result = "";

    // The reason to multiply by 2 is because 
    // Palindrome can be in two forms
    // 1. abba There will be case which center has two idenitical charachter,
    //   And there will be maximum 2*n - 1 such case
    // 2. aba There will be case which center has only one character
    var len = 2*s.length - 1;
    var left, right;
    
    for(var i = 0; i < len; i++){
        left = right = parseInt(i/2);
        if(i%2 === 1){
            right++;
        }
        
        var str = expandFromCenterAndCheckForPalindrome(s,left,right);
        
        if(str.length > result.length){
            result = str;
        }
    }
    return result;
};


// other implementation

var longestPalindrome = function(s) {
    if(s === null || s.length === 0){
        return "";
    }    
    
    var result = "";
    var len = s.length;
    var left, right;
    
    for(var i = 0; i < len; i++){
        left = right = i;

        var str = expandFromCenterAndCheckForPalindrome(s,left,right);
        if(str.length > result.length){
            result = str;
        }
        var str = expandFromCenterAndCheckForPalindrome(s,left,right + 1);
        if(str.length > result.length){
            result = str;
        }
    }
    return result;
};



var expandFromCenterAndCheckForPalindrome = function(s, left, right){
    // in the case where left !== right
    // that's the case "abba"
    // which it checks for if b === b then a === a

    // in the case where left === right
    // that's the case "aba"
    // which it check if b === b as left === right
    // then a === a 
    while(left >= 0 && right < s.length && s[left] === s[right]){
        left--;
        right++;
    }
    
    return s.substring(left+1, right);
}
</pre>
<hr />
</div>

<div>
<h3>50 Pow(x, n).js</h3>
<a name="50-pow-x-n-js"></a>
<pre>
/**
 * @param {number} x
 * @param {number} n
 * @return {number}
 */
 
//  http://blog.csdn.net/sunnyyoona/article/details/43273933
var myPow = function(x, n) {
    if(n < 0)   {
        return 1.0/myPow(x, -n);
    }
    if(n === 0) {
        return 1.0;
    }
    if(n === 1) {
        return x;
    }
    
    var sub = myPow(x, parseInt(n/2));
    return sub*sub*myPow(x, n%2);
};
</pre>
<hr />
</div>

<div>
<h3>51 N-Queens.js</h3>
<a name="51-n-queens-js"></a>
<pre>
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function(n) {
    var res = [];
    helper(n, 0, [], res);
    return res;
};

var helper = function(n, row, columnForRow, res){
    if(row === n){
        var item = [];
        
        for(var i = 0; i < n; i++){
            var strRow = "";
            for(var j = 0; j < n; j++){
                if(columnForRow[i] === j){
                    strRow += "Q";
                } else {
                    strRow += ".";
                }
            }
            
            item[i] = strRow;
        }
        
        res.push(item);
        return;   
    }
    
    for(i = 0; i < n; i++){
        columnForRow[row] = i;
        
        if(isValid(row, columnForRow)){
            helper(n, row + 1, columnForRow, res); 
        }
    }
}

var isValid = function(row, columnForRow){
    for(var i = 0; i < row; i++){
        // 1. don't have to worry about values on the same column since it will onnly be set once
        // 2. same column, columnForRow[row] === columnForRow[i]
        // 3. checking both left and right diagonal, Math.abs(columnForRow[row] - columnForRow[i]) === row - i
        //   Math.abs(columnForRow[row] - columnForRow[i]) is checking both left and right diagonal
        if(columnForRow[row] === columnForRow[i] || Math.abs(columnForRow[row] - columnForRow[i]) === row - i){
            return false;
        }
    }
    
    return true;
}
</pre>
<hr />
</div>

<div>
<h3>53 Maximum Subarray.js</h3>
<a name="53-maximum-subarray-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    var sum = 0;
    var maxSum = -Infinity;
    
    for(var i = 0; i < nums.length; i++){
        sum += nums[i];
        maxSum = Math.max(maxSum, sum);
        
        if(sum < 0){
            sum = 0;
        }
    }
    
    return maxSum;
};

</pre>
<hr />
</div>

<div>
<h3>532. K-diff Pairs in an Array.js</h3>
<a name="532-k-diff-pairs-in-an-array-js"></a>
<pre>
var findPairs = function(nums, k) {
  if(nums.length === 0 || k < 0) {
    return 0;
  }
  var dict = {};
  var count = 0;

  nums.sort(function(a,b){ return a - b });
  for(var i = 0; i < nums.length; i++) {
    var number = nums[i];
    dict[number] = (dict[number] === undefined)? 1 : dict[number] += dict[number];
  }
  for(var numb in dict) {
    numb = parseInt(numb);
    if(k === 0) {
      if(dict[numb] > 1) {
        count++;
      }
    } else if(dict[numb + k] !== undefined){
      count++;
    }
  }
  return count;
};

</pre>
<hr />
</div>

<div>
<h3>54 Spiral Matrix.js</h3>
<a name="54-spiral-matrix-js"></a>
<pre>
// Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

// For example,
// Given the following matrix:

// [
//  [ 1, 2, 3 ],
//  [ 4, 5, 6 ],
//  [ 7, 8, 9 ]
// ]
// You should return [1,2,3,6,9,8,7,4,5].

// Hide Company Tags Microsoft Google Uber
// Hide Tags Array
// Hide Similar Problems (M) Spiral Matrix II

/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
//  
var spiralOrder = function(matrix) {
    var result = [];
    
    if(matrix === null || matrix.length === 0 || matrix[0].length === 0){
        return result;
    }
    
    var rows = matrix.length;
    var cols = matrix[0].length;

    var x = 0;
    var y = 0;

    while(rows > 0 && cols > 0){
        if(rows === 1){
            for(var i = 0; i < cols; i++){
                result.push(matrix[x][y++]);
            }
            break;
        } else if(cols === 1){
            for(i = 0; i < rows; i++){
                result.push(matrix[x++][y]);
            }
            break;
        }
        
        for(i = 0; i < cols - 1; i++){
            result.push(matrix[x][y++]);
        }
        for(i = 0; i < rows - 1; i++){
            result.push(matrix[x++][y]);
        }
        for(i = 0; i < cols - 1; i++){
            result.push(matrix[x][y--]);
        }
        for(i = 0; i < rows - 1; i++){
            result.push(matrix[x--][y]);
        }
        
        x++;
        y++;
        cols -= 2;
        rows -= 2;
    }
    
    return result;
}
</pre>
<hr />
</div>

<div>
<h3>55 Jump Game.js</h3>
<a name="55-jump-game-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    var numLeft = nums[0]; 
    for(var i = 1; i < nums.length; i++){
        numLeft--;
        if(numLeft < 0){
            return false;
        }
        numLeft = Math.max(nums[i], numLeft);
    }
    
    return numLeft >= 0;
};
</pre>
<hr />
</div>

<div>
<h3>56. Merge Intervals.js</h3>
<a name="56-merge-intervals-js"></a>
<pre>
// Given a collection of intervals, merge all overlapping intervals.

// For example,
// Given [1,3],[2,6],[8,10],[15,18],
// return [1,6],[8,10],[15,18].

// Hide Company Tags LinkedIn Google Facebook Twitter Microsoft Bloomberg Yelp
// Hide Tags Array Sort
// Hide Similar Problems (H) Insert Interval (E) Meeting Rooms (M) Meeting Rooms II

 /**
  * Definition for an interval.
  * function Interval(start, end) {
  *     this.start = start;
  *     this.end = end;
  * }
  */
 /**
  * @param {Interval[]} intervals
  * @return {Interval[]}
  */


 var merge = function(intervals) {
     var res = [];
     
     intervals.sort((i1, i2) => i1.start > i2.start ? 1 : -1 );
     
     if(intervals.length) {
         res.push(intervals[0]);
     }
     
     for(var i = 1; i < intervals.length; i++) {
         var interval = intervals[i];
         var last = res.pop();
         
         if(interval.start > last.end) {
             res.push(last);
             res.push(interval);
         } else {
             last.end = Math.max(last.end, interval.end);
             res.push(last);
         }
     }
     
     return res;
 };
</pre>
<hr />
</div>

<div>
<h3>57. Insert Interval.js</h3>
<a name="57-insert-interval-js"></a>
<pre>
// Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

// You may assume that the intervals were initially sorted according to their start times.

// Example 1:
// Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

// Example 2:
// Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

// This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].

// Hide Company Tags LinkedIn Google Facebook
// Show Tags
// Show Similar Problems


/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @param {Interval} newInterval
 * @return {Interval[]}
 */
 
//  http://bangbingsyb.blogspot.com/2014/11/leetcode-insert-interval.html
var insert = function(intervals, newInterval) {
    var result = [];
    // Easier to consider if two sections are not overlapped
    // [s1, e1] [s2, e2] --> e2 < s1 or e1 < s2
    // once merged when two sections are overlapped, [min(s1,s2), max(e1,e2)]
    
    var isInsert = false;
    
    for(var i = 0; i < intervals.length; i++) {
        var interval = intervals[i];
        
        if(isInsert) {
            result.push(interval);
        } else if(newInterval.end < interval.start) { // insertion before the sorted interval
            result.push(newInterval);
            result.push(interval);
            isInsert = true;
        } else if(interval.end < newInterval.start) { // no overlap at all
            result.push(interval);
        } else {
            newInterval.start = Math.min(newInterval.start, interval.start);
            newInterval.end = Math.max(newInterval.end, interval.end);
        }
    }
     
    if(!isInsert) { // insertion at the very end;
        result.push(newInterval);
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>58 Length of Last Word.js</h3>
<a name="58-length-of-last-word-js"></a>
<pre>
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    if(s === null || s.length === 0){
        return 0;
    }
    
    var count = 0;
    
    for(var i = s.length; i--;){
        if(s[i] === ' '){
            if(count === 0){
                continue;
            } else {
                return count;
            }
        }
        
        count++;
    }
    
    return count;
};
</pre>
<hr />
</div>

<div>
<h3>59 Spiral Matrix II.js</h3>
<a name="59-spiral-matrix-ii-js"></a>
<pre>
// Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

// For example,
// Given n = 3,

// You should return the following matrix:
// [
//  [ 1, 2, 3 ],
//  [ 8, 9, 4 ],
//  [ 7, 6, 5 ]
// ]
// Hide Tags Array
// Hide Similar Problems (M) Spiral Matrix



/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
    var matrix = [];
    for(var i = 0; i < n; i++) {
        matrix.push([]);
    }
    var x = 0;
    var y = 0;
    var count = 1;
    
    while(0 < n) {
        if(n === 1) {
            matrix[x][y] = count;
            break;
        }
        
        for(i = 0; i < n - 1; i++) {
            matrix[x][y++] = count++;
        }
        
        for(i = 0; i < n - 1; i++) {
            matrix[x++][y] = count++;
        }
        
        for(i = 0; i < n - 1; i++) {
            matrix[x][y--] = count++;
        }
        
        for(i = 0; i < n - 1; i++) {
            matrix[x--][y] = count++;
        }
        
        x++;
        y++;
        n -= 2;
    }
    
    return matrix;
};
</pre>
<hr />
</div>

<div>
<h3>61 Rotate List.js</h3>
<a name="61-rotate-list-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var rotateRight = function(head, k) {
    if(head === null || k === 0){
        return head;
    }
    
    var dummy = new ListNode(-1);
    dummy.next = head;
    var p = head;
    
    var len = 1;
    
    while(p.next !== null){
        len++;
        p = p.next;
    }
    
    k = len - k%len;
    p.next = head;
    
    while(k > 0){
        p = p.next;
        k--;
    }
    
    head = p.next;
    p.next = null;
    return head;
};
</pre>
<hr />
</div>

<div>
<h3>62 Unique Paths.js</h3>
<a name="62-unique-paths-js"></a>
<pre>
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    if(m === 0 || n === 0){
        return 0;
    }
    
    var dp = [[1]];
    
    
    for(var i = 1; i < n; i++){
        dp[0][i] = 1;
    }
    
    for(var j = 1; j < m; j++){
        dp.push([]);
        dp[j][0] = 1;
    }
    
    for(i = 1; i < m; i++){
        for(j = 1; j < n; j++){
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }   
    
    console.log(dp);
    
    return dp[m-1][n-1];
}
</pre>
<hr />
</div>

<div>
<h3>63 Unique Paths II.js</h3>
<a name="63-unique-paths-ii-js"></a>
<pre>
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    if(obstacleGrid === null || obstacleGrid.length === 0 || obstacleGrid[0].length === 0){
        return 0;
    }
    
    var m = obstacleGrid.length;
    var n = obstacleGrid[0].length;
    
    if(m === 0 || n === 0){
        return 0;
    }
    
    if(obstacleGrid[0][0] === 1){
        return 0;
    }
    
    var dp = [[1]];
    
    for(var i = 1; i < n; i++){
        if(obstacleGrid[0][i] === 1){
            dp[0][i] = 0;
        } else if(dp[0][i-1] === 0){
            dp[0][i] = 0;
        } else{
            dp[0][i] = 1;
        }
    }
    
    for(var j = 1; j < m; j++){
        dp.push([]);
        if(obstacleGrid[j][0] === 1){
            dp[j][0] = 0;
        } else if(dp[j-1][0] === 0){
            dp[j][0] = 0;
        } else {
            dp[j][0] = 1;
        }
    }
    
    for(i = 1; i < m; i++){
        for(j = 1; j < n; j++){
            if(obstacleGrid[i][j] === 1){
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];    
            }
        }
    }   
    
    return dp[m-1][n-1];
};
</pre>
<hr />
</div>

<div>
<h3>64 Minimum Path Sum.js</h3>
<a name="64-minimum-path-sum-js"></a>
<pre>
/**
 * @param {number[][]} grid
 * @return {number}
 */
// var minPathSum = function(grid) {
//     if(grid === null || grid.length === 0 || grid[0].length === 0){
//         return 0;
//     }
    
//     var dp = [[]];
    
//     dp[0][0] = grid[0][0];
    
//     for(var i = 1; i < grid.length; i++){
//         dp.push([]);
//         dp[i][0] = grid[i][0] + dp[i - 1][0];
//     }
    
//     for(var j = 1; j < grid[0].length; j++){
//         dp[0][j] = grid[0][j] + dp[0][j - 1];
//     }
    
//     for(i = 1; i < grid.length; i++){
//         for(j = 1; j < grid[i].length; j++){
//             var val1 = dp[i - 1][j];
//             var val2 = dp[i][j - 1];
            
//             dp[i][j] = Math.min(val1, val2) + grid[i][j];
//         }
//     }
    
//     return dp[dp.length - 1][dp[0].length - 1];
// }


/**
 * @param {number[][]} triangle
 * @return {number}
 */

 // use only O(n) space
var minimumTotal = function(triangle) {
    var preResult = [];
    var rows = triangle.length;
    
    if(rows > 0) {
        preResult.push(triangle[0][0]);
    } else {
        return null;
    }
    
    for(var row = 1; row < rows; row++) {
        var curResult = [];
        
        for(var col = 0; col < triangle[row].length; col++) {
            var val;
            
            if(col === 0) {
                val = preResult[col];
            } else if(col === (triangle[row].length - 1)) {
                val = preResult[col-1];
            } else {
                val = Math.min(preResult[col-1], preResult[col]);
            }
        
            curResult[col] = triangle[row][col] + val;
        }
        
        preResult = curResult;
    }
    
    return Math.min.apply(null, preResult);
};
</pre>
<hr />
</div>

<div>
<h3>65 Valid Number.js</h3>
<a name="65-valid-number-js"></a>
<pre>
/**
 * @param {string} s
 * @return {boolean}
 */



// valid cases
// 9
// .9
// 9.
// 0.9
// 9e10
// 9e-10

// invalid case
// .
// ab
// 9ea10
// 9e
// e9
// .e1



// cannot use (\d*\.?\d*)\d+

var isNumber = function(s) {
    return !!s.match(/^\s*[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)(\e[+-]?\d+)?\s*$/);
};
</pre>
<hr />
</div>

<div>
<h3>66 Plus One.js</h3>
<a name="66-plus-one-js"></a>
<pre>
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    for(var i = digits.length; i--;){
        digits[i] = 1 + digits[i];
        
        if(digits[i] === 10){
            digits[i] = 0;
        } else {
            return digits;
        }
    }
    
    digits.unshift(1);
    
    
    return digits;
};
</pre>
<hr />
</div>

<div>
<h3>67 Add Binary.js</h3>
<a name="67-add-binary-js"></a>
<pre>
// Given two binary strings, return their sum (also a binary string).

// For example,
// a = "11"
// b = "1"
// Return "100".

// Hide Company Tags Facebook
// Hide Tags Math String
// Hide Similar Problems (M) Add Two Numbers (M) Multiply Strings (E) Plus One


/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    var lenA = a.length;
    var lenB = b.length;
    var ai = 0;
    var bi = 0;
    var sum = '';
    var carry = 0;
    while(ai < lenA || bi < lenB) {
        var valA = ai < lenA ? parseInt(parseInt(a[lenA - 1 - ai])) : 0;
        var valB = bi < lenB ? parseInt(parseInt(b[lenB - 1 - bi])) : 0;
        var val = valA + valB + carry;
        var rem = val%2;
        carry = val > 1 ? 1 : 0; 
        sum = rem + sum;
        ai++;
        bi++;
    }
    
    return carry > 0 ? carry + sum : sum;
};
</pre>
<hr />
</div>

<div>
<h3>68 Text Justification.js</h3>
<a name="68-text-justification-js"></a>
<pre>
// Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

// You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

// Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

// For the last line of text, it should be left justified and no extra space is inserted between words.

// For example,
// words: ["This", "is", "an", "example", "of", "text", "justification."]
// L: 16.

// Return the formatted lines as:
// [
//    "This    is    an",
//    "example  of text",
//    "justification.  "
// ]
// Note: Each word is guaranteed not to exceed L in length.
// http://bangbingsyb.blogspot.com/2014/11/leetcode-text-justification.html
/**
 * @param {string[]} words
 * @param {number} maxWidth
 * @return {string[]}
 */
var fullJustify = function(words, maxWidth) {
    var result = [];
    var start = 0;
    var end = -1;
    var currentWordsLen = 0;
    var i = 0;
    
    while(i < words.length) {
        if(words[i].size > maxWidth) {
            return result;
        }
        
        var newLen = currentWordsLen + (end - start + 1) + words[i].length; // current words len + their spaces + new word
        
        if(newLen <= maxWidth) { // words[i] can fit in the current line
            end = i;
            currentWordsLen += words[i].length;
            i++;
        } else {
            var line = createLine(words, maxWidth, start, end, currentWordsLen, false);
            result.push(line);
            start = i;
            end = i - 1;
            currentWordsLen = 0;
        }
    }
    
    var lastLine = createLine(words, maxWidth, start, end, currentWordsLen, true);
    result.push(lastLine);
    return result;
};


function createLine(words, maxWidth, start, end, currentWordsLen, isLast) {
    var result = '';
    if(start < 0 || end >= words.length) {
        return result;
    }
    
    result += words[start]; // consume the first word
    var numberOfWords = end - start + 1; // number of words to insert in this line
    
    // special case: one word or last line - left justified
    if(numberOfWords === 1 || isLast) {
        for(var i = start + 1; i <= end; i++) { // start from start + 1 since we already append the first word
            result += (" " + words[i]);
        }
        
        var remainingSpaces = maxWidth - currentWordsLen - (numberOfWords - 1);
        for(i = 0; i < remainingSpaces; i++) {
            result += ' ';
        }
        
        return result;
    }
    
    var k = parseInt((maxWidth - currentWordsLen)/(numberOfWords - 1));
    var m = (maxWidth - currentWordsLen)%(numberOfWords - 1);
    
    for(i = start + 1; i <= end; i++) { // start from start + 1 since we already append the first word
        var nspace = i - start <= m ? k + 1: k;
        
        for(var j = 0; j < nspace; j++) {
            result += ' ';    
        }
        
        result += words[i];
    }
    
    return result;
}
</pre>
<hr />
</div>

<div>
<h3>69 Sqrt(x).js</h3>
<a name="69-sqrt-x-js"></a>
<pre>
/**
Implement int sqrt(int x).

Compute and return the square root of x.
*/
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
    var start = 1,
        end = x,
        mid;
    
    if (x === 0) {
        return 0;
    }
    
    while (start + 1 < end) {
        mid = start + parseInt((end - start) / 2);
        
        if (mid * mid <= x) {
            start = mid;
        } else {
            end = mid;
        }
    }
    
    return start;
};



// http://www.cs.wustl.edu/~kjg/CS101_SP97/Notes/SquareRoot/sqrt.html

var mySqrtWithPrecision = function(digit, precision) {
    // Set initial guess to 1
    var guess = 1;
    var closeEnoughPrecision = Math.pow(0.1, precision + 1);

    while(true) {
        // difference between guess and real value
        // e.g. 5's sqrt = 2.236
        // val = x*x   sqrt = val/x
        // if we guess 3 as the sqrt of 5 -> 5/3 = 1.666 the difference between 3 and 1.6666 is 1.3333 and is way off
        // as it should be x*x = 5 and x here is 2.236
        var diff = Math.abs(guess - digit/guess);

        if(diff > closeEnoughPrecision) {
            // Better guess will be (3 + 1.66666)/2 => 2.3333
            guess = (guess + digit/guess)/2;
        } else {
            break;
        }
    }

    return guess;
}
</pre>
<hr />
</div>

<div>
<h3>70 Climbing Stairs.js</h3>
<a name="70-climbing-stairs-js"></a>
<pre>
// You are climbing a stair case. It takes n steps to reach to the top.

// Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    var n1 = 1;
    var n2 = 1;
    

    // n1 and n2 stands for how many ways it can reach n taking one step or two steps, such as n - 1 and n - 2
    for(var i = 2; i <= n; i++) {
        var ways = n1 + n2;
        n1 = n2;
        n2 = ways;
    }


    
    return n2;
};
</pre>
<hr />
</div>

<div>
<h3>71 Simplify Path.js</h3>
<a name="71-simplify-path-js"></a>
<pre>
// Given an absolute path for a file (Unix-style), simplify it.


// For example,
// path = "/home/", => "/home"
// path = "/a/./b/../../c/", => "/c"

/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function(path) {
    var arr = path.split('/');
    var result = [];
    
    for(var i = 0; i < arr.length; i++) {
        var p = arr[i];
        if(p === '..') {
            result.pop();
        } else if(p !== '' && p !== '.') {
            result.push(p);
        }
    }
    
    return '/' + result.join('/');
};
</pre>
<hr />
</div>

<div>
<h3>72 Edit Distance.js</h3>
<a name="72-edit-distance-js"></a>
<pre>
// reference: https://www.youtube.com/watch?v=We3YDTzNXEk

// Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

// You have the following 3 operations permitted on a word:

// a) Insert a character
// b) Delete a character
// c) Replace a character
// Hide Tags Dynamic Programming String
// Hide Similar Problems (M) One Edit Distance



/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    var len1 = word1.length,
        len2 = word2.length,
        matrix = [],
        i,
        j;
    
    if(len1 === 0 || len2 === 0) {
        return Math.max(len1, len2);
    }
    //initialization
    for(i = 0; i <= len1; i++) {
        matrix[i] = [];
        matrix[i][0] = i;
    }
    for (j = 0; j <= len2; j++) {
        matrix[0][j] = j;
    }
    
    for (i = 1; i <= len1; i++) {
        for (j = 1; j <= len2; j++) {
            if (word1.charAt(i - 1) === word2.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1;
            }
        }
    }
    return matrix[len1][len2];
};
</pre>
<hr />
</div>

<div>
<h3>74 Search a 2D Matrix.js</h3>
<a name="74-search-a-2d-matrix-js"></a>
<pre>
// Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

// Integers in each row are sorted in ascending from left to right.
// Integers in each column are sorted in ascending from top to bottom.
// For example,

// Consider the following matrix:

// [
//   [1,   4,  7, 11, 15],
//   [2,   5,  8, 12, 19],
//   [3,   6,  9, 16, 22],
//   [10, 13, 14, 17, 24],
//   [18, 21, 23, 26, 30]
// ]
// Given target = 5, return true.

// Given target = 20, return false.


/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */

var searchMatrix = function(matrix, target) {
    if(matrix === null || matrix.length === 0 || matrix[0].length === 0) {
        return false;
    }
    
    var rows = matrix.length;
    var cols = matrix[0].length;
    
    var y = cols - 1;
    
    for(var x = 0; x < rows; x++) {
        while(y && target < matrix[x][y]) {
            y--;
        }
        if(matrix[x][y] === target) {
            return true;
        }
    }

    return false;
};
</pre>
<hr />
</div>

<div>
<h3>75 Sort Colors.js</h3>
<a name="75-sort-colors-js"></a>
<pre>
// Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

// Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

// Note:
// You are not suppose to use the library's sort function for this problem.

// click to show follow up.

// Hide Company Tags Pocket Gems Microsoft Facebook
// Hide Tags Array Two Pointers Sort
// Hide Similar Problems (M) Sort List (M) Wiggle Sort (M) Wiggle Sort II

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
// var sortColors = function(nums) {
//     var redIndex = 0;
//     var blueIndex = nums.length - 1;
//     var red = 0;
//     var blue = 2;

//     for(var i = 0; i <= blueIndex; i++) {
//         if(nums[i] === red) {
//             swap(nums, redIndex, i);
//             redIndex++;
//         } else if(nums[i] === blue) {
//             swap(nums, blueIndex, i);
//             blueIndex--;
//             i--;
//         }
//     }
// };

// function swap(arr, i, j) {
//     if(i === j) {
//         return;
//     }
//     var tmp = arr[i];
//     arr[i] = arr[j];
//     arr[j] = tmp;
// }


var sortColors = function(nums) {
    var redIdx = 0;
    var blueIdx = nums.length - 1;
    var i = 0;
    
    while(i <= blueIdx) {
        if(nums[i] === 0) {
            swap(nums, i++, redIdx++);
        } else if(nums[i] === 2) {
            swap(nums, i, blueIdx--);
        } else {
            i++;
        }
    }
    
    function swap(nums, i, j) {
        var tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
};
</pre>
<hr />
</div>

<div>
<h3>76 Minimum Window Substring.js</h3>
<a name="76-minimum-window-substring-js"></a>
<pre>
// Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

// For example,
// S = "ADOBECODEBANC"
// T = "ABC"
// Minimum window is "BANC".

// Note:
// If there is no such window in S that covers all characters in T, return the empty string "".

// If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.

// Hide Company Tags LinkedIn Uber Facebook
// Hide Tags Hash Table Two Pointers String
// Hide Similar Problems


/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
 
// reference: http://www.cnblogs.com/TenosDoIt/p/3461301.html
var minWindow = function(s, t) {
    var lenS = s.length;
    var lenT = t.length;
    var queue = [];
    var tRequireCount = {};
    var tFoundCount = {};
    var hasFound = 0;
    var windowBeg = -1;
    var windowEnd = lenS;
    
    for(var i = 0; i < lenT; i++) {
        // init tFoundCount to all 0s
        tFoundCount[t[i]] = 0;
        // init tRequireCount to count of that character in t
        tRequireCount[t[i]] = tRequireCount[t[i]] || 0;
        tRequireCount[t[i]]++;
    }
  
    for(i = 0; i < lenS; i++) {
        if(tRequireCount[s[i]] > 0) {
            // use queue to skip a lot of redudant character
            // minWindow('aeeeeeebceeeeaeeedcb', 'abc');
            // queue will contain index
            // 1st round: [ 0, 7, 8 ] and then get rid of character at 0
            // 2nd round: [ 7, 8, 13 ] and get rid of character at 7
            // 3rd round: [ 8, 13, 18, 19 ]
            queue.push(i);
            tFoundCount[s[i]]++;
          
            // if found count is over require count, we don't need those extra, so don't record it to hasFound
            if(tFoundCount[s[i]] <= tRequireCount[s[i]]) {
                hasFound++;
            }
            
            // when the current location which is in queue
            if(hasFound === lenT) {
                var k;
              
                do {
                    k = queue.shift();
                    tFoundCount[s[k]]--;
                } while(tFoundCount[s[k]] >= tRequireCount[s[k]]);
                // moving to the minimum window location
              
                if(windowEnd - windowBeg > i - k) {
                    windowBeg = k;
                    windowEnd = i;
                    // window will be in
                    // 1st round 0 8 
                    // 2nd round 7 13
                }

                hasFound--;
            }
        }
    }
    
    return windowBeg !== -1 ? s.substring(windowBeg, windowEnd + 1) : '';
};
</pre>
<hr />
</div>

<div>
<h3>77 Combinations.js</h3>
<a name="77-combinations-js"></a>
<pre>
// Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

// For example,
// If n = 4 and k = 2, a solution is:

// [
//   [2,4],
//   [3,4],
//   [2,3],
//   [1,2],
//   [1,3],
//   [1,4],
// ]
// Hide Tags Backtracking
// Hide Similar Problems (M) Combination Sum (M) Permutations


/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    if(k === 0 || n === 0){
        return [];
    }
    
    var result = [];
    var output = [];
    generate(result, output, n, k, 1);
    
    return result;
};

var generate = function(result, output, n, k, cur){
    if(output.length === k){
        result.push(output.slice());
        return;
    }
    if(cur > n){
        return;
    }
    
    output.push(cur)
    generate(result, output, n, k, cur + 1);
    output.pop();
    generate(result, output, n, k, cur + 1);
}
</pre>
<hr />
</div>

<div>
<h3>78 Subsets.js</h3>
<a name="78-subsets-js"></a>
<pre>
// Given a set of distinct integers, nums, return all possible subsets.

// Note: The solution set must not contain duplicate subsets.

// For example,
// If nums = [1,2,3], a solution is:

// [
//   [3],
//   [1],
//   [2],
//   [1,2,3],
//   [1,3],
//   [2,3],
//   [1,2],
//   []
// ]


/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    var result = [];
    generate(nums, 0, [], result);
    return result;
};

var generate = function(nums, index, cur, result) {
    if(index === nums.length) {
        result.push(cur.slice());
        return
    }

    generate(nums, index + 1, cur, result);
    cur.push(nums[index]);
    generate(nums, index + 1, cur, result);
    cur.pop();
}



// second try
var subsets = function(nums) {
    var res = [[]];

    function generate(nums, i, cur, res) {
        for(; i < nums.length; i++) {
            cur.push(nums[i]);
            res.push(cur.slice());
            generate(nums, i + 1, cur, res);
            cur.pop();
        }
    }

    generate(nums, 0, [], res);
    return res;
};

// Third solution
var subsets = function(nums) {
    var results = [];
    combine(nums, 0, [], results);
    return results;
}

var combine = function(nums, index, partial, results) {
    if(index === nums.length) {
      results.push(partial);
      return;
    }

    combine(nums, index + 1, partial, results);
    combine(nums, index + 1, partial.concat([nums[index]]), results);
}

</pre>
<hr />
</div>

<div>
<h3>79 Word Search.js</h3>
<a name="79-word-search-js"></a>
<pre>
// Given a 2D board and a word, find if the word exists in the grid.

// The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

// For example,
// Given board =

// [
//   ['A','B','C','E'],
//   ['S','F','C','S'],
//   ['A','D','E','E']
// ]
// word = "ABCCED", -> returns true,
// word = "SEE", -> returns true,
// word = "ABCB", -> returns false.
// Hide Company Tags Microsoft Bloomberg Facebook
// Hide Tags Array Backtracking
// Hide Similar Problems (H) Word Search II


var exist = function(board, word) {
    var hash = {};
    
    for(var i = 0; i < board.length; i++) {
        for(var j = 0; j < board[0].length; j++) {
            if(dfs(board, word, 0, i, j)) {
                return true;
            }
        }
    }
    
    function dfs(board, word, w, i, j) {
        var key = i + ',' + j;
        if(hash[key]) {
            return false;
        }
        
        if(w === word.length) {
            return true;
        }
        
        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length) {
            return false;
        }
        
        var result = false;
        
        if(word[w] === board[i][j]) {
            hash[key] = true;
            
            result = dfs(board, word, w + 1, i+1, j) || dfs(board, word, w + 1, i-1, j) || dfs(board, word, w + 1, i, j+1) || dfs(board, word, w + 1, i, j-1);
            
            hash[key] = false;
        }
        
        return result
    }
    
    return false;
};
</pre>
<hr />
</div>

<div>
<h3>8 String to Integer (atoi).js</h3>
<a name="8-string-to-integer-atoi-js"></a>
<pre>
// Implement atoi to convert a string to an integer.

// Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

// Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.
/**
 * @param {string} str
 * @return {number}
 */
var myAtoi = function(str) {
    var num = 0;
    var baseCharCode = '0'.charCodeAt(0);
    var sign = 1;
    
    str = str.trim();
    
    if(str[0] === '+' || str[0] === '-') {
        
        if(str[0] === '-') {
            sign = -1;
        }
        
        str = str.substring(1);
    }
    
    for(var i = 0; i < str.length; i++) {
        var c = str[i];
        var charCode = c.charCodeAt(0) - baseCharCode;
        
        if(0 <= charCode && charCode <= 9) {
            num *= 10;
            num += charCode;
        } else {
            break;
        }
    }
    
    var maxInt = Math.pow(2,31) - 1;
    var minNegInt = -Math.pow(2,31);
    
    num = sign*num;
    
    if(0 < num && maxInt < num) {
        return maxInt;
    }
    
    if(num < 0 && num < minNegInt) {
        return minNegInt;
    }
    
    return num;
};
</pre>
<hr />
</div>

<div>
<h3>80 Remove Duplicates from Sorted Array II.js</h3>
<a name="80-remove-duplicates-from-sorted-array-ii-js"></a>
<pre>
// Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

// Do not allocate extra space for another array, you must do this in place with constant memory.

// For example,
// Given input array nums = [1,1,2],

// Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

// Hide Company Tags Microsoft Bloomberg Facebook
// Hide Tags Array Two Pointers
// Hide Similar Problems (E) Remove Element


/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    var oc = 1;
    var sorted = 0;
    
    for(var i = 1; i < nums.length; i++) {
        if(nums[i] === nums[sorted]) {
            if(oc === 2) {
                continue;
            }
            
            oc++;
        } else {
            oc = 1;
        }
        
        sorted++;
        nums[sorted] = nums[i];
    }
    
    return sorted + 1;
};
</pre>
<hr />
</div>

<div>
<h3>81 Search in Rotated Sorted Array II.js</h3>
<a name="81-search-in-rotated-sorted-array-ii-js"></a>
<pre>
// Follow up for "Search in Rotated Sorted Array":
// What if duplicates are allowed?

// Would this affect the run-time complexity? How and why?

// Write a function to determine if a given target is in the array.

// Hide Tags Array Binary Search
// Hide Similar Problems (H) Search in Rotated Sorted Array



/**
 * @param {number[]} nums
 * @param {number} target
 * @return {boolean}
 */
var search = function(nums, target) {
    var start = 0;
    var end = nums.length -1;

    while(start <= end){
        var mid = parseInt((end + start)/2);

        if(nums[mid] === target ){
            return true;
        }

        if(nums[start] === nums[mid]) {
            start++;
        } else if(nums[start] < nums[mid]){ // left part sorted
            if(target >= nums[start] && target < nums[mid]){
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        } else { //right part sorted
            if(target <= nums[end] && target > nums[mid]){ // normal order part
                start = mid + 1;
            } else {
                end = mid -1;
            }
        }
    }

    return false;
};


</pre>
<hr />
</div>

<div>
<h3>82 Remove Duplicates from Sorted List II.js</h3>
<a name="82-remove-duplicates-from-sorted-list-ii-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    var root = new ListNode(-1);
    
    root.next = head;
    var pre = head = root;

    while(pre) {
        var cur = pre.next;
        var isDup = false;
        
        while(cur && cur.next && cur.val === cur.next.val) {
            isDup = true;
            var next = cur.next;
            cur.next = next.next;
            next.next = null;
        }
        
        if(isDup) {
            pre.next = cur.next;
            cur.next = null;
            continue;
        }
        
        pre = cur;
    }
    
    return root.next;
};
</pre>
<hr />
</div>

<div>
<h3>83 Remove Duplicates from Sorted List.js</h3>
<a name="83-remove-duplicates-from-sorted-list-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if(head === null || head.next === null){
        return head;
    }
   
    var cur = head;
    
    while(cur.next){
        if(cur.val === cur.next.val){
            cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
   
    
    return head;
};
</pre>
<hr />
</div>

<div>
<h3>84 Largest Rectangle in Histogram.js</h3>
<a name="84-largest-rectangle-in-histogram-js"></a>
<pre>
// Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.


// Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].


// The largest rectangle is shown in the shaded area, which has area = 10 unit.

// For example,
// Given heights = [2,1,5,6,2,3],
// return 10.

// Hide Tags Array Stack
// Hide Similar Problems (H) Maximal Rectangle



// reference: http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html

/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
    var maxArea = 0;
    
    if(heights === null || heights.length === 0) {
        return maxArea;
    }
    
    var stack = [];
    var i = 0;
    
    while(i <= heights.length) {
        // Keep stack height in increasing order
        // stack store the height index not the height
        // everytime we encounter height smaller than the max height in the stack, we calculate area and pop 
        // height index in the stack until stack is empty or we found height smaller than the current height in the stack.
        // taking [2,1,5,6,2,3] for example
        // 2, then we encounter 1, it means anything after 1 will not yield rectangle with height greater than 1 since they all got throttle by 1
        // stack will look like
        // 1. [2]
        // 2. we calculate area 2*1, i is at index 0 and i is at 1 (1-0)*height(2) = 2
        // 3. [1]
        // 4. [1,5]
        // 5. [1,5,6]
        // we calculate area 6*1, i is at index 4 and height 6 is at index 1 (4-3)*height(6) = 6
        // 6. [1,5]
        // we calculate area 5*2, i is at index 4 and height 5 is at index 2 (4-2)*height(5) = 10
        // 7. [1,2]
        // 8. [1,2,3]
        // etc...

        if(stack.length === 0 || heights[stack[stack.length - 1]] <= heights[i]) {
            stack.push(i++);
        } else {
            var height = heights[stack.pop()];
            var width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
            maxArea = Math.max(height*width, maxArea);
        }
    }
 
    return maxArea;
};
</pre>
<hr />
</div>

<div>
<h3>85 Maximal Rectangle.js</h3>
<a name="85-maximal-rectangle-js"></a>
<pre>
// Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

// For example, given the following matrix:

// 1 0 1 0 0
// 1 0 1 1 1
// 1 1 1 1 1
// 1 0 0 1 0
// Return 6.
// Hide Company Tags Facebook
// Hide Tags Array Hash Table Stack Dynamic Programming
// Hide Similar Problems (H) Largest Rectangle in Histogram (M) Maximal Square


/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
    if(matrix === null || matrix.length === 0 || matrix[0].length === 0) {
        return 0;
    }
    var heights = [];
    
    var maxArea = 0;
    for(var x = 0; x < matrix.length; x++) {
        var height = Array(matrix[0].length).fill(0);
        heights.push(height);
        for(var y = 0; y < matrix[0].length; y++) {
            if(matrix[x][y] === '1') {
                if(x === 0) {
                    heights[x][y] = 1;
                } else {
                    heights[x][y] = heights[x-1][y] + 1;    
                }
            }
        }

        maxArea = Math.max(maxArea, largestRectangleArea(heights[x]));
    }

    return maxArea;
};


var largestRectangleArea = function(heights) {
    var maxArea = 0;
    
    if(heights === null || heights.length === 0) {
        return maxArea;
    }
    
    var stack = [];
    var i = 0;
    
    while(i <= heights.length) {
        // Keep stack height in increasing order
        // stack store the height index not the height
        // everytime we encounter height smaller than the max height in the stack, we calculate area and pop 
        // height index in the stack until stack is empty or we found height smaller than the current height in the stack.
        // taking [2,1,5,6,2,3] for example
        // 2, then we encounter 1, it means anything after 1 will not yield rectangle with height greater than 1 since they all got throttle by 1
        // stack will look like
        // 1. [2]
        // 2. we calculate area 2*1, i is at index 0 and i is at 1 (1-0)*height(2) = 2
        // 3. [1]
        // 4. [1,5]
        // 5. [1,5,6]
        // we calculate area 6*1, i is at index 4 and height 6 is at index 1 (4-3)*height(6) = 6
        // 6. [1,5]
        // we calculate area 5*2, i is at index 4 and height 5 is at index 2 (4-2)*height(5) = 10
        // 7. [1,2]
        // 8. [1,2,3]
        // etc...

        if(stack.length === 0 || heights[stack[stack.length - 1]] <= heights[i]) {
            stack.push(i++);
        } else {
            var height = heights[stack.pop()];
            var width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
            maxArea = Math.max(height*width, maxArea);
        }
    }
 
    return maxArea;
};

var matrix = ["10100","10111","11111","10010"]
maximalRectangle(matrix);
</pre>
<hr />
</div>

<div>
<h3>86 Partition List.js</h3>
<a name="86-partition-list-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
 
var partition = function(head, x) {
    var p = new ListNode(x-1);
    p.next = head;
    head = p;
    var pre;
    
    while(p !== null && p.val < x){ // since we initialize it with x - 1
        pre = p;
        p = p.next;
    }
    
    if(p !== null){
        var cur = pre;
        while(p !== null){
            if(p.val < x){
                var temp = cur.next;
                pre.next = p.next;
                cur.next = p;
                cur = p;
                p.next = temp;
                p = pre;
            }
            pre = p;
            p = p.next;
        }
    }
    
    temp = head;
    head = head.next;
    
    return head;
};
</pre>
<hr />
</div>

<div>
<h3>88 Merge Sorted Array.js</h3>
<a name="88-merge-sorted-array-js"></a>
<pre>
/**
 * @param {number[]} A
 * @param {number} m
 * @param {number[]} B
 * @param {number} n
 * @return {void} Do not return anything, modify A in-place instead.
 */
var merge = function(A, m, B, n) {
    while(m > 0 && n > 0){
        if(A[m - 1] > B[n - 1]){
            A[m+n-1] = A[m-1];
            m--;
        } else {
            A[m+n-1] = B[n-1];
            n--;
        }
    }
    
    while(n > 0) {
        nums1[n - 1] = nums2[n - 1];
        n--;
    }
};
</pre>
<hr />
</div>

<div>
<h3>89 Gray Code.js</h3>
<a name="89-gray-code-js"></a>
<pre>


// The gray code is a binary numeral system where two successive values differ in only one bit.

// Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

// For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

// 00 - 0
// 01 - 1
// 11 - 3
// 10 - 2
// Note:
// For a given n, a gray code sequence is not uniquely defined.

// For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

// For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.


// n = 0: 0
// n = 1: 0, 1
// n = 2: 00, 01, 11, 10  (0, 1, 3, 2)
// n = 3: 000, 001, 011, 010, 110, 111, 101, 100 (0, 1, 3, 2, 6, 7, 5, 4)
// ?n = 3??,grey code??4????n = 2???gray code??4????4??????2^2?

// ??:n = i?grey code???????n = i-1???grey code,??????????????2^(i-1)?


// Silly question...

/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    if(n === 0) {
        return [0];
    }
    
    var result = grayCode(n - 1);
    var addNumber = 1 << (n - 1);
    var len = result.length;
    
    for(var i = len; i--;) {
        result.push(result[i] + addNumber);
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>9 Palindrome Number.js</h3>
<a name="9-palindrome-number-js"></a>
<pre>
// Leetcode #9:
// Language: Javascript
// Problem: https://leetcode.com/problems/palindrome-number/
// Author: Chihung Yu

// Determine whether an integer is a palindrome. Do this without extra space.

 /**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if(x < 0) {
        return false;
    }
    
    var div = 1;
    
    // it means that the div is still a valid divider
    // e.g 600 the divider should be 100 at maximum
    // e.g. 90 the divider should be 10 at maximum
    // e.g. 1 the divider should be a 1 at maximum
    while(parseInt(x/div) >= 10) {
        div *= 10;   
    }
    
    var left, right;
    
    // when div === 1 it means the digit only has one value to examine
    // e.g. 121 -> only 2 is left for examine which can be ignore
    // e.g. 1 -> 1
    // e.g. 43234 -> 2
    while(div > 1) {
        left = parseInt(x/div);
        right = x%10;
        if(left !== right) {
            return false;
        }
        
        x = x%div; // remove the left most digit
        x = parseInt(x/10); // remove the right most digit
        div /= 100;
    }
    
    return true;
};
</pre>
<hr />
</div>

<div>
<h3>90 Subsets II.js</h3>
<a name="90-subsets-ii-js"></a>
<pre>
// provide many different solutions
// reference: http://bangbingsyb.blogspot.com/2014/11/leetcode-subsets-i-ii.html


/**
 * @param {number[]} nums
 * @return {number[][]}
 */
 
var subsetsWithDup = function(nums) {
    nums.sort(function(a,b){return a > b;});
    var result = [[]];
    var current = [];
    generate(nums, 0, current, result);
    return result;
};

var generate = function(nums, index, current, result){
    for(var i = index; i < nums.length; i++){
        var num = nums[i];
    
        current.push(num);
        result.push(current.slice());
        
        // process first since it will give us the correct result
        generate(nums, i + 1, current, result);
        current.pop();
        
        // avoid duplicate using this step since we have already generate what we want from line 23
        while(i < nums.length - 1 && nums[i] === nums[i+1]){
            i++;
        }
    }
}
</pre>
<hr />
</div>

<div>
<h3>91 Decode Ways.js</h3>
<a name="91-decode-ways-js"></a>
<pre>
// A message containing letters from A-Z is being encoded to numbers using the following mapping:

// 'A' -> 1
// 'B' -> 2
// ...
// 'Z' -> 26
// Given an encoded message containing digits, determine the total number of ways to decode it.

// For example,
// Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

// The number of ways decoding "12" is 2.

/**
 * @param {string} s
 * @return {number}
 */

var numDecodings = function(s) {
    if(!s || s[0] === '0') {
        return 0;
    }
   
    var nums = [1, 1];
    
    for(var i = 2; i <= s.length; i++) {
        var tmp;
        
        tmp = parseInt(s.substring(i - 1, i));
        
        if(tmp === 0) {
            nums[i] = 0;
        } else {
            nums[i] = nums[i-1];
        }
        
        if(s[i - 2] !== '0') {
            tmp = parseInt(s.substring(i - 2, i));
            
            if(0 < tmp && tmp <= 26) {

                nums[i] += nums[i - 2];
            }
        }
    }
    
    return nums[s.length];
};

console.log(numDecodings('10'));

// Using recusion
// It also store all the possible combination
// var numDecodings = function(s) {
//     var result = [];
    
//     function traverse(s, beg, end, cur) {
//         if(end > s.length) {
//           return 
//         }
    
//         var str = s.substring(beg, end);
//         var num = parseInt(str);
        
//         if(isNaN(num) || num === 0 || num > 26) {
//           return;
//         }
      
//         cur.push(str);
      
//         if(end === s.length){
//           result.push(cur.slice());
//           return;
//         }
      
//         traverse(s, end, end + 1, cur);
//         traverse(s, end, end + 2, cur);
//         cur.pop();
//     }
  
//     traverse(s, 0, 1, []);
//     traverse(s, 0, 2, []);
  
//     return result.length;
// };



</pre>
<hr />
</div>

<div>
<h3>92 Reverse Linked List II.js</h3>
<a name="92-reverse-linked-list-ii-js"></a>
<pre>
// http://bangbingsyb.blogspot.com/2014/11/leetcode-reverse-linked-list-ii.html

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */
var reverseBetween = function(head, m, n) {
    if(m >= n) {
        return head;
    }
    
    var dummy = new ListNode(0);
    dummy.next = head;
    head = dummy;
    
    // move head to m - 1 node;
    for(var i = 0; i < m - 1; i++) {
        head = head.next;
    }
    
    var pre = head.next;
    var cur = pre.next;
    
    for(i = 0; i < n - m; i++) {
        var tmp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = tmp;
    }
    
    // head.next still point to m
    head.next.next = cur;
    head.next = pre;
    
    return dummy.next; 
};
</pre>
<hr />
</div>

<div>
<h3>93 Restore IP Addresses.js</h3>
<a name="93-restore-ip-addresses-js"></a>
<pre>
/**
 * @param {string} s
 * @return {string[]}
 */
 
var restoreIpAddresses = function(s) {
    var result = [];
    var ipNums = [];
    findIp(s, 0, result, ipNums);
    return result;
};

var findIp = function(s, index, result, ipNums){
    if(ipNums.length === 4){
        if(index === s.length){
            var ip = ipNums.join('.');
            result.push(ip);
        }
        
        return
    }
    
    for(var i = index; i < (index+3) && i < s.length; i++){
        var str = s.substring(index, i + 1);
        
        if(isValidNum(str)){
            ipNums.push(str);
            findIp(s, i + 1, result, ipNums);
            ipNums.pop();
        }
    }
}

var isValidNum = function(s){
    if(s.length === 0 || s.length > 3){
        return false;
    }
    
    if(s[0] === '0' && s.length !== 1){
        return false;
    }
    
    if(s.length === 3 && parseInt(s) > 255){
        return false;
    }
    
    return true;
}
</pre>
<hr />
</div>

<div>
<h3>94 Binary Tree Inorder Traversal.js</h3>
<a name="94-binary-tree-inorder-traversal-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
 
var inorderTraversal = function(root) {
    var result = [];
    
    if(root === null){
        return result;
    }
    

    var stack = [];
    var cur = root;
    
    while(true){
        while(cur !== null){
            stack.push(cur);
            cur = cur.left;
        }
        
        if(stack.length === 0){
            break;
        }
        
        cur = stack.pop();
        result.push(cur.val);
        cur = cur.right;
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>95 Unique Binary Search Trees II.js</h3>
<a name="95-unique-binary-search-trees-ii-js"></a>
<pre>
// Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.

// For example,
// Given n = 3, your program should return all 5 unique BST's shown below.

//    1         3     3      2      1
//     \       /     /      / \      \
//      3     2     1      1   3      2
//     /     /       \                 \
//    2     1         2                 3
// Hide Tags Tree Dynamic Programming
// Hide Similar Problems (M) Unique Binary Search Trees (M) Different Ways to Add Parentheses





/**
Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

For example,
Given n = 3, your program should return all 5 unique BST's shown below.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
confused what "{1,#,2,3}" means? > read more on how binary tree is serialized on OJ.
*/
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number} n
 * @return {TreeNode[]}
 */
var generateTrees = function(n) {
    if (n === 0) {
        return [];
    }
    
    return genTreeHelper(1, n);
};

function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
}

function genTreeHelper(start, end) {
    var result = [];
    
    if (start > end) {
        return [null];
    }

    
    
    for (var i = start; i <= end; i++) {
        // let node i becomes the center node and generate it's left and right nodes
        var left = genTreeHelper(start, i - 1);
        var right = genTreeHelper(i + 1, end);
        for (var k = 0; k < left.length; k++) {
            for (var j = 0; j < right.length; j++) {
                var node = new TreeNode(i);
                node.left = left[k];
                node.right = right[j];
                result.push(node);
            }
        }
    }
    
    return result;
}




console.log(generateTrees(2));
</pre>
<hr />
</div>

<div>
<h3>96 Unique Binary Search Trees.js</h3>
<a name="96-unique-binary-search-trees-js"></a>
<pre>
/**
 * @param {number} n
 * @return {number}
 */
 // https://www.youtube.com/watch?v=YDf982Lb84o
var numTrees = function(n) {
    var result = [1, 1];
    
    for (var i = 2; i <= n; i++) {
        result[i] = 0;
        for (var j = 0; j < i; j++) {
            result[i] += result[j] * result[i - 1 - j];
        }
        
    }
    return result[n];
};



// var numTrees = function(n) {
//     var i,
//         j,
//         result = [];
    
//     result[0] = 1;
//     result[1] = 1;
    
//     for (i = 2; i <= n; i++) {
//         result[i] = 0;
//         for (j = 0; j < i; j++) {
//             result[i] += result[j] * result[i - 1 - j];
//             console.log(i, j, i - 1 - j, result)
//         }
        
//     }
//     return result[n];
// };


numTrees(4);


1, 2, 3, 4

j = r[0]
k = r[3]

j = r[1]
k = r[2]
</pre>
<hr />
</div>

<div>
<h3>98 Validate Binary Search Tree.js</h3>
<a name="98-validate-binary-search-tree-js"></a>
<pre>
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    return validate(root, -Infinity, Infinity);
};

var validate = function(node, min, max){
    if(node === null){
        return true;
    }
    
    if(node.val <= min || node.val >= max){
        return false;
    }
    return validate(node.left,min,node.val) && validate(node.right,node.val,max);
}
</pre>
<hr />
</div>

<div>
<h3>Basic Calculator II.js</h3>
<a name="basic-calculator-ii-js"></a>
<pre>
// Implement a basic calculator to evaluate a simple expression string.

// The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.

// You may assume that the given expression is always valid.

// Some examples:
// "3+2*2" = 7
// " 3/2 " = 1
// " 3+5 / 2 " = 5
// Note: Do not use the eval built-in library function.

// Credits:
// Special thanks to @ts for adding this problem and creating all test cases.

// Hide Company Tags Airbnb
// Hide Tags String
// Hide Similar Problems (H) Basic Calculator (H) Expression Add Operators



/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    var values = [];
    var ops = [];
    
    for(var i = 0; i < s.length; i++) {
        var ch = s[i];
        if(ch === ' ') {
            continue;
        }
        
        if(ch.match(/\d/)) {
            var num = '';
            while(i < s.length && s[i].match(/\d/)) {
                num += s[i++];
            }
            values.push(parseInt(num));
            i--;
        } else if(ch === '-' || ch === '+' || ch === '*' || ch === '/') {
            if(!hasPrecedence(ch, ops[ops.length - 1])) {
                while(ops.length > 0 && !hasPrecedence(ch, ops[ops.length - 1])) {
                    values.push(applyOp(values.pop(), values.pop(), ops.pop()));
                }
            }
            ops.push(ch);
        }
    }
    
    while(ops.length > 0) {
        values.push(applyOp(values.pop(), values.pop(), ops.pop()));
    }
    
    return values.pop();
};

var hasPrecedence = function(op1, op2) {
    var map = {
        '-': 1,
        '+': 1,
        '/': 2,
        '*': 2
    }
    
    return map[op1] > map[op2];
}

var applyOp = function(v1, v2, op) {
    if(op === '*') {
        return v2*v1;
    } else if(op === '-') {
        return v2-v1;
    } else if(op === '+') {
        return v2+v1;
    } else if(op === '/') {
        return parseInt(v2/v1);
    }
}

console.log(calculate("1+1+1*3*4/2+2*3"), eval("1+1+1*3*4/2+2*3"));
</pre>
<hr />
</div>

<div>
<h3>Basic Calculator III.js</h3>
<a name="basic-calculator-iii-js"></a>
<pre>
function evaluateStr(expression) {
  var values = [];
  var ops = [];

  for(var i = 0; i < expression.length; i++) {
    var ch = expression[i];

    if(ch === ' ') {
      continue;
    }

    if(ch.match(/\d/)) {
      var numStr = '';

      while(i < expression.length && expression[i].match(/\d/)) {
        numStr += expression[i++];
      }
      i--;
      values.push(parseInt(numStr));
    } else if(ch === '(') {
      ops.push(ch);
    } else if(ch === ')') {
      while(ops[ops.length - 1] !== '(') {
        values.push(applyOp(values.pop(), values.pop(), ops.pop()));
      }
      ops.pop();
    } else if(ch === '+' || ch === '-' || ch === '*' || ch === '/') {
      while(ops.length > 0 && hasPrecedence(ch, ops[ops.length - 1])) {
        values.push(applyOp(values.pop(), values.pop(), ops.pop()));  
      }
      ops.push(ch);
    }
  }

  while(ops.length > 0) {
    values.push(applyOp(values.pop(), values.pop(), ops.pop()));  
  }

  return values.pop();
}

function hasPrecedence(op1, op2) {
  var precedenceMap = {
    '=': 1,
    '(': 2,
    '+': 3,
    '-': 3,
    '*': 4,
    '/': 4,
    '~': 4,
    '^': 5
  };

  var precendence1 = precedenceMap[op1];
  var precendence2 = precedenceMap[op2];

  return precendence2 >= precendence1;
}

function applyOp(val1, val2, op) {
  if(op === '*') {
    return val2*val1;
  } else if(op === '+') {
    return val2+val1;
  } else if(op === '/') {
    return parseInt(val2/val1);
  } else if(op === '-') {
    return val2-val1;
  }
}


var data = [
  '(11+(22*3-4)*5-(3+1))',
  '11+22*3+(1*3+1)',
  '11+22*3-(1*3+1)',
];

// '11+22*3*(1*3+1)' => doesn't work

data.forEach((d)=> {
  console.log(evaluateStr(d), eval(d));
});

</pre>
<hr />
</div>

<div>
<h3>Bean Probability.js</h3>
<a name="bean-probability-js"></a>
<pre>
// ?????????????????,???????????,???????,????????????,????????????????????????????????
// r/(r+w)*(r/(r+w)*f(r - 1, w)+w/(r+w)*f(r, w - 1))
</pre>
<hr />
</div>

<div>
<h3>Can Win.js</h3>
<a name="can-win-js"></a>
<pre>
// CanWin. ??????? ???index??4,???index???????????ary???, ???????0?index???true?


function canWin(arr) {

  if(!arr || arr.length === 0) {
    return false;
  }

  var visitedIdx = {};
  var unvisited = [];
  unvisited.push(0);

  while(unvisited.length > 0) {
    var curVisitIdx = unvisited.shift();

    if(visitedIdx[curVisitIdx] === undefined) {
      visitedIdx[curVisitIdx] = true;

      if(arr[curVisitIdx] === 0) {
        return true;
      }

      unvisited.push(curVisitIdx + arr[curVisitIdx]);
      unvisited.push(curVisitIdx - arr[curVisitIdx]);
    }
  }

  return false;
}

var arr = [3,3,6,2,0,2];
// win path 0 3 1 4
console.log(canWin(arr));

</pre>
<hr />
</div>

<div>
<h3>Conjuct Names With Limit.js</h3>
<a name="conjuct-names-with-limit-js"></a>
<pre>
function conjuctNamesWithLimit(names, limit) {
  var left, right;
  
  if(names.length === 0) {
    return '';
  }
  
  if(limit === 0) {
    return names.length + ' more';
  }
  
  if(limit >= names.length) {
    left = names.slice(0, -1);
    right = names.slice(-1)[0];
    return left.join(', ') + ' and ' + right;
  } else {
    left = names.slice(0, limit);
    right = names.slice(limit);    
    return left.join(', ') + ' and ' + right.length + ' more';
  }
}

var data = [
  [],
  ['a','b'],
  ['a','b','c'],
  ['a','b','c','d']
]

for(var i = 0; i < 5; i++){
  data.forEach((d)=>{
    console.log(conjuctNamesWithLimit(d, i));
  });
}



console.log(conjuctNamesWithLimit(['alex', 'peter', 'jeremy'], 2) == 'alex, peter and 1 more');     
console.log(conjuctNamesWithLimit(['alex', 'peter', 'jeremy', 'joseph'], 2) == 'alex, peter and 2 more');
console.log(conjuctNamesWithLimit(['alex', 'peter', 'jeremy', 'joseph'], 3) == 'alex, peter, jeremy and 1 more');
console.log(conjuctNamesWithLimit(['alex', 'peter', 'jeremy', 'joseph'], 5) == 'alex, peter, jeremy and joseph');

</pre>
<hr />
</div>

<div>
<h3>Convert Binary Search Tree To Doubly Linked List.js</h3>
<a name="convert-binary-search-tree-to-doubly-linked-list-js"></a>
<pre>
// http://kubicode.me/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/

// ????????????????????,??,?????????????,?????????,??,???????????
// ????????:
// ??????????????,?
// ?????
// ??????????
// ?????right???????,?????left???????
// ??????????????,?
// ?????
// ??????????
// ?????left???????,?????right???????
// ?:tree?left?right??????list?pre?next??
//       8    
//     /   \
//    3     10
//  /   \     \
// 1     6     14
//     /  \   /
//    4    7 13 

// ????????:1(l),4(l),7(r),4(r),7(l),13(l),13(r),10(r)
//       8    
//     /   \
//  1-3     10
//     \     \
//     6     14
//     /  \   /
//    4    7 13 
//    1?3???????,????????3,3??????1


//        8    
//     /   \
//  1-3     10
//     \     \
//    4-6     14
//       \   /
//        7 13 

//  4?6????????,??4??????6,6???4

//       8    
//     /   \
//  1-3     10
//     \     \
//    4-6-7   14
//           /
//          13

//  7?6????????,??7??????6,6???4

//      8    
//     /   \
//  1-3     10
//     \     \
//      4-6-7 14
//           /
//          13

//  4?3????????,??4??????3,3???4

//  1-3-4-6-7-8    
//            \
//             10
//              \
//              14
//              /
//             13

// 7?8???????,??7??????8,8??????7
// ??????????????,?????????

/**
 * ???????????
 * @param T
 * @return
 */
private static TreeNode findMaxNodeInLeft(TreeNode T)
{
  TreeNode t=T.left;
  if(t!=null)
    while(t.right!=null)
    {
      t=t.right;//??????????
    }
  
  return t;
  
}

/**
 * ???????????
 * @param T
 * @return
 */
private static TreeNode findMinNodeInRight(TreeNode T)
{
  TreeNode t=T.right;
  if(t!=null)
    while(t.left!=null)
      t=t.left;
  
  return t;
}

/**
 * ??????????
 * @param T
 */
public static void convertNode(TreeNode T)
{
  if(T==null)
    return ;
  
  if(T.left!=null)
  {
    convertNode(T.left);
    TreeNode t=findMaxNodeInLeft(T);//????????  ?????????
    t.right=T;//????????????????
    T.left=t;
    t.parent=null;
  }
  
  if(T.right!=null)
  {
    convertNode(T.right);
    TreeNode t=findMinNodeInRight(T);
    t.left=T;//????????????????
    T.right=t;
    t.parent=null;
  }
}
</pre>
<hr />
</div>

<div>
<h3>Convert Infix to Reverse Polish Notation.js</h3>
<a name="convert-infix-to-reverse-polish-notation-js"></a>
<pre>
// https://www.youtube.com/watch?v=LQ-iW8jm6Mk

function convertInfixToReversePolishNotation(strExpression) {
  var precedenceMap = {
    '=': 1,
    '(': 2,
    '+': 3,
    '-': 3,
    '*': 4,
    '/': 4,
    '~': 4,
    '^': 5
  };

  var stack = [];
  var rpn = [];

  for(var i = 0; i < strExpression.length; i++) {
    var ch = strExpression[i];
    if(!isNaN(parseInt(ch))) {
      var num = 0;

      while(i < strExpression.length && !isNaN(parseInt(strExpression[i]))) {
        num *= 10;
        num += parseInt(strExpression[i]);
        i++;
      }

      i--;
      rpn.push(num);
    } else if(ch === '(') {
      stack.push('(');
    } else if(ch === '*' || ch === '-' || ch === '+') {
      var precedence = precedenceMap[ch];

      if(precedence > precedenceMap[stack[stack.length - 1]]) {
        stack.push(ch);
      } else {
        while(precedenceMap[stack[stack.length - 1]] >= precedence) {
          rpn.push(stack.pop());  
        }

        stack.push(ch);
      }
    } else if(ch === ')') {
      while(stack[stack.length - 1] !== '(') {
        rpn.push(stack.pop());
      }

      stack.pop();
    }
  }

  while(stack.length > 0) {
    rpn.push(stack.pop());
  }

  return rpn;
}


// console.log(convertInfixToReversePolishNotation('(12*-36+(3+4-2)-(4*4+12))'));
console.log(convertInfixToReversePolishNotation('12+12*12+(3-4)'))


</pre>
<hr />
</div>

<div>
<h3>Custom Tree Problem.js</h3>
<a name="custom-tree-problem-js"></a>
<pre>
// a ---> b
// b ---> c
// b ---> d
// a ---> e 
// Print the tree that would form when each pair of these links that has the same character as start and end point is joined together. You have to maintain fidelity w.r.t. the height of nodes, i.e. nodes at height n from root should be printed at same row or column. For set of links given above, tree printed should be 

// -->a
//    |-->b
//    |   |-->c
//    |   |-->d
//    |-->e
// Note that these links need not form a single tree; they could form, ahem, a forest. Consider the following links

// a ---> b
// a ---> g
// b ---> c
// c ---> d
// d ---> e
// c ---> f
// z ---> y
// y ---> x
// x ---> w
// The output would be following forest.

// -->a
//    |-->b
//    |   |-->c
//    |   |   |-->d
//    |   |   |   |-->e
//    |   |   |-->f
//    |-->g

// -->z
//    |-->y
//    |   |-->x
//    |   |   |-->w

// http://ideone.com/l0QiJx
function printTree(data) {
   // 0 -> not seen, can possibly be root
   // 1 -> not root
   // 2 -> root

   var NOT_SEEN = 0;
   var NOT_ROOT = 1;
   var IS_ROOT = 2;

   var roots = Array(26).fill(NOT_SEEN);
   // [[neightbors],[neighbors],...] -> idx = 0 -> 'a'
   var graph = [];
   for(var i = 0; i < 26; i++){
      graph.push([]);
   }

   for(i = 0; i < data.length; i++) {
      var pair = data[i];
      var rootChar = pair[0];
      var rootIdx = charToIdx(rootChar);
      var depChar = pair[1];
      var depIdx = charToIdx(depChar);

      graph[rootIdx].push(depIdx);

      roots[depIdx] = NOT_ROOT;

      if(roots[rootIdx] === NOT_SEEN) {
         roots[rootIdx] = IS_ROOT;
      }
   }
  // console.log(roots);
   for(i = 0; i < roots.length; i++) {
      if(roots[i] === IS_ROOT) {
         dfs(i, 0, graph);
      }
   }
}

function charToIdx(char) {
   var base = 'a'.charCodeAt(0);
   return char.charCodeAt(0) - base;
}

function idxToChar(idx) {
   var base = 'a'.charCodeAt(0);
   return String.fromCharCode(base + idx);
}

function dfs(idx, level, graph) {
   var str = '';

   for(var i = 1; i <= level; i++) {
      str += '   |';
   }

   var char = idxToChar(idx);
   str += ('-->' + char);
   console.log(str);

   for(i = 0; i < graph[idx].length; i++) {
      var depIdx = graph[idx][i];
      dfs(depIdx, level + 1, graph);
   }
}



var data = [
   ['a', 'b'],
   ['a', 'g'],
   ['b', 'c'],
   ['c', 'd'],
   ['d', 'e'],
   ['c', 'f'],
   ['z', 'y'],
   ['y', 'x'],
   ['x', 'w']
];

console.log(printTree(data));
</pre>
<hr />
</div>

<div>
<h3>Data Structure Max Heap.js</h3>
<a name="data-structure-max-heap-js"></a>
<pre>
'use strict'

class MaxHeap {
  constructor() {
    this.arr = [];
  }

  peek() {
    return this.arr[0] || null;
  }

  size() {
    return this.arr.length;
  }

  pollMax() {
    var arr = this.arr;
    var len = arr.length;

    if(len === 0) {
      return null;
    }

    var max = arr[0];
    arr[0] = arr[len - 1] // replace max value with the last value

    arr.pop();

    this.sinkDown(0);

    return max;
  }

  add(val) {
    var arr = this.arr;
    arr.push(val);
    this.bubbleUp(arr.length - 1);
  }

  bubbleUp(n) {
    var arr = this.arr;

    while(n > 0) {
      // [3,2,1] 3 as root, 2 as left child and 1 as right child 
      // 2 has idx = 1 and 1 has idx = 2 
      // 1/2 will result in parent idx = 0 
      // and 2/2 will result in parent idx = 1. So we need to add one to them and -1 at the end
      var parentN = Math.floor((n + 1)/2) - 1;

      if(arr[parentN] > arr[n]) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[parentN];
      arr[parentN] = tmp;
      n = parentN;
    } 
  }

  sinkDown(n) {
    var arr = this.arr;
    var len = arr.length;
    var val = arr[n];
  
    while(true) {
      
      var swap = null;
      var child2N = n*2 + 2; // root = 0 right child idx is (0 + 1)*2 = 2
      var child1N = n*2 + 1; // right child idx - 1 = 1 for root's left child
      
      if(child1N < len && arr[child1N] > val) {
        swap = child1N;
      }

      if(child2N < len && arr[child2N] > val && arr[child2N] >= arr[child1N]) {
        swap = child2N;
      }
    
      if(swap === null) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[swap];
      arr[swap] = tmp;
      n = swap;
    } 
  }
}

var m = new MaxHeap();
m.add(4);
m.add(1);
m.add(2);
m.add(1);
m.add(15);
m.add(3);
m.add(4);
m.add(3);
m.add(3);

m.add(3);
m.add(4);
m.add(-1);

m.add(-1);
m.add(1);
m.add(10);

m.add(-1);
m.add(4);
m.add(8);
m.add(9);
m.add(100);
m.add(3);
m.add(7);
m.add(9);
m.add(4);

console.log(m.arr);
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
console.log(m.pollMax());
</pre>
<hr />
</div>

<div>
<h3>Data Structure Min Heap.js</h3>
<a name="data-structure-min-heap-js"></a>
<pre>
class MinHeap {
  constructor() {
    this.arr = [];
  }

  peek() {
    return this.arr[0] || null;
  }

  size() {
    return this.arr.length;
  }

  pollMin() {
    var arr = this.arr;
    var len = arr.length;

    if(len === 0) {
      return null;
    }

    var min = arr[0];
    arr[0] = arr[len - 1] // swap the last value with min value

    arr.pop();

    this.sinkDown(0);

    return min;
  }

  add(val) {
    var arr = this.arr;
    arr.push(val);
    this.bubbleUp(arr.length - 1);
  }

  bubbleUp(n) {
    var arr = this.arr;

    while(n > 0) {
      // [1,2,3] 1 as root 2 as left child and 3 as right child 
      // 2 has idx = 1 and 3 has idx = 2    1/2 will result in parent idx = 0 and 2/2 will result in parent idx = 1. So we need to add one to them and -1 at the end
      var parentN = Math.floor((n + 1)/2) - 1; 

      if(arr[parentN] <= arr[n]) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[parentN];
      arr[parentN] = tmp;
      n = parentN;
    } 
  }

  sinkDown(n) {
    var arr = this.arr;
    var len = arr.length;
    var val = arr[n]

    while(true) {
      var swap = null;
      var child2N = (n+1)*2; // root = 0 right child idx is (0 + 1)*2 = 2
      var child1N = child2N - 1; // right child idx - 1 = 1 for root's left child
      if(child1N < len && arr[child1N] < val) {
        swap = child1N;
      }

      if(child2N < len && arr[child2N] < val && arr[child2N] <= arr[child1N]) {
        swap = child2N;
      }

      if(swap === null) {
        break;
      }

      var tmp = arr[n];
      arr[n] = arr[swap];
      arr[swap] = tmp;
      n = swap;
    } 
  }
}
 

var m = new MinHeap();

// m.add(4);
m.add(1);
m.add(-1);
m.add(1);
m.add(-1);
m.add(1);
m.add(-1);
m.add(-1);
m.add(1);
m.add(1);
console.log('debug', m.arr)
m.add(1);
// m.add(1);
// m.add(-1);

// console.log(m.arr);
console.log(m.pollMin());
console.log(m.pollMin());
console.log(m.pollMin());


console.log(m.arr);
console.log(m.pollMin());
console.log(m.pollMin());
console.log(m.pollMin());
console.log(m.pollMin());
 
console.log(m.pollMin());
console.log(m.pollMin());
console.log(m.pollMin());
// console.log(m.pollMin());


</pre>
<hr />
</div>

<div>
<h3>Disambiguos Actors.js</h3>
<a name="disambiguos-actors-js"></a>
<pre>



process.stdin.resume();
process.stdin.setEncoding("ascii");
var input = "";
process.stdin.on("data", function (chunk) {
    input += chunk;
});
process.stdin.on("end", function () {
    actorsInOrder = input.split("\n");
    disambiguated = disambiguateActors(actorsInOrder);
    for(var i = 0; i < disambiguated.length; i++) {
        console.log(disambiguated[i]);
    }
});

function disambiguateActors(actorsInOrder) {
    // WRITE YOUR CODE HERE
    var hash = {};
    
    for(var i = 0; i < actorsInOrder.length; i++){
        var actor = actorsInOrder[i];
        if(hash[actor] !== undefined){
            hash[actor] += 1;
        } else {
            hash[actor] = 1;
        }
    }
    
    for(var i = actorsInOrder.length; i--;){
        actor = actorsInOrder[i];
        if(hash[actor] !== 1) {
            var count = hash[actor] === -1 ? 1 : hash[actor];
            actorsInOrder[i] = postfixActorName(actor, count);
            hash[actor] -= 1;
            
            if(hash[actor] === 1) {
                hash[actor] = -1;
            }
        }
    }
    
    for(var i = 0; i < actorsInOrder.length; i++){
        console.log(actorsInOrder[i])   
    }
    
}

function postfixActorName(actorName, num) {
    return actorName + " (" + convertNumberToRomanLetter(num) + ")";
}
    
function convertNumberToRomanLetter(num) {
    var dict = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
    var val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    var result = "";
    
    for(var i = 0; i < val.length; i++) {
        var v = val[i];
        
        if(num >= v) {
            var count = parseInt(num/v);
            num %= v;
            
            for(var j = 0; j < count; j++) {
                result = result + dict[i];
            }
        }
    }
    
    return result;
}
</pre>
<hr />
</div>

<div>
<h3>Find Duplicate Files.js</h3>
<a name="find-duplicate-files-js"></a>
<pre>
// ?????????, get_files(dir), get_dir(dir) ?????????file,
// ?????????, ???hashing??????hash?key??dictionary,??????dictionary?????code,test case? ??follow up?, ??hashing??expensive???, ??hashing??check file size,????????,??hashing???????? ????,????follow up?get_files, get_dir??expensive???,???parrallel programming (gpu or multi core) ????,??????????system design????? 

// getDir(dir)
// getFiles(dir)


function findDuplicateFiles(dir) {
  var files = [];
  var queue = [];

  queue.push(dir);

  // get all files
  while(queue.length > 0) {
    var curDir = queue.shift();

    var curFiles = getFiles(curDir);
    var curDirs = getDir(curDir);

    queue.concat(curDirs);
    files.concat(curFiles);
  }
}
</pre>
<hr />
</div>

<div>
<h3>Find Median in  K Sorted Arrays.js</h3>
<a name="find-median-in-k-sorted-arrays-js"></a>
<pre>
var data  = [
  [1,2,3,4,5,6,7,19],
  [2,3,5,7,8,10,11],
  [2,3,5,7,8,9],
  [10,13,15,17,18,100],
  [5,8,100,1002,1033,1044]
];

findMedianInKSortedArrays(data);

function findMedianInKSortedArrays(arrs) {
  var len = 0;

  for(var i = 0; i < arrs.length; i++) {
    len += arrs[i].length;
  }

  var kth = Math.floor(len/arrs.length);
  var list = [];


}


function findMedianInKArrs(arrs) {
  var len = 0;
  for(var i = 0; i < arrs.length; i++) {
    len = arrs[i].length;
  }

  findKthInKArrs(arrs, len);
}


function findKthInKArrs(arrs, n) {
  var min = Infinity;
  var max = -Infinity;

  for(var i = 0; i < arrs.length; i++) {
    min = Math.min(arrs[i][0], min);
    max = Math.max(arrs[i][arrs[i].length - 1], max);
  }

  var removed = 0;
  var dividers = [];

  for(var i = 0; i < arrs.length; i++) {

  }
}





function findKth(a, m, b, n, k) {
    // always assume that m is equal or smaller than n
    if(m > n) {
        return findKth(b, n, a, m, k);
    }
    
    if(m === 0) {
        return b[k-1];
    }
    
    if(k === 1) {
        return Math.min(a[0],b[0]);
    }
    
    // divide k into two parts
    var pa = Math.min(parseInt(k/2), m);
    var pb = k - pa;
    
    if(a[pa - 1] < b[pb - 1]) {
        return findKth(a.slice(pa), m - pa, b, n, k - pa);
    } else if(a[pa - 1] > b[pb - 1]) {
        return findKth(a, m, b.slice(pb), n - pb, k - pb);
    } else {
        return a[pa - 1];
    }
}













// function findMedian(arrs) {
//   var n = 0;
//   var min, max;

//   for(var i = 0; i < arrs.length; i++) {
//     n += arrs[i].length;
//   }

//   var res = mergeKLists(arrs, 0, arrs.length - 1);

//   function mergeKLists(arrs, left, right) {
//     if(left === right) {
//       return arrs[left];
//     }

//     if(left > right) {
//       return [];
//     }

//     var mid = Math.floor((left + right)/2);

//     var arr1 = mergeKLists(arrs, left, mid);
//     var arr2 = mergeKLists(arrs, mid + 1, right);

//     return merge2Lists(arr1, arr2);
//   }

//   function merge2Lists(arr1, arr2) {
//     var res = [];
//     var i = 0;
//     var j = 0;
//     while(i < arr1.length && j < arr2.length) {
//       if(arr1[i] < arr2[j]) {
//         res.push(arr1[i++]);
//       } else {
//         res.push(arr2[j++]);
//       }
//     }

//     while(i < arr1.length) {
//       res.push(arr1[i++]);
//     }
//     while(j < arr2.length) {
//       res.push(arr2[j++]);
//     }

//     return res;
//   }

//   return res;
// }

// console.log(findMedian(data));
</pre>
<hr />
</div>

<div>
<h3>Javascript Closure Questions.js</h3>
<a name="javascript-closure-questions-js"></a>
<pre>
// implement function add in such a way that:
// add() => 0
// add(1)(2)() => 3
// add(n0)(n1)...(nk)() => n0+n1+...+nk

function add(val){
    var total = 0;
    var result;
    var step = function(val){
        if(val === undefined){
            result = total;
            total = 0;
            return result;
        } else {
            total += val;
        }
    
        return step;
    }
    
    result = step(val);
    
    return result;
}
</pre>
<hr />
</div>

<div>
<h3>Job Sequencing Problem.js</h3>
<a name="job-sequencing-problem-js"></a>
<pre>
// Given an array of jobs where every job has a deadline and associated profit if the job is finished before the deadline. It is also given that every job takes single unit of time, so the minimum possible deadline for any job is 1. How to maximize total profit if only one job can be scheduled at a time.

// Examples:

// Input: Four Jobs with following deadlines and profits
//   JobID    Deadline      Profit
//     a        4            20   
//     b        1            10
//     c        1            40  
//     d        1            30
// Output: Following is maximum profit sequence of jobs
//         c, a   


// Input:  Five Jobs with following deadlines and profits
//    JobID     Deadline     Profit
//      a         2           100
//      b         1           19
//      c         2           27
//      d         1           25
//      e         3           15
// Output: Following is maximum profit sequence of jobs
//         c, a, e
// We strongly recommend to minimize your browser and try this yourself first.

// A Simple Solution is to generate all subsets of given set of jobs and check individual subset for feasibility of jobs in that subset. Keep track of maximum profit among all feasible subsets. The time complexity of this solution is exponential.

// This is a standard Greedy Algorithm problem. Following is algorithm.

// 1) Sort all jobs in decreasing order of profit. // 4, 2, 1, 6, 2 becomes 6, 4, 2, 2, 1
// 2) Initialize the result sequence as first job in sorted jobs.
// 3) Do following for remaining n-1 jobs
// .......a) If the current job can fit in the current result sequence 
//           without missing the deadline, add current job to the result.
//           Else ignore the current job.
// The Following is C++ implementation of above algorithm.

// Program to find the maximum profit job sequence from a given array
// of jobs with deadlines and profits
#include<iostream>
#include<algorithm>
using namespace std;
 
// A structure to represent a job
struct Job
{
   char id;      // Job Id
   int dead;    // Deadline of job
   int profit;  // Profit if job is over before or on deadline
};
 
// This function is used for sorting all jobs according to profit
bool comparison(Job a, Job b)
{
     return (a.profit > b.profit);
}
 
// Returns minimum number of platforms reqquired
void printJobScheduling(Job arr[], int n)
{
    // Sort all jobs according to decreasing order of prfit
    sort(arr, arr+n, comparison);
 
    int result[n]; // To store result (Sequence of jobs)
    bool slot[n];  // To keep track of free time slots
 
    // Initialize all slots to be free
    for (int i=0; i<n; i++)
        slot[i] = false;
 
    // Iterate through all given jobs
    for (int i=0; i<n; i++)
    {
       // Find a free slot for this job (Note that we start
       // from the last possible slot)
       for (int j=min(n, arr[i].dead)-1; j>=0; j--)
       {
          // Free slot found
          if (slot[j]==false)
          {
             result[j] = i;  // Add this job to result
             slot[j] = true; // Make this slot occupied
             break;
          }
       }
    }
 
    // Print the result
    for (int i=0; i<n; i++)
       if (slot[i])
         cout << arr[result[i]].id << " ";
}
 
// Driver program to test methods
int main()
{
    Job arr[] = { {'a', 2, 100}, {'b', 1, 19}, {'c', 2, 27},
                   {'d', 1, 25}, {'e', 3, 15}};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Following is maximum profit sequence of jobs\n";
    printJobScheduling(arr, n);
    return 0;
}
</pre>
<hr />
</div>

<div>
<h3>Log Hits.js</h3>
<a name="log-hits-js"></a>
<pre>
//  void log_hit()
//  int get_hits() - Returns the number of hits in the last 6 minutes
// ...........
// [11,12,13,14,15,............] 6mins
// 6*60sec => 360
// [0,...,359]
// { time: timestamp, count: integer}
// lastTime: 1, count
// ????

class Node {
  constructor(time) {
    this.time = time;
    this.count = 0;
    this.next = null;
  }
}

class Logger {
  constructor(precision, seconds) {
    this.lastTimeHit = null;
    this.precision = precision; // 1 src
    this.seconds = seconds; // 360 seconds
    // this.count = []; // initialize later // linklist structure
    
    this.head = this.tail = new Node(this.getCurTimeInSec());
    this.count = 0;
    this.totalCount = 0;  
  }

  logHit() { // assume this log hit got hits more
    var curTimeInSec = this.getCurTimeInSec();
    
    if(curTimeInSec === this.lastTimeHit) {
      this.tail.count++;
    } else {
      var node = new Node(curTimeInSec);
      node.count+=;
      this.tail.next = node;
      this.tail = node;
      this.count++;
    }
    
    // 361 > 360
    if(this.count > this.seconds) {
      var next = this.head.next;
      this.head.next = null;
      this.head = next;
      this.totalCount -= this.head.count;
    }
    
    this.totalCount++;
    
  }

  getHits() {
    var curTime = this.getCurTimeInSec();
    var startTime = curTime - this.seconds; // 360 seconds 
    var discount = 0;
    
    while(this.head && this.head.time < startTime) {
      discount += this.head.count;
      var next = this.head.next;
      this.head.next = null;
      this.head = next;
    }
    
    if(this.head === null) {
      this.head = this.tail = new Node(curTime);
    }
    
    this.totalCount -= discount;
    
    return this.totalCount;
  }

  getCurTimeInSec() {
    var curTime = Date.now(); // assuming this is ms
    var curTimeInSec = Math.floor(curTime / 1000);
    return curTimeInSec;
  }
}


new Logger(1, 6);
// starting 123
// loghit 154

// head(123) -> node(154)
// tail at node(154)
//loghit 160

// head(123) -> node(154) -> node(160);
// tail at 160
// getHits() // curTime 510
// 510 - 360 = 150

// logHit at 100
// totalCount -> 1
// head(0) -> node(100)
// tail is at node(100)
// getHits at 500
// 500 - 360 = 140
// dicount += 0
// dicount += 1
// curHead === null

</pre>
<hr />
</div>

<div>
<h3>Longest Common Subsequence.js</h3>
<a name="longest-common-subsequence-js"></a>
<pre>
// https://www.youtube.com/watch?v=NnD96abizww


function longestCommonSubsequence(str1, str2) {
  var dp = [];

  for(var i = 0 ; i <= str1.length; i++) {
    dp.push([]);
    for(var j = 0; j <= str2.length; j++) {
      dp[i].push(0);
    }
  }

  var result = [];

  for(i = 1 ; i <= str1.length; i++) {
    for(j = 1; j <= str2.length; j++) {
      if(str1[i-1] === str2[j-1]) {
        dp[i][j] = dp[i-1][j-1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
      }
    }
  }

  return dp[str1.length][str2.length];
}
</pre>
<hr />
</div>

<div>
<h3>Matrix Diagonal Traversal.js</h3>
<a name="matrix-diagonal-traversal-js"></a>
<pre>
// Print a N x M matrix in diagonal from the upper left to lower right.
// However, with the following caveat.
// It's easy to just show the input and expect output. 
// matrix: [
//   'abc',
//   'defg',
//   'hijk'
// ]
// output: aej bfk cg di h


// matrix: [
//   'abc',
//   'defgsb',
//   'hijk'
// ]
// output: aej bfk cg s b di h

function matrixDiagonalTraversal(matrix) {
  var maxLen = 0;
  for(var i = 0; i < matrix.length; i++) {
    maxLen = Math.max(matrix[i].length, maxLen);
  }

  for(i = 0; i < matrix.length; i++) {
    var row = matrix[i];
    var cnt = maxLen - row.length;
    
    while(cnt > 0) {
      matrix[i] += ' ';
      cnt--;
    }

    var leftStr = matrix[i].substring(i);

    var reversedRightStr = '';
    cnt = i;

    while(cnt > 0) {
      reversedRightStr += matrix[i][--cnt];
    }

    matrix[i] = leftStr + reversedRightStr;
  }

  var result = '';

  for(i = 0; i < maxLen; i++) {
    for(var j = 0; j < matrix.length; j++) {
      if(matrix[j][i] !== ' ') {
        result += matrix[j][i];  
      }
    }
  }

  return result;
}




console.log(matrixDiagonalTraversal([
  'abc',
  'defgsb',
  'hijk',
  'lm',
  'nopq'
]));


'abc___'
'deggsb'
'hijk__'
'lm____'
'nopq__'


'abc___'
'efgsbd'
'jk__ih'
'____ml'
'__qpon'
</pre>
<hr />
</div>

<div>
<h3>Maximum Sum Rectangular Submatrix in Matrix Dynamic Programming_2D.js</h3>
<a name="maximum-sum-rectangular-submatrix-in-matrix-dynamic-programming-2d-js"></a>
<pre>
/**
 * @param {number[]} nums
 * @return {number}
 */

 // Kadane's algo
function maxSubArray(nums) {
    var max = -Infinity;
    var curMax = 0;
    var beg = 0;
    var end = 0;
    
    for(var i = 0; i < nums.length; i++) {
        var val = nums[i];
        
        curMax += val;
        
        if(curMax > max) {
            end = i;
            max = curMax;
        }
        
        if(curMax < 0) {
            beg = i + 1;
            curMax = 0;
        }
    }
        
    return {
        max: max,
        beg: beg,
        end: end
    };
};


// https://www.youtube.com/watch?v=yCQN096CwWM

var sampleData = [
    [ 2, 1,-3,-4, 5],
    [ 0, 6, 3, 4, 1],
    [ 2,-2,-1, 4,-5],
    [-3, 3, 1, 0, 3]
]

// move from left to right
function maximumRectangularSubmatrix(matrix) {
    var row = matrix.length;
    var col = matrix[0].length;
    var max = -Infinity;
    var maxTop = 0;
    var maxLeft = 0;
    var maxRight = 0;
    var maxBottom = 0;

    for(var left = 0; left < col; left++){
      var subArray = [];
      
      for(var right = left; right < col; right++){
        for(var i = 0; i < row; i++) {
            subArray[i] = subArray[i] || 0;
            subArray[i] += matrix[i][right];
        }
        
        var info = maxSubArray(subArray);
      
        if(info.max > max) {
            max = info.max;
            maxLeft = left;
            maxRight = right;
            maxTop = info.beg;
            maxBottom = info.end;
        }
      }
    }

    return {
      max: max,
      left: maxLeft,
      right: maxRight,
      top: maxTop,
      bottom: maxBottom
    }
}

console.log(maximumRectangularSubmatrix(sampleData));
</pre>
<hr />
</div>

<div>
<h3>Merge Two Lists Into Sorted List.js</h3>
<a name="merge-two-lists-into-sorted-list-js"></a>
<pre>
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
 
// !!! we can concat two list together than use merge sort to sort the merged list

var sortList = function(head) {
    if(head === null) {
        return null;
    }
    
    var len = 0;
    var p = head;
    
    while(p) {
        len++;
        p = p.next;
    }
    
    var newHead = sort(len);
    
    return newHead;
    
    function sort(len) {
        // there will be no case of len = 0 which is caused by 1/2
        if(len === 1) {
            var temp = head;
            // !!! important: moving pointer to the next
            // e.g. 1->2->3->4
            // head-> 1
            // now head will be point to 2
            head = head.next; 
            temp.next = null;
            return temp;
        }
        // there will be no case of len = 0 which is caused by 1/2
        var leftHead = sort(parseInt(len/2));
        var rightHead = sort(len - parseInt(len/2));
        var newHead = merge(leftHead, rightHead);
        
        return newHead;
    }
    
    function merge(first, second) {
        var h = new ListNode(-1);
        var cur = h;
    
        while(first && second) {
            
            
            if(first.val <= second.val) {
                cur.next = first;
                first = first.next;
            } else {
                cur.next = second;
                second = second.next;
            }
            
            cur = cur.next;
        }
        
        if(first) {
            cur.next = first;
        }
        
        if(second) {
            cur.next = second;
        }
        
        cur = h.next;
        h.next = null;
        return cur;
    }
};
</pre>
<hr />
</div>

<div>
<h3>Min CPU Count.js</h3>
<a name="min-cpu-count-js"></a>
<pre>
// ??list of task, task???????,????,???cpu ??? ????cpu??????complete all task without cpu deficit

var minCPU = function(intervals) {
    var schedule = {};
    
    intervals.forEach((interval)=>{
        schedule[interval.start] = schedule[interval.start] || 0;
        schedule[interval.start] += interval.cpu;
        
        schedule[interval.end] = schedule[interval.end] || 0;
        schedule[interval.start] -= interval.cpu;
    });
    
    var maxCpu = 0;
    var curCpu = 0;
    
    for(var i in schedule) {
        curCpu += schedule[i];
        maxCpu = Math.max(maxCpu, curCpu);
    }
    
    return maxCpu;
};
</pre>
<hr />
</div>

<div>
<h3>Parse HTML.js</h3>
<a name="parse-html-js"></a>
<pre>
// Hulu


function parseHtml(htmlArr) {
  var context = [];
  var stack = [];
  
  for(var i = 0; i < htmlArr.length; i++){
    var htmlTag = htmlArr[i];
    
    if(htmlTag[0] === '/'){
      context = stack.pop();
    } else {
      var map = {};
      map[htmlTag] = [];
      context.push(map);
      stack.push(context);
      context = map[htmlTag];
    }
  }
  
  return context;
}




var htmlArr = [
  'html',
  'body',
  'div',
  'a',
  '/a',
  '/div',
  'div',
  'a',
  '/a',
  '/div',
  'div',
  'a',
  '/a',
  '/div',
  '/body',
  '/html'
];


console.log(parseHtml(htmlArr));
// will generate

/*
[{
  html: [{
    body: [{
      div: [{
        a: [{}]
      }]
    },{
      div: [{
        a: [{}]
      }]
    },{
      div: [{
        a: [{}]
      }]
    }]
  }]
}]
*/


</pre>
<hr />
</div>

<div>
<h3>Parse Log Top k Longest Running Job.js</h3>
<a name="parse-log-top-k-longest-running-job-js"></a>
<pre>

</pre>
<hr />
</div>

<div>
<h3>Parse String Into Array.js</h3>
<a name="parse-string-into-array-js"></a>
<pre>
// Given a string, parse it and return a string array.
// It's like a tokenizer, but the rules are too...
// For exmple, string="abc(edf)hij{klmn}opq[rst]uvw"
// Rule 1:
// The delimitors are (), {}, []. They are in pair.
// So output array: ["abc", "edf", "hij", "klmn", "opq", "rst", "uvw"]
// Rule 2:
// if any two consecutive "(" means escaping, that is "((" is actually output char "(".
// It's not part of the delimitor. Similar to ")", "{", "}", "[", "]". abc(e))df) =&gt; ["abc", "e)df"], since the "))" outpus ")".
// Rule 3: if "{" is inside a delimitor pair (), then "{" isn't part of the delimitor. Output it as is. abc(e{df}}g) =&gt; ["abc", "e{df}}g"]
// So, parse the given string and assume the given string is always valid and parsable.



function tokenizeString(str) {
  var result = [];
  var cur = '';
  var i = 0;

  while(i < str.length){
    var c = str[i];

    // Need to take care of [ && [[ && [[[
    // [123] -> ['123'], [[123]] --> ['[123]'], [[[123]]] -> ['[[123]]']
    if(c === '[' || c === '(' || c === '{') {
      if(cur !== '') {
        result.push(cur);
        cur = '';
      }
      var eq = escapeQuote(str, i + 1, c);
      result.push(eq[0]);
      i = eq[1];
      
    } else {
      cur += c;
      i++;
    }
  }

  if(cur !== '') {
    result.push(cur);
  }

  return result;

  function escapeQuote(str, i, quoteSym) {
    var quoteCnt = 1;
    var result = '';

    while(i < str.length) {
      var c = str[i]
      if(quoteSym === c) {
        quoteCnt++;
      } else if((quoteSym === '[' && c === ']') 
        || (quoteSym === '{' && c === '}')
        || (quoteSym === '(' && c === ')')
        ) {
        quoteCnt--;
      }

      i++;
      
      if(quoteCnt === 0) {
        break;
      }
      
      result += c;
    }

    return [result, i];
  }
}


var str = "abc(((edf)))hij{{klmn}}opq[rst]uvw";
// answer should be ['abc', '((edf))', 'hij', '{klmn}', 'opq', 'rst', 'uvw']

console.log(tokenizeString(str));
// [ 'abc', '((edf))', 'hij', '{klmn}', 'opq', 'rst', 'uvw' ] 

</pre>
<hr />
</div>

<div>
<h3>Ransom Note From Magazine.js</h3>
<a name="ransom-note-from-magazine-js"></a>
<pre>
// Kidnapper kidnaps you and writes a ransom note. He does not write it with hand, as handwriting can put him in, so reaches to a magazine at table and creates ransom note. We need to find out given ransom string and magazine string, is it possible to create given ransom note. Kidnapper can use individual characters of words.



function ransomNoteFromMagazine(magazine, ransom) {
  var hash = {};
  var mLen = magazine.length;
  var rLen = ransom.length;
  var mIdx = 0;
  var rIdx = 0;

  while(rIdx < rLen) {
    var rc = ransom[rIdx];

    if(hash[rc] === undefined || hash[rc] === 0) {
      var found = false;

      while(mIdx < mLen) {
        var mc = magazine[mIdx];
        hash[mc] = hash[mc] || 0;
        hash[mc]++;  
        mIdx++;

        if(mc === rc) {
          found = true;
          break;
        }
      }

      if(!found) {
        return false;
      }
    }

    hash[rc]--;
    rIdx++;
  }

  return true;
}

</pre>
<hr />
</div>

<div>
<h3>Rate Limiter.js</h3>
<a name="rate-limiter-js"></a>
<pre>
var RATE = 5;
var PER = 8;
var SECOND_IN_MS = 1000;

function* RateLimiter(rate, per, cbFunc) {
  var lastTime = Date.now();
  var rate = rate;
  var per = per;
  var allowance = rate;
  
  
  while(true){
    var currentTime = Date.now();
    var elapsedTime = (currentTime - lastTime)/SECOND_IN_MS;    
    lastTime = currentTime;
    allowance += elapsedTime*(rate/per);
    
    
    if(allowance > rate) {
      allowance = rate; 
    } 
    
    if(allowance < 1.0) {
      yield cbFunc(false); 
    } else {
      allowance -= 1;
      yield cbFunc(true);
    }
  } 
}

var rl = RateLimiter(RATE, PER, function(output){
  console.log(output)
});

rl.next();
rl.next();
rl.next();
rl.next();
rl.next();

rl.next();

setTimeout(()=>{
  rl.next();
  rl.next();
},PER/RATE*SECOND_IN_MS);
</pre>
<hr />
</div>

<div>
<h3>Reverse Integer.js</h3>
<a name="reverse-integer-js"></a>
<pre>
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    var isNeg = x < 0;
    var result = 0;
    
    x = Math.abs(x);
    
    while(x) {
        var lastDigit = x%10;
        result *= 10;
        result += lastDigit;
        x = parseInt(x/10);
    }

    result = isNeg ? -result : result;
    
    if(result > Math.pow(2,31) - 1 || result < -Math.pow(2,31)) {
        return 0;
    }
    
    return result;
};
</pre>
<hr />
</div>

<div>
<h3>Snake And Ladder.js</h3>
<a name="snake-and-ladder-js"></a>
<pre>
// Snake and Ladder Problem
// Given a snake and ladder board, find the minimum number of dice throws required to reach the destination or last cell from source or 1st cell. Basically, the player has total control over outcome of dice throw and wants to find out minimum number of throws required to reach last cell.

// If the player reaches a cell which is base of a ladder, the player has to climb up that ladder and if reaches a cell is mouth of the snake, has to go down to the tail of snake without a dice throw.

// snakesladders

// For example consider the board shown on right side (taken from here), the minimum number of dice throws required to reach cell 30 from cell 1 is 3. Following are steps.

// a) First throw two on dice to reach cell number 3 and then ladder to reach 22
// b) Then throw 6 to reach 28.
// c) Finally through 2 to reach 30.

// There can be other solutions as well like (2, 2, 6), (2, 4, 4), (2, 3, 5).. etc.



function snakeAndLadder(moves, n){
  var visited = Array(n).fill(false);
  visited[0] = true;
  var queue = [];
  queue.push(0);

  var dist = 0;
  
  while(queue.length > 0) {
    var len = queue.length;

    for(var j = 0; j < len; j++) {
      var move = queue.shift();
      
      if(move === n - 1) {
        return dist;
      }
      
      for(var i = move + 1; i <= move + 6; i++) {
        
        if(!visited[i]) {

          visited[i] = true;  
        
          if(moves[i] !== -1) {
            newMove = moves[i];
          } else {
            newMove = i;
          }
          
          queue.push(newMove);
        }
      }
    }

    dist++;
  }
  
  return -1;
}

var moves = [];
var n = 100;
for(var i = 0; i < n; i++){
  moves.push(-1);
}

moves[2] = 53;
moves[41] = 99;
moves[54] = 40;


console.log(snakeAndLadder(moves, n));
</pre>
<hr />
</div>

<div>
<h3>String Encoding and Decoding.js</h3>
<a name="string-encoding-and-decoding-js"></a>
<pre>
public class Codec {

    // Encodes a list of strings to a single string.
    public String encode(List<String> strs) {
        StringBuilder output = new StringBuilder();
        for(String str : strs){
            // ??????,?????????,?#??
            output.append(String.valueOf(str.length())+"#");
            // ??????????
            output.append(str);
        }
        return output.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        List<String> res = new LinkedList<String>();
        int start = 0;
        while(start < s.length()){
            // ???start??????#,??#?????
            int idx = s.indexOf('#', start);
            int size = Integer.parseInt(s.substring(start, idx));
            // ??????????
            res.add(s.substring(idx + 1, idx + size + 1));
            // ??start?????????
            start = idx + size + 1;
        }
        return res;
    }
}
</pre>
<hr />
</div>

<div>
<h3>Top k Longest Running Job.js</h3>
<a name="top-k-longest-running-job-js"></a>
<pre>
// parse log?
// log?????????????????jobname???????????
// ??jobname??????jobid???jobid????endtime?
// ??,print out ?k???????????jobname??????endtime?


// jobname, jobid, endtime

// hash1: jobname->endtime:
//   store the longest endtime for that job
// hash2: jobid->jobname 
//   not sure what it's for

// use min heap to store the top k longest running one




</pre>
<hr />
</div>

<div>
<h3>URL shortening.js</h3>
<a name="url-shortening-js"></a>
<pre>
// http://www.hiredintech.com/system-design/the-system-design-process/





Use Cases:

1. shortening: take url => return a shorter url
2. redirection: take a short url => redirect to the original url

high availability of the system

traffic?

how many request per sec?
how many new url per sec?

10% shortening 90% from redirection

data?



out of scope
3. custom url
4. analytics
5. automatic link expriation
6. manual link removal
7. UI vs API
</pre>
<hr />
</div>

<div>
<h3>Weighted Job Scheduling.js</h3>
<a name="weighted-job-scheduling-js"></a>
<pre>
// C++ program for weighted job scheduling using Dynamic 
// Programming and Binary Search
#include <iostream>
#include <algorithm>
using namespace std;
 
// A job has start time, finish time and profit.
struct Job
{
    int start, finish, profit;
};
 
// A utility function that is used for sorting events
// according to finish time
bool myfunction(Job s1, Job s2)
{
    return (s1.finish < s2.finish);
}
 
// A Binary Search based function to find the latest job
// (before current job) that doesn't conflict with current
// job.  "index" is index of the current job.  This function
// returns -1 if all jobs before index conflict with it.
// The array jobs[] is sorted in increasing order of finish
// time.
int binarySearch(Job jobs[], int index)
{
    // Initialize 'lo' and 'hi' for Binary Search
    int lo = 0, hi = index - 1;
 
    // Perform binary Search iteratively
    while (lo <= hi)
    {
        int mid = (lo + hi) / 2;
        if (jobs[mid].finish <= jobs[index].start)
        {
            if (jobs[mid + 1].finish <= jobs[index].start)
                lo = mid + 1;
            else
                return mid;
        }
        else
            hi = mid - 1;
    }
 
    return -1;
}
 
// The main function that returns the maximum possible
// profit from given array of jobs
int findMaxProfit(Job arr[], int n)
{
    // Sort jobs according to finish time
    sort(arr, arr+n, myfunction);
 
    // Create an array to store solutions of subproblems.  table[i]
    // stores the profit for jobs till arr[i] (including arr[i])
    int *table = new int[n];
    table[0] = arr[0].profit;
 
    // Fill entries in table[] using recursive property
    for (int i=1; i<n; i++)
    {
        // Find profit including the current job
        int inclProf = arr[i].profit;
        int l = binarySearch(arr, i);
        if (l != -1)
            inclProf += table[l];
 
        // Store maximum of including and excluding
        table[i] = max(inclProf, table[i-1]);
    }
 
    // Store result and free dynamic memory allocated for table[]
    int result = table[n-1];
    delete[] table;
 
    return result;
}
 
// Driver program
int main()
{
    Job arr[] = {{3, 10, 20}, {1, 2, 50}, {6, 19, 100}, {2, 100, 200}};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Optimal profit is " << findMaxProfit(arr, n);
    return 0;
}
</pre>
<hr />
</div>

<div>
<h3>ZigZag Conversion.js</h3>
<a name="zigzag-conversion-js"></a>
<pre>
// Ref: http://www.cnblogs.com/springfor/p/3889414.html
// The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

// P   A   H   N
// A P L S I I G
// Y   I   R
// And then read line by line: "PAHNAPLSIIGYIR"
// Write the code that will take a string and make this conversion given a number of rows:

// string convert(string text, int nRows);
// convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".


/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  if(s === null || s.length === 0 || numRows <= 0) {
    return "";
  }
  
  if(numRows === 1) {
    return s;
  }
  
  var res = '';
  var size = 2 * numRows - 2;
  
  for(var i = 0; i < numRows; i++) {
    for(var j = i; j < s.length; j += size) {
      res += s[j];
      
      if(i !== 0 && i !== numRows - 1) { // except first and last row
        var tmp = j + size - 2 * i;
        if(tmp < s.length) {
          res += s[tmp];
        }
      }
    }
  }
  
  return res;
};
</pre>
<hr />
</div>

<div>
<h3>find kth element in two arrays.js</h3>
<a name="find-kth-element-in-two-arrays-js"></a>
<pre>
var findKth = (a1, a2, kth) => {
  var alen1 = a1.length;
  var alen2 = a2.length;
  
  if(alen1 > alen2) {
    return findKth(a2, a1, kth);
  }
  
  if(alen1 === 0) {
    return a2[kth -1];
  }
  
  if(kth === 1) {
    return Math.min(a1[0], a2[0]);
  }
  
//   need to make sure that kth is not 1 as kth/2 = 0 
  var p1 = Math.min(parseInt(kth/2), alen1);
  var p2 = kth - p1;
  
  if(a1[p1 - 1] < a2[p2 - 1]) {
     return findKth(a1.slice(p1), a2, kth - p1);
  } else if(a1[p1 - 1] > a2[p2 - 1]) {
    return findKth(a1, a2.slice(p2), kth - p2);
  } else {
    return a1[p1 - 1]; 
  }
}


// function findKth(a, aStart, aEnd, b, bStart, bEnd, kth) {
//     // use array position rather than use slice to get array
//     // always assume that m is equal or smaller than n
//     var aLen = aEnd - aStart + 1; // same as a.length as index 3 - 3 = 0 but still it has one element compared to a.length === 0 has notthing
//     var bLen = bEnd - bStart + 1;
//     var mid;
//     if(aLen > bLen) {
//         return findKth(b, bStart, bEnd, a, aStart, aEnd, kth);
//     }
    
//     if(aLen <= 0) {
//         return b[kth - 1];
//     }
    
//     if(kth === 1) {
//         return Math.min(a[aStart], b[bStart]);
//     }
    
//     var k1 = Math.min(parseInt(kth/2), aLen); 
//     var k2 = kth - k1;
    
//     if(a[aStart + k1 - 1] < b[bStart + k2 - 1]) {
//         return findKth(a, aStart + k1, aEnd, b, bStart, bEnd, kth -k1);
//     } else if(a[aStart + k1 - 1] > b[bStart + k2 - 1]) {
//         return findKth(a, aStart, aEnd, b, bStart + k2, bEnd, kth -k2);
//     } else {
//         return a[aStart + k1 -1];
//     }
// }
</pre>
<hr />
</div>

<div>
<h3>flatten nested array.js</h3>
<a name="flatten-nested-array-js"></a>
<pre>
var arr = [1,2,[3,4,[5,[6]],7],8,9];

function flatten(arr) {
  return arr.reduce(function(self, el){
    var items = Array.isArray(el) ? flatten(el) : [el];
    return self.concat(items);
  }, []);
}

function flatten(array, result) {
    result === undefined && (result = []);

    for (var i = 0, len = array.length; i < len; i++) {
        if (Object.prototype.toString.call(array[i]) === '[object Array]') {
            flatten(array[i], result);
        } else {
            result.push(array[i]);
        }
    }

    return result;
}

console.log(flatten(arr));
</pre>
<hr />
</div>



</body>
</html>
